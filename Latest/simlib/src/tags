!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
A	ni_euler.h	/^  Memory si, di, A;  \/\/ auxiliary memories$/;"	m	class:simlib3::EULER	access:private
A1	ni_rke.h	/^  Memory A1, A2, A3, A4, A5, A6, A7;  \/\/ auxiliary memories$/;"	m	class:simlib3::RKE	access:private
A1	ni_rkf3.h	/^  Memory A1, A2, A3;  \/\/ auxiliary memories$/;"	m	class:simlib3::RKF3	access:private
A1	ni_rkf5.h	/^  Memory A1, A2, A3, A4, A5, A6;  \/\/ auxiliary memories$/;"	m	class:simlib3::RKF5	access:private
A1	ni_rkf8.h	/^  Memory A1, A2, A3,  A4,  A5,  A6, A7;  \/\/ auxiliary memories$/;"	m	class:simlib3::RKF8	access:private
A10	ni_rkf8.h	/^  Memory A8, A9, A10, A11, A12, A13;$/;"	m	class:simlib3::RKF8	access:private
A11	ni_rkf8.h	/^  Memory A8, A9, A10, A11, A12, A13;$/;"	m	class:simlib3::RKF8	access:private
A12	ni_rkf8.h	/^  Memory A8, A9, A10, A11, A12, A13;$/;"	m	class:simlib3::RKF8	access:private
A13	ni_rkf8.h	/^  Memory A8, A9, A10, A11, A12, A13;$/;"	m	class:simlib3::RKF8	access:private
A2	ni_rke.h	/^  Memory A1, A2, A3, A4, A5, A6, A7;  \/\/ auxiliary memories$/;"	m	class:simlib3::RKE	access:private
A2	ni_rkf3.h	/^  Memory A1, A2, A3;  \/\/ auxiliary memories$/;"	m	class:simlib3::RKF3	access:private
A2	ni_rkf5.h	/^  Memory A1, A2, A3, A4, A5, A6;  \/\/ auxiliary memories$/;"	m	class:simlib3::RKF5	access:private
A2	ni_rkf8.h	/^  Memory A1, A2, A3,  A4,  A5,  A6, A7;  \/\/ auxiliary memories$/;"	m	class:simlib3::RKF8	access:private
A3	ni_rke.h	/^  Memory A1, A2, A3, A4, A5, A6, A7;  \/\/ auxiliary memories$/;"	m	class:simlib3::RKE	access:private
A3	ni_rkf3.h	/^  Memory A1, A2, A3;  \/\/ auxiliary memories$/;"	m	class:simlib3::RKF3	access:private
A3	ni_rkf5.h	/^  Memory A1, A2, A3, A4, A5, A6;  \/\/ auxiliary memories$/;"	m	class:simlib3::RKF5	access:private
A3	ni_rkf8.h	/^  Memory A1, A2, A3,  A4,  A5,  A6, A7;  \/\/ auxiliary memories$/;"	m	class:simlib3::RKF8	access:private
A4	ni_rke.h	/^  Memory A1, A2, A3, A4, A5, A6, A7;  \/\/ auxiliary memories$/;"	m	class:simlib3::RKE	access:private
A4	ni_rkf5.h	/^  Memory A1, A2, A3, A4, A5, A6;  \/\/ auxiliary memories$/;"	m	class:simlib3::RKF5	access:private
A4	ni_rkf8.h	/^  Memory A1, A2, A3,  A4,  A5,  A6, A7;  \/\/ auxiliary memories$/;"	m	class:simlib3::RKF8	access:private
A5	ni_rke.h	/^  Memory A1, A2, A3, A4, A5, A6, A7;  \/\/ auxiliary memories$/;"	m	class:simlib3::RKE	access:private
A5	ni_rkf5.h	/^  Memory A1, A2, A3, A4, A5, A6;  \/\/ auxiliary memories$/;"	m	class:simlib3::RKF5	access:private
A5	ni_rkf8.h	/^  Memory A1, A2, A3,  A4,  A5,  A6, A7;  \/\/ auxiliary memories$/;"	m	class:simlib3::RKF8	access:private
A6	ni_rke.h	/^  Memory A1, A2, A3, A4, A5, A6, A7;  \/\/ auxiliary memories$/;"	m	class:simlib3::RKE	access:private
A6	ni_rkf5.h	/^  Memory A1, A2, A3, A4, A5, A6;  \/\/ auxiliary memories$/;"	m	class:simlib3::RKF5	access:private
A6	ni_rkf8.h	/^  Memory A1, A2, A3,  A4,  A5,  A6, A7;  \/\/ auxiliary memories$/;"	m	class:simlib3::RKF8	access:private
A7	ni_rke.h	/^  Memory A1, A2, A3, A4, A5, A6, A7;  \/\/ auxiliary memories$/;"	m	class:simlib3::RKE	access:private
A7	ni_rkf8.h	/^  Memory A1, A2, A3,  A4,  A5,  A6, A7;  \/\/ auxiliary memories$/;"	m	class:simlib3::RKF8	access:private
A8	ni_rkf8.h	/^  Memory A8, A9, A10, A11, A12, A13;$/;"	m	class:simlib3::RKF8	access:private
A9	ni_rkf8.h	/^  Memory A8, A9, A10, A11, A12, A13;$/;"	m	class:simlib3::RKF8	access:private
ABM4	ni_abm4.h	/^  ABM4(const char* name, const char* slave_name):$/;"	f	class:simlib3::ABM4	access:public	signature:(const char* name, const char* slave_name)
ABM4	ni_abm4.h	/^class ABM4 : public MultiStepMethod {$/;"	c	namespace:simlib3	inherits:MultiStepMethod
ABM_Count	ni_abm4.h	/^  int ABM_Count;  \/\/ # of start steps (done by starting method)$/;"	m	class:simlib3::ABM4	access:private
ACos	fun.cc	/^Input ACos(Input x)             { return new Function1(x, acos); }$/;"	f	namespace:simlib3	signature:(Input x)
ACos	simlib.h	/^Input ACos(Input x);            \/\/ acos(x)$/;"	p	namespace:simlib3	signature:(Input x)
ALLOC_CONTEXT	process.cc	169;"	d	file:
AL_BadBounds	errors.h	/^\/* 63 *\/ AL_BadBounds,$/;"	e	enum:_ErrEnum
AL_BadInitVal	errors.h	/^\/* 64 *\/ AL_BadInitVal,$/;"	e	enum:_ErrEnum
AL_Diverg	errors.h	/^\/* 65 *\/ AL_Diverg,$/;"	e	enum:_ErrEnum
AL_MaxCount	errors.h	/^\/* 66 *\/ AL_MaxCount,$/;"	e	enum:_ErrEnum
AL_NotInLoop	errors.h	/^\/* 67 *\/ AL_NotInLoop,$/;"	e	enum:_ErrEnum
ASin	fun.cc	/^Input ASin(Input x)             { return new Function1(x, asin); }$/;"	f	namespace:simlib3	signature:(Input x)
ASin	simlib.h	/^Input ASin(Input x);            \/\/ asin(x)$/;"	p	namespace:simlib3	signature:(Input x)
ATan	fun.cc	/^Input ATan(Input x)             { return new Function1(x, atan); }$/;"	f	namespace:simlib3	signature:(Input x)
ATan	simlib.h	/^Input ATan(Input x);            \/\/ atan(x)$/;"	p	namespace:simlib3	signature:(Input x)
ATan2	fun.cc	/^Input ATan2(Input y, Input x)   { return new Function2(y, x, atan2); }$/;"	f	namespace:simlib3	signature:(Input y, Input x)
ATan2	simlib.h	/^Input ATan2(Input y, Input x);  \/\/ atan2(y,x)$/;"	p	namespace:simlib3	signature:(Input y, Input x)
Abort	run.cc	/^void Abort()$/;"	f	namespace:simlib3	signature:()
Abort	simlib.h	/^void Abort();$/;"	p	namespace:simlib3	signature:()
Abs	fun.cc	/^Input Abs(Input x)              { return new Function1(x, fabs); }$/;"	f	namespace:simlib3	signature:(Input x)
Abs	simlib.h	/^Input Abs(Input x);             \/\/ abs(x)     absolute value$/;"	p	namespace:simlib3	signature:(Input x)
Abs	simlib2D.cc	/^Input Abs(Input2D x) { return new _Abs2D(x); } \/\/ absolute value of vector x$/;"	f	namespace:simlib3	signature:(Input2D x)
Abs	simlib2D.h	/^Input Abs(Input2D x);$/;"	p	namespace:simlib3	signature:(Input2D x)
Abs	simlib3D.cc	/^Input Abs(Input3D x) { return new _Abs3D(x); } \/\/ absolute value of vector x$/;"	f	namespace:simlib3	signature:(Input3D x)
Abs	simlib3D.h	/^Input   Abs(Input3D x);$/;"	p	namespace:simlib3	signature:(Input3D x)
AbsoluteError	intg.cc	/^const double &AbsoluteError=SIMLIB_AbsoluteError; \/\/!< max. abs. error of integration$/;"	m	namespace:simlib3	file:
AccuracyError	errors.h	/^\/* 13 *\/ AccuracyError,$/;"	e	enum:_ErrEnum
Action	simlib.h	/^  virtual void Action()=0;                \/\/ state event$/;"	p	class:simlib3::ConditionDown	access:public	signature:()
Action	simlib.h	/^  virtual void Action()=0;             \/\/ state event$/;"	p	class:simlib3::Condition	access:public	signature:()
Action	simlib.h	/^  virtual void Action()=0;             \/\/ state event$/;"	p	class:simlib3::ConditionUp	access:public	signature:()
Action	simlib.h	/^  virtual void Action()=0;             \/\/!< state event description$/;"	p	class:simlib3::aCondition	access:private	signature:()
Activate	entity.cc	/^void Entity::Activate(double t)$/;"	f	class:simlib3::Entity	signature:(double t)
Activate	process.cc	/^void Process::Activate(double t)$/;"	f	class:simlib3::Process	signature:(double t)
Activate	simlib.h	/^    virtual void Activate(double t);    \/\/!< activate at time t (schedule)$/;"	p	class:simlib3::Entity	access:public	signature:(double t)
Activate	simlib.h	/^    void Activate() { Activate(Time); } \/\/!< activate now$/;"	f	class:simlib3::Entity	access:public	signature:()
Activate	simlib.h	/^  virtual void Activate(double t);      \/\/!< activate at time t (schedule)$/;"	p	class:simlib3::Process	access:public	signature:(double t)
Activate	simlib.h	/^inline void Activate(Entity *e)  { e->Activate(); }   \/\/!< activate entity e$/;"	f	namespace:simlib3	signature:(Entity *e)
ActivateAll	sampler.cc	/^void Sampler::ActivateAll()$/;"	f	class:simlib3::Sampler	signature:()
ActivateAll	simlib.h	/^    static void ActivateAll();      \/\/!< start all samplers (Run)$/;"	p	class:simlib3::Sampler	access:private	signature:()
ActivationTime	calendar.cc	/^double Entity::ActivationTime() { \/\/ activation time$/;"	f	class:simlib3::Entity	signature:()
ActivationTime	simlib.h	/^    double ActivationTime();            \/\/ get activation time if scheduled$/;"	p	class:simlib3::Entity	access:public	signature:()
Adaptor2D	simlib2D.h	/^  Adaptor2D(Input _x, Input _y) : x(_x), y(_y) {}$/;"	f	class:simlib3::Adaptor2D	access:public	signature:(Input _x, Input _y)
Adaptor2D	simlib2D.h	/^class Adaptor2D : public aContiBlock2D {$/;"	c	namespace:simlib3	inherits:aContiBlock2D
Adaptor3D	simlib3D.h	/^  Adaptor3D(Input _x, Input _y, Input _z) : x(_x), y(_y), z(_z) {}$/;"	f	class:simlib3::Adaptor3D	access:public	signature:(Input _x, Input _y, Input _z)
Adaptor3D	simlib3D.h	/^class Adaptor3D : public aContiBlock3D {$/;"	c	namespace:simlib3	inherits:aContiBlock3D
AlgLoop	algloop.cc	/^AlgLoop::AlgLoop(Input i, double eps, unsigned long max_it,$/;"	f	class:simlib3::AlgLoop	signature:(Input i, double eps, unsigned long max_it, double t_min, double t_max, double t0)
AlgLoop	simlib.h	/^  AlgLoop(Input i, double eps, unsigned long max_it, \/\/ constructor$/;"	p	class:simlib3::AlgLoop	access:public	signature:(Input i, double eps, unsigned long max_it, double t_min, double t_max, double t0)
AlgLoop	simlib.h	/^class AlgLoop : public aContiBlock1 {$/;"	c	namespace:simlib3	inherits:aContiBlock1
AlgLoopDetected	errors.h	/^\/* 55 *\/ AlgLoopDetected,$/;"	e	enum:_ErrEnum
AlgLoopDetector	internal.h	/^    AlgLoopDetector(aContiBlock *x): block(x)  { lock(); }$/;"	f	class:simlib3::AlgLoopDetector	access:public	signature:(aContiBlock *x)
AlgLoopDetector	internal.h	/^class AlgLoopDetector {$/;"	c	namespace:simlib3
AllActions	cond.cc	/^void aCondition::AllActions()$/;"	f	class:simlib3::aCondition	signature:()
AllActions	simlib.h	/^  static void AllActions();$/;"	p	class:simlib3::aCondition	access:public	signature:()
Alloc	histo.cc	/^static unsigned *Alloc(unsigned n)$/;"	f	namespace:simlib3	signature:(unsigned n)
Backlash	simlib.h	/^typedef Blash Backlash; \/\/ alias$/;"	t	namespace:simlib3
BadQntzrStep	errors.h	/^\/* 57 *\/ BadQntzrStep,$/;"	e	enum:_ErrEnum
BadUniformParam	errors.h	/^\/* 60 *\/ BadUniformParam,$/;"	e	enum:_ErrEnum
Barrier	barrier.cc	/^Barrier::Barrier(const char *name, unsigned height):$/;"	f	class:simlib3::Barrier	signature:(const char *name, unsigned height)
Barrier	barrier.cc	/^Barrier::Barrier(unsigned height):$/;"	f	class:simlib3::Barrier	signature:(unsigned height)
Barrier	simlib.h	/^  Barrier(const Barrier&);              \/\/ ## disable$/;"	p	class:simlib3::Barrier	access:private	signature:(const Barrier&)
Barrier	simlib.h	/^  Barrier(const char *_name, unsigned N);$/;"	p	class:simlib3::Barrier	access:public	signature:(const char *_name, unsigned N)
Barrier	simlib.h	/^  Barrier(unsigned N);$/;"	p	class:simlib3::Barrier	access:public	signature:(unsigned N)
Barrier	simlib.h	/^class Barrier : public SimObject {$/;"	c	namespace:simlib3	inherits:SimObject
Begin	simlib.h	/^  static iterator Begin(void) {$/;"	f	class:simlib3::IntegratorContainer	access:public	signature:(void)
Begin	simlib.h	/^  static iterator Begin(void) {$/;"	f	class:simlib3::StatusContainer	access:public	signature:(void)
Behavior	_test_.cc	/^  void Behavior() {$/;"	f	class:TestProcess	access:public	signature:()
Behavior	graph.cc	/^void Graph::Behavior()$/;"	f	class:simlib3::Graph	signature:()
Behavior	sampler.cc	/^void Sampler::Behavior() {$/;"	f	class:simlib3::Sampler	signature:()
Behavior	simlib.h	/^    virtual void Behavior(); \/\/!< behavior description$/;"	p	class:simlib3::Sampler	access:protected	signature:()
Behavior	simlib.h	/^  virtual void Behavior() = 0;          \/\/!< behavior description$/;"	p	class:simlib3::Process	access:public	signature:()
Behavior	simlib.h	/^  virtual void Behavior() = 0;    \/\/!< behavior description$/;"	p	class:simlib3::Event	access:public	signature:()
Behavior	zdelay.cc	/^void ZDelayTimer::Behavior()$/;"	f	class:simlib3::ZDelayTimer	signature:()
Behavior	zdelay.h	/^    void Behavior();$/;"	p	class:simlib3::ZDelayTimer	access:public	signature:()
Beta	random2.cc	/^double Beta(double th, double fi, double min, double max)$/;"	f	namespace:simlib3	signature:(double th, double fi, double min, double max)
Beta	simlib.h	/^double Beta(double th, double fi, double min, double max);$/;"	p	namespace:simlib3	signature:(double th, double fi, double min, double max)
Bisect	simlib.h	/^  Bisect(Input i, double eps, unsigned long max_it,$/;"	f	class:simlib3::Bisect	access:public	signature:(Input i, double eps, unsigned long max_it, double t_min, double t_max)
Bisect	simlib.h	/^class Bisect : public AlgLoop {$/;"	c	namespace:simlib3	inherits:AlgLoop
Blash	simlib.h	/^  Blash(Input i, double p1, double p2, double tga);$/;"	p	class:simlib3::Blash	access:public	signature:(Input i, double p1, double p2, double tga)
Blash	simlib.h	/^class Blash : public Status {    \/\/ backlash$/;"	c	namespace:simlib3	inherits:Status
Blash	stdblock.cc	/^Blash::Blash(Input i, double _p1, double _p2, double _tga)$/;"	f	class:simlib3::Blash	signature:(Input i, double _p1, double _p2, double _tga)
Boolean	generr.c	/^enum Boolean { FALSE, TRUE };$/;"	g	file:
Break	barrier.cc	/^int Barrier::Break() {$/;"	f	class:simlib3::Barrier	signature:()
Break	simlib.h	/^  virtual int Break();                  \/\/!< activate all waiting entities$/;"	p	class:simlib3::Barrier	access:public	signature:()
BucketList	calendar.cc	/^    typedef CalendarListImplementation BucketList;$/;"	t	class:simlib3::CalendarQueue	file:	access:private
Buffer	delay.cc	/^struct Delay::Buffer {$/;"	s	class:simlib3::Delay	file:
Buffer	delay.h	/^    struct Buffer {$/;"	s	class:simlib3::Delay	access:public
Busy	simlib.h	/^  bool Busy() const { return in!=0; }$/;"	f	class:simlib3::Facility	access:public	signature:() const
CALL_HOOK	internal.h	262;"	d
CANARY1	process.cc	355;"	d	file:
CANARY2	process.cc	511;"	d	file:
CHECKENTITY	facility.cc	33;"	d	file:
CHECKQUEUE	facility.cc	32;"	d	file:
CHECKQUEUE	store.cc	33;"	d	file:
COEF_PAR	calendar.cc	/^const double COEF_PAR     = 1.5;  \/\/ TODO:tune parameter: cca 1.5$/;"	m	namespace:simlib3	file:
Calendar	calendar.cc	/^    Calendar(): _size(0), mintime(SIMLIB_MAXTIME) {}$/;"	f	class:simlib3::Calendar	access:protected	signature:()
Calendar	calendar.cc	/^class Calendar { \/\/ abstract base class$/;"	c	namespace:simlib3	file:
CalendarList	calendar.cc	/^    CalendarList() {$/;"	f	class:simlib3::CalendarList	file:	access:private	signature:()
CalendarList	calendar.cc	/^class CalendarList : public Calendar {$/;"	c	namespace:simlib3	file:	inherits:Calendar
CalendarListImplementation	calendar.cc	/^    CalendarListImplementation() { }$/;"	f	class:simlib3::CalendarListImplementation	access:public	signature:()
CalendarListImplementation	calendar.cc	/^class CalendarListImplementation {$/;"	c	namespace:simlib3	file:
CalendarQueue	calendar.cc	/^    CalendarQueue();$/;"	p	class:simlib3::CalendarQueue	file:	access:private	signature:()
CalendarQueue	calendar.cc	/^CalendarQueue::CalendarQueue():$/;"	f	class:simlib3::CalendarQueue	signature:()
CalendarQueue	calendar.cc	/^class CalendarQueue : public Calendar {$/;"	c	namespace:simlib3	file:	inherits:Calendar
Cancel	simlib.h	/^    void Cancel() { Terminate(); }      \/\/!< end Behavior() and remove entity$/;"	f	class:simlib3::Entity	access:public	signature:()
CantCloseOutFile	errors.h	/^\/* 54 *\/ CantCloseOutFile,$/;"	e	enum:_ErrEnum
CantCreateIntg	errors.h	/^\/* 31 *\/ CantCreateIntg,$/;"	e	enum:_ErrEnum
CantCreateStatus	errors.h	/^\/* 33 *\/ CantCreateStatus,$/;"	e	enum:_ErrEnum
CantDestroyIntg	errors.h	/^\/* 32 *\/ CantDestroyIntg,$/;"	e	enum:_ErrEnum
CantDestroyStatus	errors.h	/^\/* 34 *\/ CantDestroyStatus,$/;"	e	enum:_ErrEnum
CantOpenOutFile	errors.h	/^\/* 53 *\/ CantOpenOutFile,$/;"	e	enum:_ErrEnum
Capacity	simlib.h	/^  unsigned long Capacity() const { return capacity; }   \/\/!< max capacity$/;"	f	class:simlib3::Store	access:public	signature:() const
Change	simlib.h	/^  bool Change() { return ccl!=cc; }     \/\/ both changes$/;"	f	class:simlib3::Condition	access:protected	signature:()
ChangeHeight	barrier.cc	/^void Barrier::ChangeHeight(unsigned new_height) {$/;"	f	class:simlib3::Barrier	signature:(unsigned new_height)
ChangeHeight	simlib.h	/^  void ChangeHeight(unsigned new_maxn);         \/\/!< change size$/;"	p	class:simlib3::Barrier	access:public	signature:(unsigned new_maxn)
CheckUniq	generr.c	/^int CheckUniq(TABLE * t)$/;"	f	signature:(TABLE * t)
Clear	barrier.cc	/^void Barrier::Clear() {$/;"	f	class:simlib3::Barrier	signature:()
Clear	calendar.cc	/^void SQS::Clear() {                       \/\/ remove all$/;"	f	class:simlib3::SQS	signature:()
Clear	facility.cc	/^void Facility::Clear()$/;"	f	class:simlib3::Facility	signature:()
Clear	histo.cc	/^void Histogram::Clear()$/;"	f	class:simlib3::Histogram	signature:()
Clear	internal.h	/^    void Clear();                        \/\/ remove all items$/;"	p	namespace:simlib3::SQS	signature:()
Clear	semaphor.cc	/^void Semaphore::Clear() {$/;"	f	class:simlib3::Semaphore	signature:()
Clear	simlib.h	/^    void Clear()  { clear(); }$/;"	f	class:simlib3::Queue	access:public	signature:()
Clear	simlib.h	/^  virtual void Clear() = 0;                 \/\/ initialize$/;"	p	class:simlib3::aStat	access:public	signature:()
Clear	simlib.h	/^  virtual void Clear();                                 \/\/!< initialize$/;"	p	class:simlib3::Store	access:public	signature:()
Clear	simlib.h	/^  virtual void Clear();                          \/\/!< initialize$/;"	p	class:simlib3::Facility	access:public	signature:()
Clear	simlib.h	/^  virtual void Clear();                         \/\/!< initialization$/;"	p	class:simlib3::Semaphore	access:public	signature:()
Clear	simlib.h	/^  virtual void Clear();                 \/\/!< initialization$/;"	p	class:simlib3::Barrier	access:public	signature:()
Clear	simlib.h	/^  virtual void Clear();                \/\/ initialize (zero) value array$/;"	p	class:simlib3::Histogram	access:public	signature:()
Clear	simlib.h	/^  virtual void Clear();         \/\/!< initialize$/;"	p	class:simlib3::Stat	access:public	signature:()
Clear	simlib.h	/^  virtual void Clear(double initval=0.0);        \/\/!< initialize$/;"	p	class:simlib3::TStat	access:public	signature:(double initval=0.0)
Clear	stat.cc	/^void Stat::Clear()$/;"	f	class:simlib3::Stat	signature:()
Clear	store.cc	/^void Store::Clear()$/;"	f	class:simlib3::Store	signature:()
Clear	tstat.cc	/^void TStat::Clear(double initval)$/;"	f	class:simlib3::TStat	signature:(double initval)
ClearAllValueOK	intg.cc	/^void StatusContainer::ClearAllValueOK()$/;"	f	class:simlib3::StatusContainer	signature:()
ClearAllValueOK	simlib.h	/^  static void ClearAllValueOK();   \/\/ invalidate values of all items$/;"	p	class:simlib3::StatusContainer	access:public	signature:()
Condition	cond.cc	/^Condition::Condition(Input i) :$/;"	f	class:simlib3::Condition	signature:(Input i)
Condition	simlib.h	/^  Condition(Input i);$/;"	p	class:simlib3::Condition	access:public	signature:(Input i)
Condition	simlib.h	/^class Condition : public aCondition {  \/\/ state condition$/;"	c	namespace:simlib3	inherits:aCondition
ConditionDown	simlib.h	/^  ConditionDown(Input i) : Condition(i) {}$/;"	f	class:simlib3::ConditionDown	access:public	signature:(Input i)
ConditionDown	simlib.h	/^class ConditionDown : public Condition { \/\/ state event on TRUE-->FALSE change$/;"	c	namespace:simlib3	inherits:Condition
ConditionUp	simlib.h	/^  ConditionUp(Input i) : Condition(i) {}$/;"	f	class:simlib3::ConditionUp	access:public	signature:(Input i)
ConditionUp	simlib.h	/^class ConditionUp : public Condition { \/\/ state event on FALSE-->TRUE change$/;"	c	namespace:simlib3	inherits:Condition
Constant	simlib.h	/^  Constant(double x) : value(x) {}$/;"	f	class:simlib3::Constant	access:public	signature:(double x)
Constant	simlib.h	/^class Constant : public aContiBlock {$/;"	c	namespace:simlib3	inherits:aContiBlock
Constant2D	simlib2D.h	/^  explicit Constant2D(Value2D x) : value(x) {}$/;"	f	class:simlib3::Constant2D	access:public	signature:(Value2D x)
Constant2D	simlib2D.h	/^  explicit Constant2D(double x, double y) : value(x,y) {}$/;"	f	class:simlib3::Constant2D	access:public	signature:(double x, double y)
Constant2D	simlib2D.h	/^class Constant2D : public aContiBlock2D {$/;"	c	namespace:simlib3	inherits:aContiBlock2D
Constant3D	simlib3D.h	/^  explicit Constant3D(Value3D x) : value(x) {}$/;"	f	class:simlib3::Constant3D	access:public	signature:(Value3D x)
Constant3D	simlib3D.h	/^  explicit Constant3D(double x, double y, double z) : value(x,y,z) {}$/;"	f	class:simlib3::Constant3D	access:public	signature:(double x, double y, double z)
Constant3D	simlib3D.h	/^class Constant3D : public aContiBlock3D {$/;"	c	namespace:simlib3	inherits:aContiBlock3D
ContractStep	intg.cc	/^void ContractStep() {$/;"	f	namespace:simlib3	signature:()
ContractStep	intg.cc	/^void ContractStep(double time)$/;"	f	namespace:simlib3	signature:(double time)
ContractStep	simlib.h	/^void ContractStep();$/;"	p	namespace:simlib3	signature:()
ContractStep	simlib.h	/^void ContractStep(double time);$/;"	p	namespace:simlib3	signature:(double time)
Copyright	errors.h	/^\/* 0 *\/ Copyright,$/;"	e	enum:_ErrEnum
Cos	fun.cc	/^Input Cos(Input x)              { return new Function1(x, cos); }$/;"	f	namespace:simlib3	signature:(Input x)
Cos	simlib.h	/^Input Cos(Input x);             \/\/ cos(x)$/;"	p	namespace:simlib3	signature:(Input x)
Count	simlib.h	/^  unsigned Count() const { return count; }$/;"	f	class:simlib3::Histogram	access:public	signature:() const
Create	calendar.cc	/^    static EventNotice *Create(Entity *p, double t);$/;"	p	struct:simlib3::EventNotice	file:	access:public	signature:(Entity *p, double t)
Create	calendar.cc	/^inline EventNotice *EventNotice::Create(Entity *e, double t)$/;"	f	class:simlib3::EventNotice	signature:(Entity *e, double t)
CtrInit	graph.cc	/^void Graph::CtrInit(char *name) \/\/ common initialization$/;"	f	class:simlib3::Graph	signature:(char *name)
CtrInit	intg.cc	/^void Integrator::CtrInit() {$/;"	f	class:simlib3::Integrator	signature:()
CtrInit	intg.cc	/^void Status::CtrInit() {$/;"	f	class:simlib3::Status	signature:()
CtrInit	simlib.h	/^  void CtrInit();$/;"	p	class:simlib3::Integrator	access:protected	signature:()
CtrInit	simlib.h	/^  void CtrInit();$/;"	p	class:simlib3::Status	access:protected	signature:()
Current	run.cc	/^Entity *const &Current = SIMLIB_Current;        \/\/ read-only reference$/;"	m	namespace:simlib3	file:
CurrentMethodPtr	numint.cc	/^IntegrationMethod* IntegrationMethod::CurrentMethodPtr = &rke;$/;"	m	class:simlib3::IntegrationMethod	file:
CurrentMethodPtr	simlib.h	/^  static IntegrationMethod* CurrentMethodPtr;  \/\/ method used at present$/;"	m	class:simlib3::IntegrationMethod	access:private
DBG_ALL	internal.h	95;"	d
DBG_ATEXIT	internal.h	112;"	d
DBG_BEXPR	internal.h	107;"	d
DBG_CALENDAR	internal.h	105;"	d
DBG_CHG	internal.h	99;"	d
DBG_CONTI	internal.h	101;"	d
DBG_CTR	internal.h	97;"	d
DBG_FACSTO	internal.h	102;"	d
DBG_INIT	internal.h	98;"	d
DBG_MODULE	internal.h	111;"	d
DBG_NEW	internal.h	96;"	d
DBG_NUMINT	internal.h	109;"	d
DBG_PROCESS	internal.h	103;"	d
DBG_QUEUE	internal.h	104;"	d
DBG_SIMULATOR	internal.h	106;"	d
DBG_STEP	internal.h	100;"	d
DBG_THREAD	internal.h	110;"	d
DBG_WU	internal.h	108;"	d
DEBUG	internal.h	78;"	d
DEBUG	internal.h	89;"	d
DEBUG_INFO	internal.h	79;"	d
DEBUG_INFO	internal.h	82;"	d
DEFAULT_PRIORITY	simlib.h	/^  DEFAULT_PRIORITY = 0$/;"	e	enum:simlib3::__anon1
DEFINE_HOOK	internal.h	251;"	d
DEFINE_HOOK	run.cc	/^DEFINE_HOOK(Break);     \/\/ called in Run()$/;"	p	namespace:simlib3	file:	signature:(Break)
DEFINE_HOOK	run.cc	/^DEFINE_HOOK(Delay);     \/\/ called in Run() and SampleDelays()$/;"	p	namespace:simlib3	file:	signature:(Delay)
DEFINE_HOOK	run.cc	/^DEFINE_HOOK(DelayInit); \/\/ called in Init()$/;"	p	namespace:simlib3	file:	signature:(DelayInit)
DEFINE_HOOK	run.cc	/^DEFINE_HOOK(SamplerAct);        \/\/ called in Run()$/;"	p	namespace:simlib3	file:	signature:(SamplerAct)
DEFINE_HOOK	run.cc	/^DEFINE_HOOK(SamplerInit);       \/\/ called in Init()$/;"	p	namespace:simlib3	file:	signature:(SamplerInit)
DEFINE_HOOK	run.cc	/^DEFINE_HOOK(WUclear); \/\/ should be in run.cc$/;"	p	namespace:simlib3	file:	signature:(WUclear)
DEFINE_HOOK	run.cc	/^DEFINE_HOOK(WUget_next);$/;"	p	namespace:simlib3	file:	signature:(WUget_next)
DEFINE_HOOK	run.cc	/^DEFINE_HOOK(ZDelayTimerInit); \/\/ called in Run()$/;"	p	namespace:simlib3	file:	signature:(ZDelayTimerInit)
DeadZone	simlib.h	/^typedef Insv DeadZone;$/;"	t	namespace:simlib3
Debug	debug.cc	/^unsigned long Debug(unsigned long mode)$/;"	f	namespace:simlib3	signature:(unsigned long mode)
Debug	simlib.h	/^unsigned long Debug(unsigned long mode=~0UL); \/\/ start\/stop partial debugging$/;"	p	namespace:simlib3	signature:(unsigned long mode=~0UL)
DebugOFF	debug.cc	/^void DebugOFF()$/;"	f	namespace:simlib3	signature:()
DebugOFF	simlib.h	/^void DebugOFF();  \/\/!< stop debugging output$/;"	p	namespace:simlib3	signature:()
DebugON	debug.cc	/^void DebugON()$/;"	f	namespace:simlib3	signature:()
DebugON	simlib.h	/^void DebugON();   \/\/!< start debugging output$/;"	p	namespace:simlib3	signature:()
Default	zdelay.h	/^    static const bool Default = true;$/;"	m	class:simlib3::ZDelayTimer	access:public
Delay	delay.cc	/^Delay::Delay(Input i, double _dt, double ival) :$/;"	f	class:simlib3::Delay	signature:(Input i, double _dt, double ival)
Delay	delay.h	/^    Delay(Input i, double dt, double initvalue=0); \/\/ dt > MaxStep$/;"	p	class:simlib3::Delay	access:public	signature:(Input i, double dt, double initvalue=0)
Delay	delay.h	/^    Delay(const Delay&);                 \/\/ disable copy ctor$/;"	p	class:simlib3::Delay	access:private	signature:(const Delay&)
Delay	delay.h	/^class Delay : public aContiBlock1 {$/;"	c	namespace:simlib3	inherits:aContiBlock1
DelayTimeErr	errors.h	/^\/* 78 *\/ DelayTimeErr,$/;"	e	enum:_ErrEnum
DeletingActive	errors.h	/^\/* 18 *\/ DeletingActive,$/;"	e	enum:_ErrEnum
Destroy	calendar.cc	/^    static void Destroy(EventNotice *en);$/;"	p	struct:simlib3::EventNotice	file:	access:public	signature:(EventNotice *en)
Destroy	calendar.cc	/^inline void EventNotice::Destroy(EventNotice *en)$/;"	f	class:simlib3::EventNotice	signature:(EventNotice *en)
Destroy	delay.cc	/^    static void Destroy() {     \/\/!< should be called by ExitSimulation()? ###???$/;"	f	class:simlib3::SIMLIB_Delay	file:	access:private	signature:()
Destroy	zdelay.cc	/^    static void Destroy() {     \/\/ should be called by ExitSimulation()? ###???$/;"	f	class:simlib3::SIMLIB_ZDelayTimer	file:	access:private	signature:()
Down	simlib.h	/^  bool Down()   { return ccl>cc; }      \/\/ change: TRUE->FALSE$/;"	f	class:simlib3::Condition	access:protected	signature:()
Dprintf	internal.h	77;"	d
Dprintf	internal.h	84;"	d
DuplicateCalendar	errors.h	/^\/* 17 *\/ DuplicateCalendar,$/;"	e	enum:_ErrEnum
ERR	ni_fw.h	/^  Memory Y1, ERR;  \/\/ auxiliary memories$/;"	m	class:simlib3::FW	access:private
ERROREXIT	internal.h	/^    ERROREXIT       \/\/ fatal error handling phase$/;"	e	enum:simlib3::SIMLIB_Phase_t
EULER	ni_euler.h	/^  EULER(const char* name) :  \/\/ registrate method and name it$/;"	f	class:simlib3::EULER	access:public	signature:(const char* name)
EULER	ni_euler.h	/^class EULER : public StatusMethod {$/;"	c	namespace:simlib3	inherits:StatusMethod
Empty	calendar.cc	/^    bool     Empty() const { return _size == 0; }$/;"	f	class:simlib3::Calendar	access:public	signature:() const
Empty	calendar.cc	/^bool SQS::Empty() {                       \/\/ used by Run() only$/;"	f	class:simlib3::SQS	signature:()
Empty	internal.h	/^    bool Empty();                        \/\/ ?empty calendar$/;"	p	namespace:simlib3::SQS	signature:()
Empty	simlib.h	/^    bool Empty()  { return empty(); }$/;"	f	class:simlib3::Queue	access:public	signature:()
Empty	simlib.h	/^  bool Empty() const  { return Used() == 0; }           \/\/!< store is empty$/;"	f	class:simlib3::Store	access:public	signature:() const
EmptyCalendar	errors.h	/^\/* 20 *\/ EmptyCalendar,$/;"	e	enum:_ErrEnum
EmptyWUListError	errors.h	/^\/* 27 *\/ EmptyWUListError,$/;"	e	enum:_ErrEnum
End	simlib.h	/^  static iterator End(void) {$/;"	f	class:simlib3::IntegratorContainer	access:public	signature:(void)
End	simlib.h	/^  static iterator End(void) {$/;"	f	class:simlib3::StatusContainer	access:public	signature:(void)
EndTime	run.cc	/^const double & EndTime   = SIMLIB_EndTime;      \/\/ time of simulation end$/;"	m	namespace:simlib3	file:
EndTime	simlib.h	/^  double EndTime;$/;"	m	struct:simlib3::SIMLIB_statistics_t	access:public
Enter	barrier.cc	/^void Barrier::Enter(Entity * e) \/\/TODO without parameter: use Current?$/;"	f	class:simlib3::Barrier	signature:(Entity * e)
Enter	process.cc	/^void Process::Enter(Store & s, unsigned long cap)$/;"	f	class:simlib3::Process	signature:(Store & s, unsigned long cap)
Enter	simlib.h	/^  virtual void Enter(Entity *e);        \/\/!< wait for barrier break TODO: remove\/rename$/;"	p	class:simlib3::Barrier	access:public	signature:(Entity *e)
Enter	simlib.h	/^  virtual void Enter(Entity *e, unsigned long rcap);    \/\/!< allocate capacity$/;"	p	class:simlib3::Store	access:public	signature:(Entity *e, unsigned long rcap)
Enter	simlib.h	/^  void Enter(Store &s, unsigned long ReqCap=1); \/\/!< acquire some capacity$/;"	p	class:simlib3::Process	access:public	signature:(Store &s, unsigned long ReqCap=1)
Enter	store.cc	/^void Store::Enter(Entity *e, unsigned long rcap)$/;"	f	class:simlib3::Store	signature:(Entity *e, unsigned long rcap)
EnterCapError	errors.h	/^\/* 38 *\/ EnterCapError,$/;"	e	enum:_ErrEnum
Entity	entity.cc	/^Entity::Entity(Priority_t p) :$/;"	f	class:simlib3::Entity	signature:(Priority_t p)
Entity	simlib.h	/^    Entity(Priority_t p = DEFAULT_PRIORITY);$/;"	p	class:simlib3::Entity	access:public	signature:(Priority_t p = DEFAULT_PRIORITY)
Entity	simlib.h	/^    Entity(const Entity&);           \/\/ disable$/;"	p	class:simlib3::Entity	access:private	signature:(const Entity&)
Entity	simlib.h	/^class Entity : public Link {$/;"	c	namespace:simlib3	inherits:Link
EntityIsNotScheduled	errors.h	/^\/* 29 *\/ EntityIsNotScheduled,$/;"	e	enum:_ErrEnum
EntityPriority_t	simlib.h	/^typedef signed char EntityPriority_t;$/;"	t	namespace:simlib3
EntityRefError	errors.h	/^\/* 28 *\/ EntityRefError,$/;"	e	enum:_ErrEnum
Eps	simlib.h	/^  double Eps; \/\/ required accuracy$/;"	m	class:simlib3::AlgLoop	access:protected
Erase	intg.cc	/^void IntegratorContainer::Erase(IntegratorContainer::iterator it)$/;"	f	class:simlib3::IntegratorContainer	signature:(IntegratorContainer::iterator it)
Erase	intg.cc	/^void StatusContainer::Erase(StatusContainer::iterator it)$/;"	f	class:simlib3::StatusContainer	signature:(StatusContainer::iterator it)
Erase	simlib.h	/^  static void Erase(iterator it);  \/\/ exclude element$/;"	p	class:simlib3::IntegratorContainer	access:public	signature:(iterator it)
Erase	simlib.h	/^  static void Erase(iterator it);  \/\/ exclude element$/;"	p	class:simlib3::StatusContainer	access:public	signature:(iterator it)
Erlang	random2.cc	/^double Erlang(double alfa, int beta)$/;"	f	namespace:simlib3	signature:(double alfa, int beta)
Erlang	simlib.h	/^double Erlang(double alfa, int beta);$/;"	p	namespace:simlib3	signature:(double alfa, int beta)
ErlangError	errors.h	/^\/* 43 *\/ ErlangError,$/;"	e	enum:_ErrEnum
ErrBadArguments	generr.c	/^\/* 1 *\/ ErrBadArguments,$/;"	e	enum:ErrEnum	file:
ErrBadFile	generr.c	/^\/* 2 *\/ ErrBadFile,$/;"	e	enum:ErrEnum	file:
ErrBadHeader	generr.c	/^\/* 3 *\/ ErrBadHeader,$/;"	e	enum:ErrEnum	file:
ErrBadIdentifier	generr.c	/^\/* 4 *\/ ErrBadIdentifier,$/;"	e	enum:ErrEnum	file:
ErrCantOpenIn	generr.c	/^\/* 5 *\/ ErrCantOpenIn,$/;"	e	enum:ErrEnum	file:
ErrCantOpenOut	generr.c	/^\/* 6 *\/ ErrCantOpenOut,$/;"	e	enum:ErrEnum	file:
ErrDuplicateId	generr.c	/^\/* 7 *\/ ErrDuplicateId,$/;"	e	enum:ErrEnum	file:
ErrEnum	generr.c	/^enum ErrEnum {$/;"	g	file:
ErrId	generr.c	/^    char *ErrId;$/;"	m	struct:tabitem	file:	access:public
ErrIdTooLong	generr.c	/^\/* 8 *\/ ErrIdTooLong,$/;"	e	enum:ErrEnum	file:
ErrLineTooLong	generr.c	/^\/* 9 *\/ ErrLineTooLong,$/;"	e	enum:ErrEnum	file:
ErrMsg	generr.c	/^    char *ErrMsg;$/;"	m	struct:tabitem	file:	access:public
ErrMsg	generr.c	/^char *ErrMsg(enum ErrEnum N)$/;"	f	signature:(enum ErrEnum N)
ErrNoIdentifier	generr.c	/^\/* 10 *\/ ErrNoIdentifier,$/;"	e	enum:ErrEnum	file:
ErrNoMemory	generr.c	/^\/* 11 *\/ ErrNoMemory,$/;"	e	enum:ErrEnum	file:
ErrTooManyMsg	generr.c	/^\/* 12 *\/ ErrTooManyMsg,$/;"	e	enum:ErrEnum	file:
Error	print.cc	/^void Error(const char *fmt, ...)$/;"	f	namespace:simlib3	signature:(const char *fmt, ...)
Error	simlib.h	/^void Error(const char *fmt, ...);$/;"	p	namespace:simlib3	signature:(const char *fmt, ...)
Eval	continuous.cc	/^  virtual void Eval() {}$/;"	f	class:simlib3::_Add	file:	access:private	signature:()
Eval	continuous.cc	/^  virtual void Eval() {}$/;"	f	class:simlib3::_Div	file:	access:private	signature:()
Eval	continuous.cc	/^  virtual void Eval() {}$/;"	f	class:simlib3::_Mul	file:	access:private	signature:()
Eval	continuous.cc	/^  virtual void Eval() {}$/;"	f	class:simlib3::_Sub	file:	access:private	signature:()
Eval	continuous.cc	/^  virtual void Eval() {}$/;"	f	class:simlib3::_UMinus	file:	access:private	signature:()
Eval	intg.cc	/^void Integrator::Eval()$/;"	f	class:simlib3::Integrator	signature:()
Eval	intg.cc	/^void Status::Eval()$/;"	f	class:simlib3::Status	signature:()
Eval	simlib.h	/^    virtual void Eval() {};$/;"	f	class:simlib3::aContiBlock	access:private	signature:()
Eval	simlib.h	/^    virtual void Eval();           \/\/ block evaluation$/;"	p	class:simlib3::Hyst	access:protected	signature:()
Eval	simlib.h	/^  virtual void Eval();                 \/\/ block evaluation$/;"	p	class:simlib3::Status	access:public	signature:()
Eval	simlib.h	/^  virtual void Eval();           \/\/ block evaluation$/;"	p	class:simlib3::Blash	access:public	signature:()
Eval	simlib.h	/^  virtual void Eval();          \/\/!< block evaluation$/;"	p	class:simlib3::Relay	access:public	signature:()
Eval	simlib.h	/^  void Eval();                         \/\/ integrator input evaluation$/;"	p	class:simlib3::Integrator	access:public	signature:()
Eval	simlib2D.h	/^  virtual void Eval() {};            \/\/ evaluate without loop detection$/;"	f	class:simlib3::aContiBlock2D	access:private	signature:()
Eval	simlib3D.h	/^  virtual void Eval() {};            \/\/ evaluate without loop detection$/;"	f	class:simlib3::aContiBlock3D	access:private	signature:()
Eval	stdblock.cc	/^void Blash::Eval()$/;"	f	class:simlib3::Blash	signature:()
Eval	stdblock.cc	/^void Hyst::Eval()$/;"	f	class:simlib3::Hyst	signature:()
Eval	stdblock.cc	/^void Relay::Eval()$/;"	f	class:simlib3::Relay	signature:()
EvaluateAll	intg.cc	/^void IntegratorContainer::EvaluateAll()$/;"	f	class:simlib3::IntegratorContainer	signature:()
EvaluateAll	intg.cc	/^void StatusContainer::EvaluateAll()$/;"	f	class:simlib3::StatusContainer	signature:()
EvaluateAll	simlib.h	/^  static void EvaluateAll();       \/\/ evaluate all integrators$/;"	p	class:simlib3::IntegratorContainer	access:public	signature:()
EvaluateAll	simlib.h	/^  static void EvaluateAll();       \/\/ evaluate all integrators$/;"	p	class:simlib3::StatusContainer	access:public	signature:()
Event	event.cc	/^Event::Event(Priority_t p) : Entity(p)$/;"	f	class:simlib3::Event	signature:(Priority_t p)
Event	simlib.h	/^  Event(Priority_t p=DEFAULT_PRIORITY);$/;"	p	class:simlib3::Event	access:public	signature:(Priority_t p=DEFAULT_PRIORITY)
Event	simlib.h	/^class Event : public Entity {$/;"	c	namespace:simlib3	inherits:Entity
EventCount	simlib.h	/^  long   EventCount;    \/\/ for discrete simulation$/;"	m	struct:simlib3::SIMLIB_statistics_t	access:public
EventNotice	calendar.cc	/^    EventNotice(Entity *p, double t) :$/;"	f	struct:simlib3::EventNotice	access:public	signature:(Entity *p, double t)
EventNotice	calendar.cc	/^    EventNotice(const EventNotice&); \/\/ disable$/;"	p	struct:simlib3::EventNotice	file:	access:private	signature:(const EventNotice&)
EventNotice	calendar.cc	/^struct EventNotice : public EventNoticeLinkBase {$/;"	s	namespace:simlib3	file:	inherits:EventNoticeLinkBase
EventNoticeAllocator	calendar.cc	/^    EventNoticeAllocator(): l(0), freed(0) {}$/;"	f	class:simlib3::EventNoticeAllocator	access:public	signature:()
EventNoticeAllocator	calendar.cc	/^class EventNoticeAllocator {$/;"	c	namespace:simlib3	file:
EventNoticeLinkBase	calendar.cc	/^    EventNoticeLinkBase() : pred(this), succ(this) {}$/;"	f	struct:simlib3::EventNoticeLinkBase	access:public	signature:()
EventNoticeLinkBase	calendar.cc	/^struct EventNoticeLinkBase { \/\/ base class with list pointers only$/;"	s	namespace:simlib3	file:
Exp	fun.cc	/^Input Exp(Input x)              { return new Function1(x, exp); }$/;"	f	namespace:simlib3	signature:(Input x)
Exp	simlib.h	/^Input Exp(Input x);             \/\/ exp(x)     e ** x$/;"	p	namespace:simlib3	signature:(Input x)
Exponential	random2.cc	/^double Exponential(double mv)$/;"	f	namespace:simlib3	signature:(double mv)
Exponential	simlib.h	/^double Exponential(double mv);$/;"	p	namespace:simlib3	signature:(double mv)
Expression	simlib.h	/^  Expression(Input i) : aContiBlock1(i) {}$/;"	f	struct:simlib3::Expression	access:public	signature:(Input i)
Expression	simlib.h	/^struct Expression : public aContiBlock1 {$/;"	s	namespace:simlib3	inherits:aContiBlock1
Expression2D	simlib2D.h	/^  explicit Expression2D(Input2D i) : aContiBlock2D1(i) {}$/;"	f	struct:simlib3::Expression2D	access:public	signature:(Input2D i)
Expression2D	simlib2D.h	/^struct Expression2D : public aContiBlock2D1 {$/;"	s	namespace:simlib3	inherits:aContiBlock2D1
Expression3D	simlib3D.h	/^  explicit Expression3D(Input3D i) : aContiBlock3D1(i) {}$/;"	f	struct:simlib3::Expression3D	access:public	signature:(Input3D i)
Expression3D	simlib3D.h	/^struct Expression3D : public aContiBlock3D1 {$/;"	s	namespace:simlib3	inherits:aContiBlock3D1
FALSE	generr.c	/^enum Boolean { FALSE, TRUE };$/;"	e	enum:Boolean	file:
FREE_CONTEXT	process.cc	174;"	d	file:
FW	ni_fw.h	/^  FW(const char* name) :  \/\/ registrate method and name it$/;"	f	class:simlib3::FW	access:public	signature:(const char* name)
FW	ni_fw.h	/^class FW : public SingleStepMethod {$/;"	c	namespace:simlib3	inherits:SingleStepMethod
FW_First	ni_fw.h	/^  bool FW_First;  \/\/ is method called for first time?$/;"	m	class:simlib3::FW	access:private
FacInterruptError	errors.h	/^\/* 35 *\/ FacInterruptError,$/;"	e	enum:_ErrEnum
Facility	facility.cc	/^Facility::Facility()$/;"	f	class:simlib3::Facility	signature:()
Facility	facility.cc	/^Facility::Facility(Queue * queue)$/;"	f	class:simlib3::Facility	signature:(Queue * queue)
Facility	facility.cc	/^Facility::Facility(const char *name)$/;"	f	class:simlib3::Facility	signature:(const char *name)
Facility	facility.cc	/^Facility::Facility(const char *name, Queue * queue)$/;"	f	class:simlib3::Facility	signature:(const char *name, Queue * queue)
Facility	simlib.h	/^    Facility(const Facility&);                  \/\/ disable$/;"	p	class:simlib3::Facility	access:private	signature:(const Facility&)
Facility	simlib.h	/^  Facility();$/;"	p	class:simlib3::Facility	access:public	signature:()
Facility	simlib.h	/^  Facility(Queue *_queue1);$/;"	p	class:simlib3::Facility	access:public	signature:(Queue *_queue1)
Facility	simlib.h	/^  Facility(const char *_name);$/;"	p	class:simlib3::Facility	access:public	signature:(const char *_name)
Facility	simlib.h	/^  Facility(const char *_name, Queue *_queue1);$/;"	p	class:simlib3::Facility	access:public	signature:(const char *_name, Queue *_queue1)
Facility	simlib.h	/^class Facility : public SimObject {$/;"	c	namespace:simlib3	inherits:SimObject
First	cond.cc	/^aCondition *aCondition::First = 0;       \/\/ condition list$/;"	m	class:simlib3::aCondition	file:
First	graph.cc	/^Graph *Graph::First = 0;$/;"	m	class:simlib3::Graph	file:
First	sampler.cc	/^Sampler *Sampler::First = 0;$/;"	m	class:simlib3::Sampler	file:
First	simlib.h	/^    static Sampler *First;              \/\/ list of objects TODO: use container$/;"	m	class:simlib3::Sampler	access:private
First	simlib.h	/^  static aCondition *First;            \/\/ list of all conditions$/;"	m	class:simlib3::aCondition	access:private
FirstIntegrator	simlib.h	/^  static Iterator FirstIntegrator(void) {  \/\/ it. to first integrator in list$/;"	f	class:simlib3::IntegrationMethod	access:protected	signature:(void)
FirstStatus	simlib.h	/^  static StatusIterator FirstStatus(void) {  \/\/ it. to first status in list$/;"	f	class:simlib3::StatusMethod	access:protected	signature:(void)
Free	simlib.h	/^  unsigned long Free() const { return capacity - used; }\/\/!< free capacity$/;"	f	class:simlib3::Store	access:public	signature:() const
Frict	simlib.h	/^  Frict(Input in, double l, double h, double tga=1.0);$/;"	p	class:simlib3::Frict	access:public	signature:(Input in, double l, double h, double tga=1.0)
Frict	simlib.h	/^class Frict : public aContiBlock1 {$/;"	c	namespace:simlib3	inherits:aContiBlock1
Frict	stdblock.cc	/^Frict::Frict(Input in, double l, double h, double tga)$/;"	f	class:simlib3::Frict	signature:(Input in, double l, double h, double tga)
Friction	simlib.h	/^typedef Frict Friction;$/;"	t	namespace:simlib3
Full	simlib.h	/^  bool Full() const   { return Free() == 0; }           \/\/!< store is full$/;"	f	class:simlib3::Store	access:public	signature:() const
FunCall	numint.cc	/^void IntegrationMethod::FunCall(double step_frag)$/;"	f	class:simlib3::IntegrationMethod	signature:(double step_frag)
FunCall	simlib.h	/^  static void FunCall(double step_frag); \/\/ evaluate y'(t) = f(t, y(t))$/;"	p	class:simlib3::IntegrationMethod	access:public	signature:(double step_frag)
Function1	fun.cc	/^Function1::Function1(Input i, double (*pf)(double))$/;"	f	class:simlib3::Function1	signature:(Input i, double (*pf)(double))
Function1	simlib.h	/^    Function1(const Function1&); \/\/ ## disable$/;"	p	class:simlib3::Function1	access:private	signature:(const Function1&)
Function1	simlib.h	/^  Function1(Input i, double (*pf)(double));$/;"	p	class:simlib3::Function1	access:public	signature:(Input i, double (*pf)(double))
Function1	simlib.h	/^class Function1 : public aContiBlock1 {$/;"	c	namespace:simlib3	inherits:aContiBlock1
Function2	fun.cc	/^Function2::Function2(Input i1, Input i2, double (*pf)(double,double))$/;"	f	class:simlib3::Function2	signature:(Input i1, Input i2, double (*pf)(double,double))
Function2	simlib.h	/^    Function2(const Function2&); \/\/ ## disable$/;"	p	class:simlib3::Function2	access:private	signature:(const Function2&)
Function2	simlib.h	/^  Function2(Input i1, Input i2, double (*pf)(double,double));$/;"	p	class:simlib3::Function2	access:public	signature:(Input i1, Input i2, double (*pf)(double,double))
Function2	simlib.h	/^class Function2 : public aContiBlock2 {$/;"	c	namespace:simlib3	inherits:aContiBlock2
Gamma	random2.cc	/^double Gamma(double alfa, double beta)$/;"	f	namespace:simlib3	signature:(double alfa, double beta)
Gamma	simlib.h	/^double Gamma(double alfa, double beta);$/;"	p	namespace:simlib3	signature:(double alfa, double beta)
GenEnum	generr.c	/^void GenEnum(FILE * outf, TABLE * t)$/;"	f	signature:(FILE * outf, TABLE * t)
GenErrFun	generr.c	/^void GenErrFun(FILE * outf)$/;"	f	signature:(FILE * outf)
GenMessages	generr.c	/^void GenMessages(FILE * outf, TABLE * t)$/;"	f	signature:(FILE * outf, TABLE * t)
GenerHeader	generr.c	/^void GenerHeader(TABLE * t)$/;"	f	signature:(TABLE * t)
GenerModule	generr.c	/^void GenerModule(TABLE * t)$/;"	f	signature:(TABLE * t)
Geom	random2.cc	/^int Geom(double q)$/;"	f	namespace:simlib3	signature:(double q)
Geom	simlib.h	/^int    Geom(double q);$/;"	p	namespace:simlib3	signature:(double q)
GeomError	errors.h	/^\/* 48 *\/ GeomError,$/;"	e	enum:_ErrEnum
Get	calendar.cc	/^    virtual Entity * Get(Entity *e) = 0;$/;"	p	class:simlib3::Calendar	file:	access:public	signature:(Entity *e)
Get	calendar.cc	/^    virtual Entity *Get(Entity *p);              \/\/ remove process p from calendar$/;"	p	class:simlib3::CalendarList	file:	access:public	signature:(Entity *p)
Get	calendar.cc	/^    virtual Entity *Get(Entity *p);              \/\/ remove process p from calendar$/;"	p	class:simlib3::CalendarQueue	file:	access:public	signature:(Entity *p)
Get	calendar.cc	/^Entity * CalendarList::Get(Entity * e)$/;"	f	class:simlib3::CalendarList	signature:(Entity * e)
Get	calendar.cc	/^Entity * CalendarQueue::Get(Entity * e)$/;"	f	class:simlib3::CalendarQueue	signature:(Entity * e)
Get	calendar.cc	/^void SQS::Get(Entity *e) {             \/\/ used by Run() only$/;"	f	class:simlib3::SQS	signature:(Entity *e)
Get	internal.h	/^    void Get(Entity *e);                 \/\/ remove entity e$/;"	p	namespace:simlib3::SQS	signature:(Entity *e)
Get	list.cc	/^Link *List::Get(iterator pos)$/;"	f	class:simlib3::List	signature:(iterator pos)
Get	queue.cc	/^Entity *Queue::Get(iterator pos)$/;"	f	class:simlib3::Queue	signature:(iterator pos)
Get	simlib.h	/^    virtual Entity *Get(iterator pos);           \/\/ remove entity$/;"	p	class:simlib3::Queue	access:public	signature:(iterator pos)
Get	simlib.h	/^    virtual Link *Get(iterator pos);     \/\/!< remove at position$/;"	p	class:simlib3::List	access:public	signature:(iterator pos)
GetChar	generr.c	/^int GetChar(void)$/;"	f	signature:(void)
GetCurrent	waitunti.cc	/^    static void GetCurrent();        \/\/ get current process$/;"	p	class:simlib3::WaitUntilList	file:	access:public	signature:()
GetCurrent	waitunti.cc	/^void WaitUntilList::GetCurrent()$/;"	f	class:simlib3::WaitUntilList	signature:()
GetDiff	simlib.h	/^  double GetDiff(void) { return dd; }$/;"	f	class:simlib3::Integrator	access:public	signature:(void)
GetErrId	generr.c	/^char *GetErrId(void)$/;"	f	signature:(void)
GetErrMsg	generr.c	/^char *GetErrMsg(void)$/;"	f	signature:(void)
GetErrNo	simlib.h	/^  static int GetErrNo(void) { \/\/ return # of errors$/;"	f	class:simlib3::IntegrationMethod	access:public	signature:(void)
GetEventNotice	simlib.h	/^    EventNotice *GetEventNotice() { return _evn; }$/;"	f	class:simlib3::Entity	access:public	signature:()
GetFirst	calendar.cc	/^    virtual Entity * GetFirst() = 0;$/;"	p	class:simlib3::Calendar	file:	access:public	signature:()
GetFirst	calendar.cc	/^    virtual Entity *GetFirst();$/;"	p	class:simlib3::CalendarList	file:	access:public	signature:()
GetFirst	calendar.cc	/^    virtual Entity *GetFirst();$/;"	p	class:simlib3::CalendarQueue	file:	access:public	signature:()
GetFirst	calendar.cc	/^Entity * CalendarQueue::GetFirst()$/;"	f	class:simlib3::CalendarQueue	signature:()
GetFirst	calendar.cc	/^Entity *CalendarList::GetFirst()$/;"	f	class:simlib3::CalendarList	signature:()
GetFirst	calendar.cc	/^Entity *SQS::GetFirst() {                  \/\/ used by Run()$/;"	f	class:simlib3::SQS	signature:()
GetFirst	internal.h	/^    Entity *GetFirst();                  \/\/ remove first item$/;"	p	namespace:simlib3::SQS	signature:()
GetFirst	list.cc	/^Link *List::GetFirst()$/;"	f	class:simlib3::List	signature:()
GetFirst	queue.cc	/^Entity *Queue::GetFirst()$/;"	f	class:simlib3::Queue	signature:()
GetFirst	simlib.h	/^    Entity *GetFirst();$/;"	p	class:simlib3::Queue	access:public	signature:()
GetFirst	simlib.h	/^    Link *GetFirst();                    \/\/!< remove first$/;"	p	class:simlib3::List	access:public	signature:()
GetHeader	generr.c	/^void GetHeader(FILE * inf, char *funcname, char *enumname)$/;"	f	signature:(FILE * inf, char *funcname, char *enumname)
GetIdent	generr.c	/^void GetIdent(char *sptr)$/;"	f	signature:(char *sptr)
GetLast	list.cc	/^Link *List::GetLast()$/;"	f	class:simlib3::List	signature:()
GetLast	queue.cc	/^Entity *Queue::GetLast()$/;"	f	class:simlib3::Queue	signature:()
GetLast	simlib.h	/^    Entity *GetLast();$/;"	p	class:simlib3::Queue	access:public	signature:()
GetLast	simlib.h	/^    Link *GetLast();                     \/\/!< remove last$/;"	p	class:simlib3::List	access:public	signature:()
GetLine	generr.c	/^int GetLine(FILE * inf)$/;"	f	signature:(FILE * inf)
GetMethod	simlib.h	/^  static const char* GetMethod(void) {  \/\/ get name of method which is used$/;"	f	class:simlib3::IntegrationMethod	access:public	signature:(void)
GetMethod	simlib.h	/^inline const char* GetMethod(void)$/;"	f	namespace:simlib3	signature:(void)
GetName	name.cc	/^const char *GetName(SimObject & o)$/;"	f	namespace:simlib3	signature:(SimObject & o)
GetName	name.cc	/^const char *GetName(SimObject * o)$/;"	f	namespace:simlib3	signature:(SimObject * o)
GetName	simlib.h	/^const char *GetName(SimObject &o);$/;"	p	namespace:simlib3	signature:(SimObject &o)
GetName	simlib.h	/^const char *GetName(SimObject *o);$/;"	p	namespace:simlib3	signature:(SimObject *o)
GetOldDiff	simlib.h	/^  double GetOldDiff(void) { return ddl; }$/;"	f	class:simlib3::Integrator	access:public	signature:(void)
GetOldState	simlib.h	/^  double GetOldState(void) { return ssl; }$/;"	f	class:simlib3::Integrator	access:public	signature:(void)
GetOldState	simlib.h	/^  double GetOldState(void) { return stl; }$/;"	f	class:simlib3::Status	access:public	signature:(void)
GetStarter	numint.cc	/^const char* MultiStepMethod::GetStarter(const char* name)$/;"	f	class:simlib3::MultiStepMethod	signature:(const char* name)
GetStarter	simlib.h	/^  static const char* GetStarter(const char* name);$/;"	p	class:simlib3::MultiStepMethod	access:public	signature:(const char* name)
GetStarter	simlib.h	/^inline const char* GetStarter(const char* name)$/;"	f	namespace:simlib3	signature:(const char* name)
GetStarter	simlib.h	/^inline const char* GetStarter(void)$/;"	f	namespace:simlib3	signature:(void)
GetState	simlib.h	/^  double GetState(void) { return ss; }$/;"	f	class:simlib3::Integrator	access:public	signature:(void)
GetState	simlib.h	/^  double GetState(void) { return st; }$/;"	f	class:simlib3::Status	access:public	signature:(void)
GetStep	simlib.h	/^    double GetStep() const { return step; } \/\/!< get current step$/;"	f	class:simlib3::Sampler	access:public	signature:() const
GetTable	generr.c	/^void GetTable(FILE * inf, TABLE * t)$/;"	f	signature:(FILE * inf, TABLE * t)
GoToState	numint.cc	/^void StatusMethod::GoToState(Memory& di, Memory& si, StatusMemory& xi)$/;"	f	class:simlib3::StatusMethod	signature:(Memory& di, Memory& si, StatusMemory& xi)
GoToState	simlib.h	/^  static void GoToState(Memory& di, Memory& si, StatusMemory& xi);$/;"	p	class:simlib3::StatusMethod	access:protected	signature:(Memory& di, Memory& si, StatusMemory& xi)
Graph	graph.cc	/^Graph::Graph(char *_name, Input i, double dTime) : in(i), TimeStep(dTime)$/;"	f	class:simlib3::Graph	signature:(char *_name, Input i, double dTime)
HIGHEST_PRIORITY	simlib.h	/^  HIGHEST_PRIORITY = 127,$/;"	e	enum:simlib3::__anon1
HOOK_INST_NAME	internal.h	231;"	d
HOOK_PTR_NAME	internal.h	230;"	d
HasName	simlib.h	/^  bool HasName() const { return _name !=0; }$/;"	f	class:simlib3::SimObject	access:public	signature:() const
Height	simlib.h	/^  unsigned Height() const { return maxn; }      \/\/!< barrier size$/;"	f	class:simlib3::Barrier	access:public	signature:() const
High	simlib.h	/^  double High() const    { return low + step*count; }$/;"	f	class:simlib3::Histogram	access:public	signature:() const
HistoCountError	errors.h	/^\/* 23 *\/ HistoCountError,$/;"	e	enum:_ErrEnum
HistoStepError	errors.h	/^\/* 22 *\/ HistoStepError,$/;"	e	enum:_ErrEnum
Histogram	histo.cc	/^Histogram::Histogram() :$/;"	f	class:simlib3::Histogram	signature:()
Histogram	histo.cc	/^Histogram::Histogram(const char *n, double l, double s, unsigned c) :$/;"	f	class:simlib3::Histogram	signature:(const char *n, double l, double s, unsigned c)
Histogram	histo.cc	/^Histogram::Histogram(double l, double s, unsigned c) :$/;"	f	class:simlib3::Histogram	signature:(double l, double s, unsigned c)
Histogram	simlib.h	/^    Histogram(const Histogram&);           \/\/ disable$/;"	p	class:simlib3::Histogram	access:private	signature:(const Histogram&)
Histogram	simlib.h	/^  Histogram();$/;"	p	class:simlib3::Histogram	access:public	signature:()
Histogram	simlib.h	/^  Histogram(const char *_name, double low, double step, unsigned count=10);$/;"	p	class:simlib3::Histogram	access:public	signature:(const char *_name, double low, double step, unsigned count=10)
Histogram	simlib.h	/^  Histogram(double low, double step, unsigned count=10);$/;"	p	class:simlib3::Histogram	access:public	signature:(double low, double step, unsigned count=10)
Histogram	simlib.h	/^class Histogram : public SimObject {$/;"	c	namespace:simlib3	inherits:SimObject
HyperGeom	random2.cc	/^int HyperGeom(double p, int n, int m)$/;"	f	namespace:simlib3	signature:(double p, int n, int m)
HyperGeom	simlib.h	/^int    HyperGeom(double p, int n, int m);$/;"	p	namespace:simlib3	signature:(double p, int n, int m)
HyperGeomError1	errors.h	/^\/* 49 *\/ HyperGeomError1,$/;"	e	enum:_ErrEnum
HyperGeomError2	errors.h	/^\/* 50 *\/ HyperGeomError2,$/;"	e	enum:_ErrEnum
Hyst	simlib.h	/^    Hyst(Input i, double p1, double p2, double y1, double y2, double tga);$/;"	p	class:simlib3::Hyst	access:public	signature:(Input i, double p1, double p2, double y1, double y2, double tga)
Hyst	simlib.h	/^class Hyst : public Status {$/;"	c	namespace:simlib3	inherits:Status
Hyst	stdblock.cc	/^Hyst::Hyst(Input i, double _p1, double _p2, double _y1, double _y2, double _tga)$/;"	f	class:simlib3::Hyst	signature:(Input i, double _p1, double _p2, double _y1, double _y2, double _tga)
Hysteresis	simlib.h	/^typedef Hyst Hysteresis; \/\/ alias name$/;"	t	namespace:simlib3
INICONST	random1.cc	/^const myint32 INICONST   = 1537L;$/;"	m	namespace:simlib3	file:
INITIALIZATION	internal.h	/^    INITIALIZATION, \/\/ after Init() call$/;"	e	enum:simlib3::SIMLIB_Phase_t
INSTALL_HOOK	internal.h	239;"	d
Idle	simlib.h	/^    bool Idle() { return _evn==0; }     \/\/!< entity activation is not scheduled in calendar$/;"	f	class:simlib3::Entity	access:public	signature:()
InconsistentHeader	errors.h	/^\/* 58 *\/ InconsistentHeader,$/;"	e	enum:_ErrEnum
Init	atexit.cc	/^int SIMLIB_module::Init(const char *s) {$/;"	f	class:simlib3::SIMLIB_module	signature:(const char *s)
Init	barrier.cc	/^void Barrier::Init() {$/;"	f	class:simlib3::Barrier	signature:()
Init	cond.cc	/^void Condition::Init()$/;"	f	class:simlib3::Condition	signature:()
Init	delay.cc	/^void Delay::Init() {$/;"	f	class:simlib3::Delay	signature:()
Init	delay.h	/^    void Init();                \/\/!< initialize delay block$/;"	p	class:simlib3::Delay	access:public	signature:()
Init	histo.cc	/^void Histogram::Init(double l, double s, unsigned c)$/;"	f	class:simlib3::Histogram	signature:(double l, double s, unsigned c)
Init	internal.h	/^  int Init(const char *s);$/;"	p	class:simlib3::SIMLIB_module	access:public	signature:(const char *s)
Init	intg.cc	/^void Integrator::Init(double initvalue) {$/;"	f	class:simlib3::Integrator	signature:(double initvalue)
Init	intg.cc	/^void Status::Init(double initvalue)$/;"	f	class:simlib3::Status	signature:(double initvalue)
Init	run.cc	/^void SIMLIB_statistics_t::Init() {$/;"	f	class:simlib3::SIMLIB_statistics_t	signature:()
Init	simlib.h	/^  virtual void Init();$/;"	p	class:simlib3::Condition	access:private	signature:()
Init	simlib.h	/^  virtual void Init()=0;               \/\/!< initialize$/;"	p	class:simlib3::aCondition	access:private	signature:()
Init	simlib.h	/^  void Init() { Init(initval); }       \/\/!< use preset initial value$/;"	f	class:simlib3::Integrator	access:public	signature:()
Init	simlib.h	/^  void Init() { Init(initval); }$/;"	f	class:simlib3::Status	access:public	signature:()
Init	simlib.h	/^  void Init();          \/\/!< initialization$/;"	p	class:simlib3::Barrier	access:protected	signature:()
Init	simlib.h	/^  void Init();$/;"	p	struct:simlib3::SIMLIB_statistics_t	access:public	signature:()
Init	simlib.h	/^  void Init(double initvalue);         \/\/ set value$/;"	p	class:simlib3::Integrator	access:public	signature:(double initvalue)
Init	simlib.h	/^  void Init(double initvalue);         \/\/ value initialization$/;"	p	class:simlib3::Status	access:public	signature:(double initvalue)
Init	simlib.h	/^  void Init(double low, double step, unsigned count);$/;"	p	class:simlib3::Histogram	access:public	signature:(double low, double step, unsigned count)
Init	simlib.h	/^inline void Init(double t0, double t1=SIMLIB_MAXTIME) {$/;"	f	namespace:simlib3	signature:(double t0, double t1=SIMLIB_MAXTIME)
Init	simlib3D.h	/^  void Init(const Value3D &v) {_x.Init(v.x()); _y.Init(v.y()); _z.Init(v.z());}$/;"	f	class:simlib3::Integrator3D	access:public	signature:(const Value3D &v)
Init	zdelay.cc	/^void ZDelay::Init() {$/;"	f	class:simlib3::ZDelay	signature:()
Init	zdelay.cc	/^void ZDelay::Init(double iv) { \/\/ set initial value of ZDelay block$/;"	f	class:simlib3::ZDelay	signature:(double iv)
Init	zdelay.cc	/^void ZDelayTimer::Init()  \/\/ called each Run()$/;"	f	class:simlib3::ZDelayTimer	signature:()
Init	zdelay.h	/^    virtual void Init();        \/\/ initialize ZDelay block$/;"	p	class:simlib3::ZDelay	access:public	signature:()
Init	zdelay.h	/^    void Init();  \/\/ called each Run()$/;"	p	class:simlib3::ZDelayTimer	access:public	signature:()
Init	zdelay.h	/^    void Init(double iv);       \/\/ set initial value of ZDelay block$/;"	p	class:simlib3::ZDelay	access:public	signature:(double iv)
InitAll	cond.cc	/^void aCondition::InitAll() {$/;"	f	class:simlib3::aCondition	signature:()
InitAll	delay.cc	/^    static void InitAll() {     \/\/ called at Init()$/;"	f	class:simlib3::SIMLIB_Delay	file:	access:private	signature:()
InitAll	intg.cc	/^void IntegratorContainer::InitAll()$/;"	f	class:simlib3::IntegratorContainer	signature:()
InitAll	intg.cc	/^void StatusContainer::InitAll()$/;"	f	class:simlib3::StatusContainer	signature:()
InitAll	sampler.cc	/^void Sampler::InitAll() {$/;"	f	class:simlib3::Sampler	signature:()
InitAll	simlib.h	/^    static void InitAll();          \/\/!< initialize all samplers (Init)$/;"	p	class:simlib3::Sampler	access:private	signature:()
InitAll	simlib.h	/^  static void InitAll();           \/\/ initialize all$/;"	p	class:simlib3::IntegratorContainer	access:public	signature:()
InitAll	simlib.h	/^  static void InitAll();           \/\/ initialize all$/;"	p	class:simlib3::StatusContainer	access:public	signature:()
InitAll	simlib.h	/^  static void InitAll();$/;"	p	class:simlib3::aCondition	access:public	signature:()
InitAll	zdelay.cc	/^    static void InitAll() {     \/\/ called at Init()$/;"	f	class:simlib3::SIMLIB_ZDelayTimer	file:	access:private	signature:()
InitError	errors.h	/^\/* 4 *\/ InitError,$/;"	e	enum:_ErrEnum
InitInRunError	errors.h	/^\/* 6 *\/ InitInRunError,$/;"	e	enum:_ErrEnum
InitMinStepError	errors.h	/^\/* 9 *\/ InitMinStepError,$/;"	e	enum:_ErrEnum
InitStep	numint.cc	/^void IntegrationMethod::InitStep(double step_frag)$/;"	f	class:simlib3::IntegrationMethod	signature:(double step_frag)
InitStep	simlib.h	/^  static void InitStep(double step_frag); \/\/ initialize step$/;"	p	class:simlib3::IntegrationMethod	access:public	signature:(double step_frag)
InitTable	generr.c	/^void InitTable(TABLE ** t)$/;"	f	signature:(TABLE ** t)
Initialize	delay.cc	/^    static void Initialize() {          \/\/!< initialize delay subsystem$/;"	f	class:simlib3::SIMLIB_Delay	file:	access:private	signature:()
Initialize	graph.cc	/^void Graph::Initialize()$/;"	f	class:simlib3::Graph	signature:()
Initialize	zdelay.cc	/^    static void Initialize() {          \/\/ initialize delay subsystem$/;"	f	class:simlib3::SIMLIB_ZDelayTimer	file:	access:private	signature:()
Input	simlib.h	/^  Input(); \/\/ disable default constructor$/;"	p	class:simlib3::Input	access:private	signature:()
Input	simlib.h	/^  Input(aContiBlock &cb): bp(&cb) { RegisterReference(bp); } \/\/!< reference to block$/;"	f	class:simlib3::Input	access:public	signature:(aContiBlock &cb)
Input	simlib.h	/^  Input(aContiBlock *cb): bp(cb)  { RegisterReference(bp); } \/\/!< pointer to block$/;"	f	class:simlib3::Input	access:public	signature:(aContiBlock *cb)
Input	simlib.h	/^  Input(const Input &i): bp(i.bp) { RegisterReference(bp); }$/;"	f	class:simlib3::Input	access:public	signature:(const Input &i)
Input	simlib.h	/^  Input(const double c):  bp(new Constant(c)) { RegisterReference(bp); }$/;"	f	class:simlib3::Input	access:public	signature:(const double c)
Input	simlib.h	/^class Input {$/;"	c	namespace:simlib3
Input1Value	simlib.h	/^  double Input1Value() { return input1.Value(); }$/;"	f	class:simlib3::aContiBlock2	access:public	signature:()
Input1Value	simlib.h	/^  double Input1Value() { return input1.Value(); }$/;"	f	class:simlib3::aContiBlock3	access:public	signature:()
Input1Value	simlib2D.h	/^  Value2D Input1Value() { return input1.Value(); }$/;"	f	class:simlib3::aContiBlock2D2	access:public	signature:()
Input1Value	simlib3D.h	/^  Value3D Input1Value() { return input1.Value(); }$/;"	f	class:simlib3::aContiBlock3D2	access:public	signature:()
Input2D	simlib2D.h	/^  Input2D(aContiBlock2D &cb): bp(&cb) {}         \/\/ reference to 2D block$/;"	f	class:simlib3::Input2D	access:public	signature:(aContiBlock2D &cb)
Input2D	simlib2D.h	/^  Input2D(aContiBlock2D *cb): bp(cb)  {}         \/\/ pointer to 2D block$/;"	f	class:simlib3::Input2D	access:public	signature:(aContiBlock2D *cb)
Input2D	simlib2D.h	/^  Input2D(const Input2D &in): bp(in.bp) {}       \/\/ copy reference$/;"	f	class:simlib3::Input2D	access:public	signature:(const Input2D &in)
Input2D	simlib2D.h	/^class Input2D {                   \/\/ small objects, without virtual methods$/;"	c	namespace:simlib3
Input2Value	simlib.h	/^  double Input2Value() { return input2.Value(); }$/;"	f	class:simlib3::aContiBlock2	access:public	signature:()
Input2Value	simlib.h	/^  double Input2Value() { return input2.Value(); }$/;"	f	class:simlib3::aContiBlock3	access:public	signature:()
Input2Value	simlib2D.h	/^  Value2D Input2Value() { return input2.Value(); }$/;"	f	class:simlib3::aContiBlock2D2	access:public	signature:()
Input2Value	simlib3D.h	/^  Value3D Input2Value() { return input2.Value(); }$/;"	f	class:simlib3::aContiBlock3D2	access:public	signature:()
Input3D	simlib3D.h	/^  Input3D(aContiBlock3D &cb): bp(&cb) {}          \/\/ reference to 3D block$/;"	f	class:simlib3::Input3D	access:public	signature:(aContiBlock3D &cb)
Input3D	simlib3D.h	/^  Input3D(aContiBlock3D *cb): bp(cb)  {}          \/\/ pointer to 3D block$/;"	f	class:simlib3::Input3D	access:public	signature:(aContiBlock3D *cb)
Input3D	simlib3D.h	/^  Input3D(const Input3D &inp): bp(inp.bp) {}      \/\/ copy reference$/;"	f	class:simlib3::Input3D	access:public	signature:(const Input3D &inp)
Input3D	simlib3D.h	/^class Input3D {                   \/\/ small objects, without virtual methods$/;"	c	namespace:simlib3
Input3Value	simlib.h	/^  double Input3Value() { return input3.Value(); }$/;"	f	class:simlib3::aContiBlock3	access:public	signature:()
Input3Value	simlib2D.h	/^  Value2D Input3Value() { return input3.Value(); }$/;"	f	class:simlib3::aContiBlock2D3	access:public	signature:()
Input3Value	simlib3D.h	/^  Value3D Input3Value() { return input3.Value(); }$/;"	f	class:simlib3::aContiBlock3D3	access:public	signature:()
InputValue	simlib.h	/^  double InputValue() { return input.Value(); } \/\/!< current input value$/;"	f	class:simlib3::Integrator	access:public	signature:()
InputValue	simlib.h	/^  double InputValue() { return input.Value(); }$/;"	f	class:simlib3::aContiBlock1	access:public	signature:()
InputValue	simlib2D.h	/^  Value2D InputValue() { return input.Value(); }$/;"	f	class:simlib3::aContiBlock2D1	access:public	signature:()
InputValue	simlib3D.h	/^  Value3D InputValue() { return input.Value(); }$/;"	f	class:simlib3::aContiBlock3D1	access:public	signature:()
InsFirst	list.cc	/^void List::InsFirst(Link *ent)$/;"	f	class:simlib3::List	signature:(Link *ent)
InsFirst	queue.cc	/^void Queue::InsFirst(Entity *ent)$/;"	f	class:simlib3::Queue	signature:(Entity *ent)
InsFirst	simlib.h	/^    void InsFirst(Entity *e);$/;"	p	class:simlib3::Queue	access:public	signature:(Entity *e)
InsFirst	simlib.h	/^    void InsFirst(Link *e);              \/\/ insert operation$/;"	p	class:simlib3::List	access:public	signature:(Link *e)
InsLast	list.cc	/^void List::InsLast(Link *ent)$/;"	f	class:simlib3::List	signature:(Link *ent)
InsLast	queue.cc	/^void Queue::InsLast(Entity *ent)$/;"	f	class:simlib3::Queue	signature:(Entity *ent)
InsLast	simlib.h	/^    void InsLast (Entity *e);$/;"	p	class:simlib3::Queue	access:public	signature:(Entity *e)
InsLast	simlib.h	/^    void InsLast (Link *e);$/;"	p	class:simlib3::List	access:public	signature:(Link *e)
Insert	intg.cc	/^IntegratorContainer::iterator IntegratorContainer::Insert(Integrator* ptr)$/;"	f	class:simlib3::IntegratorContainer	signature:(Integrator* ptr)
Insert	intg.cc	/^StatusContainer::iterator StatusContainer::Insert(Status* ptr)$/;"	f	class:simlib3::StatusContainer	signature:(Status* ptr)
Insert	queue.cc	/^void Queue::Insert(Entity *ent)$/;"	f	class:simlib3::Queue	signature:(Entity *ent)
Insert	simlib.h	/^    virtual void Insert  (Entity *e);            \/\/ priority insert$/;"	p	class:simlib3::Queue	access:public	signature:(Entity *e)
Insert	simlib.h	/^  static iterator Insert(Integrator* ptr);  \/\/ insert element into container$/;"	p	class:simlib3::IntegratorContainer	access:public	signature:(Integrator* ptr)
Insert	simlib.h	/^  static iterator Insert(Status* ptr);  \/\/ insert element into container$/;"	p	class:simlib3::StatusContainer	access:public	signature:(Status* ptr)
InsertCurrent	waitunti.cc	/^    static void InsertCurrent();     \/\/ insert current process into list$/;"	p	class:simlib3::WaitUntilList	file:	access:public	signature:()
InsertCurrent	waitunti.cc	/^void WaitUntilList::InsertCurrent()$/;"	f	class:simlib3::WaitUntilList	signature:()
InstallBreak	run.cc	/^void InstallBreak(void (*f)()) { \/\/ for user interface (in simlib.h)$/;"	f	namespace:simlib3	signature:(void (*f)())
InstallBreak	simlib.h	/^void InstallBreak(void (*f)());$/;"	p	namespace:simlib3	signature:(void (*f)())
Instance	intg.cc	/^std::list<Integrator*>* IntegratorContainer::Instance(void)$/;"	f	class:simlib3::IntegratorContainer	signature:(void)
Instance	intg.cc	/^std::list<Status*>* StatusContainer::Instance(void)$/;"	f	class:simlib3::StatusContainer	signature:(void)
Instance	simlib.h	/^  static std::list<Integrator*> * Instance(void);  \/\/ return list (& create)$/;"	p	class:simlib3::IntegratorContainer	access:private	signature:(void)
Instance	simlib.h	/^  static std::list<Status*>* Instance(void);  \/\/ return list (& create)$/;"	p	class:simlib3::StatusContainer	access:private	signature:(void)
Insv	simlib.h	/^  Insv(Input in, double l, double h, double tga=1.0, double tgb=1.0);$/;"	p	class:simlib3::Insv	access:public	signature:(Input in, double l, double h, double tga=1.0, double tgb=1.0)
Insv	simlib.h	/^class Insv : public aContiBlock1 {$/;"	c	namespace:simlib3	inherits:aContiBlock1
Insv	stdblock.cc	/^Insv::Insv(Input in, double l, double h, double tga, double tgb)$/;"	f	class:simlib3::Insv	signature:(Input in, double l, double h, double tga, double tgb)
Integrate	ni_abm4.cc	/^void ABM4::Integrate(void)$/;"	f	class:simlib3::ABM4	signature:(void)
Integrate	ni_abm4.h	/^  virtual void Integrate(void);  \/\/ integration method$/;"	p	class:simlib3::ABM4	access:public	signature:(void)
Integrate	ni_euler.cc	/^void EULER::Integrate(void)$/;"	f	class:simlib3::EULER	signature:(void)
Integrate	ni_euler.h	/^  virtual void Integrate(void);  \/\/ integration method$/;"	p	class:simlib3::EULER	access:public	signature:(void)
Integrate	ni_fw.cc	/^void FW::Integrate(void)$/;"	f	class:simlib3::FW	signature:(void)
Integrate	ni_fw.h	/^  virtual void Integrate(void);  \/\/ integration method$/;"	p	class:simlib3::FW	access:public	signature:(void)
Integrate	ni_rke.cc	/^void RKE::Integrate(void)$/;"	f	class:simlib3::RKE	signature:(void)
Integrate	ni_rke.h	/^  virtual void Integrate(void);  \/\/ integration method$/;"	p	class:simlib3::RKE	access:public	signature:(void)
Integrate	ni_rkf3.cc	/^void RKF3::Integrate(void)$/;"	f	class:simlib3::RKF3	signature:(void)
Integrate	ni_rkf3.h	/^  virtual void Integrate(void);  \/\/ integration method$/;"	p	class:simlib3::RKF3	access:public	signature:(void)
Integrate	ni_rkf5.cc	/^void RKF5::Integrate(void)$/;"	f	class:simlib3::RKF5	signature:(void)
Integrate	ni_rkf5.h	/^  virtual void Integrate(void);  \/\/ integration method$/;"	p	class:simlib3::RKF5	access:public	signature:(void)
Integrate	ni_rkf8.cc	/^void RKF8::Integrate(void)$/;"	f	class:simlib3::RKF8	signature:(void)
Integrate	ni_rkf8.h	/^  virtual void Integrate(void);  \/\/ integration method$/;"	p	class:simlib3::RKF8	access:public	signature:(void)
Integrate	simlib.h	/^  virtual void Integrate(void) = 0;  \/\/ the method does integration$/;"	p	class:simlib3::IntegrationMethod	access:public	signature:(void)
Integrate	simlib.h	/^  virtual void Integrate(void) = 0;  \/\/ the method does integration$/;"	p	class:simlib3::MultiStepMethod	access:public	signature:(void)
Integrate	simlib.h	/^  virtual void Integrate(void) = 0;  \/\/ the method does integration$/;"	p	class:simlib3::SingleStepMethod	access:public	signature:(void)
Integrate	simlib.h	/^  virtual void Integrate(void) = 0;  \/\/ the method does integration$/;"	p	class:simlib3::StatusMethod	access:public	signature:(void)
IntegrationDone	simlib.h	/^  static void IntegrationDone(void) {  \/\/ terminate integration$/;"	f	class:simlib3::IntegrationMethod	access:public	signature:(void)
IntegrationMethod	numint.cc	/^IntegrationMethod::IntegrationMethod(const char *name):$/;"	f	class:simlib3::IntegrationMethod	signature:(const char *name)
IntegrationMethod	simlib.h	/^    IntegrationMethod(const IntegrationMethod&); \/\/ ## disable$/;"	p	class:simlib3::IntegrationMethod	access:private	signature:(const IntegrationMethod&)
IntegrationMethod	simlib.h	/^  IntegrationMethod();  \/\/ forbid implicit constructor$/;"	p	class:simlib3::IntegrationMethod	access:private	signature:()
IntegrationMethod	simlib.h	/^  IntegrationMethod(IntegrationMethod&);  \/\/ forbid implicit copy-constructor$/;"	p	class:simlib3::IntegrationMethod	access:private	signature:(IntegrationMethod&)
IntegrationMethod	simlib.h	/^  IntegrationMethod(const char* name);  \/\/ registrate method and name it$/;"	p	class:simlib3::IntegrationMethod	access:public	signature:(const char* name)
IntegrationMethod	simlib.h	/^class IntegrationMethod {$/;"	c	namespace:simlib3
Integrator	intg.cc	/^Integrator::Integrator() : input(SIMLIB_Integrator_0input)$/;"	f	class:simlib3::Integrator	signature:()
Integrator	intg.cc	/^Integrator::Integrator(Input i, double initvalue) : input(i)$/;"	f	class:simlib3::Integrator	signature:(Input i, double initvalue)
Integrator	intg.cc	/^Integrator::Integrator(Integrator &i, double initvalue) :$/;"	f	class:simlib3::Integrator	signature:(Integrator &i, double initvalue)
Integrator	simlib.h	/^  Integrator();                        \/\/ implicit CTR (input = 0)$/;"	p	class:simlib3::Integrator	access:public	signature:()
Integrator	simlib.h	/^  Integrator(Input i, double initvalue=0);$/;"	p	class:simlib3::Integrator	access:public	signature:(Input i, double initvalue=0)
Integrator	simlib.h	/^  Integrator(Integrator &i, double initvalue=0); \/\/ copy-ctr$/;"	p	class:simlib3::Integrator	access:public	signature:(Integrator &i, double initvalue=0)
Integrator	simlib.h	/^class Integrator : public aContiBlock {   \/\/ integrator$/;"	c	namespace:simlib3	inherits:aContiBlock
Integrator2D	simlib2D.cc	/^Integrator2D::Integrator2D():$/;"	f	class:simlib3::Integrator2D	signature:()
Integrator2D	simlib2D.cc	/^Integrator2D::Integrator2D(Input2D i):$/;"	f	class:simlib3::Integrator2D	signature:(Input2D i)
Integrator2D	simlib2D.cc	/^Integrator2D::Integrator2D(Input2D i, Value2D initial_value):$/;"	f	class:simlib3::Integrator2D	signature:(Input2D i, Value2D initial_value)
Integrator2D	simlib2D.cc	/^Integrator2D::Integrator2D(Integrator2D &i, Value2D initial_value):$/;"	f	class:simlib3::Integrator2D	signature:(Integrator2D &i, Value2D initial_value)
Integrator2D	simlib2D.h	/^  Integrator2D();       \/\/ for arrays: implicit input value (0,0)$/;"	p	class:simlib3::Integrator2D	access:public	signature:()
Integrator2D	simlib2D.h	/^  Integrator2D(Input2D i);$/;"	p	class:simlib3::Integrator2D	access:public	signature:(Input2D i)
Integrator2D	simlib2D.h	/^  Integrator2D(Input2D i, Value2D initial_value);$/;"	p	class:simlib3::Integrator2D	access:public	signature:(Input2D i, Value2D initial_value)
Integrator2D	simlib2D.h	/^  Integrator2D(Integrator2D &i, Value2D initial_value=Value2D(0,0));$/;"	p	class:simlib3::Integrator2D	access:public	signature:(Integrator2D &i, Value2D initial_value=Value2D(0,0))
Integrator2D	simlib2D.h	/^class Integrator2D : public aContiBlock2D {$/;"	c	namespace:simlib3	inherits:aContiBlock2D
Integrator3D	simlib3D.cc	/^Integrator3D::Integrator3D():$/;"	f	class:simlib3::Integrator3D	signature:()
Integrator3D	simlib3D.cc	/^Integrator3D::Integrator3D(Input3D i):$/;"	f	class:simlib3::Integrator3D	signature:(Input3D i)
Integrator3D	simlib3D.cc	/^Integrator3D::Integrator3D(Input3D i, Value3D initial_value):$/;"	f	class:simlib3::Integrator3D	signature:(Input3D i, Value3D initial_value)
Integrator3D	simlib3D.cc	/^Integrator3D::Integrator3D(Integrator3D &i, Value3D initial_value):$/;"	f	class:simlib3::Integrator3D	signature:(Integrator3D &i, Value3D initial_value)
Integrator3D	simlib3D.h	/^  Integrator3D();       \/\/ for arrays: implicit input value (0,0,0)$/;"	p	class:simlib3::Integrator3D	access:public	signature:()
Integrator3D	simlib3D.h	/^  Integrator3D(Input3D i);$/;"	p	class:simlib3::Integrator3D	access:public	signature:(Input3D i)
Integrator3D	simlib3D.h	/^  Integrator3D(Input3D i, Value3D initial_value);$/;"	p	class:simlib3::Integrator3D	access:public	signature:(Input3D i, Value3D initial_value)
Integrator3D	simlib3D.h	/^  Integrator3D(Integrator3D &i, Value3D initial_value=Value3D(0,0,0));$/;"	p	class:simlib3::Integrator3D	access:public	signature:(Integrator3D &i, Value3D initial_value=Value3D(0,0,0))
Integrator3D	simlib3D.h	/^class Integrator3D : public aContiBlock3D {$/;"	c	namespace:simlib3	inherits:aContiBlock3D
IntegratorContainer	simlib.h	/^  IntegratorContainer();  \/\/ forbid constructor$/;"	p	class:simlib3::IntegratorContainer	access:private	signature:()
IntegratorContainer	simlib.h	/^class IntegratorContainer {$/;"	c	namespace:simlib3
InternalError	errors.h	/^\/* 2 *\/ InternalError,$/;"	e	enum:_ErrEnum
Interrupt	process.cc	/^void Process::Interrupt()$/;"	f	class:simlib3::Process	signature:()
Interrupt	simlib.h	/^  void Interrupt(); \/\/!< test of WaitUntil list, allow running others$/;"	p	class:simlib3::Process	access:public	signature:()
Into	link.cc	/^void Link::Into(List *l)$/;"	f	class:simlib3::Link	signature:(List *l)
Into	process.cc	/^void Process::Into(Queue & q)$/;"	f	class:simlib3::Process	signature:(Queue & q)
Into	simlib.h	/^  virtual void Into(List *l);          \/\/!< insert last$/;"	p	class:simlib3::Link	access:public	signature:(List *l)
Into	simlib.h	/^  virtual void Into(Queue &q);          \/\/!< insert process into queue$/;"	p	class:simlib3::Process	access:public	signature:(Queue &q)
IsConditionFlag	simlib.h	/^  static bool IsConditionFlag(void) { \/\/ wer any changes of condition vector?$/;"	f	class:simlib3::IntegrationMethod	access:public	signature:(void)
IsEndStepEvent	numint.cc	/^bool IntegrationMethod::IsEndStepEvent=false;$/;"	m	class:simlib3::IntegrationMethod	file:
IsEndStepEvent	simlib.h	/^  static bool IsEndStepEvent; \/\/ flag - will be event at the end of the step?$/;"	m	class:simlib3::IntegrationMethod	access:protected
IsSingleStep	simlib.h	/^  virtual bool IsSingleStep(void) {  \/\/ it's a multi-step method$/;"	f	class:simlib3::MultiStepMethod	access:public	signature:(void)
IsSingleStep	simlib.h	/^  virtual bool IsSingleStep(void) {  \/\/ it's a single-step method$/;"	f	class:simlib3::SingleStepMethod	access:public	signature:(void)
IsSingleStep	simlib.h	/^  virtual bool IsSingleStep(void)=0; \/\/ is it a single-step method?$/;"	p	class:simlib3::IntegrationMethod	access:public	signature:(void)
IsStartMode	simlib.h	/^  bool IsStartMode(void) {  \/\/ is method used to start multi-step method?$/;"	f	class:simlib3::SingleStepMethod	access:public	signature:(void)
ItList	simlib.h	/^  std::list<IntegrationMethod*>::iterator ItList;  \/\/ position in the list$/;"	m	class:simlib3::IntegrationMethod	access:private
Iterate	numint.cc	/^void IntegrationMethod::Iterate(void)$/;"	f	class:simlib3::IntegrationMethod	signature:(void)
Iterate	simlib.h	/^  static void Iterate(void);  \/\/ compute new values of state blocks$/;"	p	class:simlib3::IntegrationMethod	access:private	signature:(void)
Iterations	simlib.h	/^  Iterations(Input i, double eps, unsigned long max_it,$/;"	f	class:simlib3::Iterations	access:public	signature:(Input i, double eps, unsigned long max_it, double t_min, double t_max, double t0)
Iterations	simlib.h	/^class Iterations : public AlgLoop {$/;"	c	namespace:simlib3	inherits:AlgLoop
Iterator	simlib.h	/^  typedef IntegratorContainer::iterator Iterator;  \/\/ iterator of intg. list$/;"	t	class:simlib3::IntegrationMethod	access:protected
LIST_MAX	calendar.cc	/^const unsigned LIST_MAX   = 512; \/\/ TODO:tune parameter: 64-1024$/;"	m	namespace:simlib3	file:
LIST_MIN	calendar.cc	/^const unsigned LIST_MIN   = LIST_MAX\/2; \/\/ TODO:tune parameter$/;"	m	namespace:simlib3	file:
LOWEST_PRIORITY	simlib.h	/^  LOWEST_PRIORITY  = -127,$/;"	e	enum:simlib3::__anon1
LastIntegrator	simlib.h	/^  static Iterator LastIntegrator(void) {  \/\/ it. to last integrator in list$/;"	f	class:simlib3::IntegrationMethod	access:protected	signature:(void)
LastStatus	simlib.h	/^  static StatusIterator LastStatus(void) {  \/\/ it. to last status in list$/;"	f	class:simlib3::StatusMethod	access:protected	signature:(void)
LastTime	simlib.h	/^  double LastTime() const      { return tl; }$/;"	f	class:simlib3::TStat	access:public	signature:() const
LastValue	simlib.h	/^  double LastValue() const     { return xl; }$/;"	f	class:simlib3::TStat	access:public	signature:() const
Leave	process.cc	/^void Process::Leave(Store & s, unsigned long cap)$/;"	f	class:simlib3::Process	signature:(Store & s, unsigned long cap)
Leave	simlib.h	/^  virtual void Leave(unsigned long rcap);               \/\/!< deallocate capacity$/;"	p	class:simlib3::Store	access:public	signature:(unsigned long rcap)
Leave	simlib.h	/^  void Leave(Store &s, unsigned long ReqCap=1); \/\/!< return some capacity$/;"	p	class:simlib3::Process	access:public	signature:(Store &s, unsigned long ReqCap=1)
Leave	store.cc	/^void Store::Leave(unsigned long rcap)$/;"	f	class:simlib3::Store	signature:(unsigned long rcap)
LeaveManyError	errors.h	/^\/* 39 *\/ LeaveManyError,$/;"	e	enum:_ErrEnum
Length	simlib.h	/^    unsigned Length() { return size(); }$/;"	f	class:simlib3::Queue	access:public	signature:()
Lim	simlib.h	/^  Lim(Input in, double l, double h, double tga=1.0);$/;"	p	class:simlib3::Lim	access:public	signature:(Input in, double l, double h, double tga=1.0)
Lim	simlib.h	/^class Lim : public aContiBlock1 {$/;"	c	namespace:simlib3	inherits:aContiBlock1
Lim	stdblock.cc	/^Lim::Lim(Input in, double l, double h, double tga)$/;"	f	class:simlib3::Lim	signature:(Input in, double l, double h, double tga)
Limitation	simlib.h	/^typedef Lim Limitation;$/;"	t	namespace:simlib3
Link	link.cc	/^Link::Link() :$/;"	f	class:simlib3::Link	signature:()
Link	link.cc	/^Link::Link(Link *p, Link *s, List *h) :$/;"	f	class:simlib3::Link	signature:(Link *p, Link *s, List *h)
Link	simlib.h	/^  Link();$/;"	p	class:simlib3::Link	access:public	signature:()
Link	simlib.h	/^  Link(Link *p, Link *s, List *h);$/;"	p	class:simlib3::Link	access:protected	signature:(Link *p, Link *s, List *h)
Link	simlib.h	/^  Link(Link&);                         \/\/ disable operation$/;"	p	class:simlib3::Link	access:private	signature:(Link&)
Link	simlib.h	/^class Link : public SimObject {$/;"	c	namespace:simlib3	inherits:SimObject
LinkDelError	errors.h	/^\/* 15 *\/ LinkDelError,$/;"	e	enum:_ErrEnum
LinkOutError	errors.h	/^\/* 16 *\/ LinkOutError,$/;"	e	enum:_ErrEnum
LinkRefError	errors.h	/^\/* 14 *\/ LinkRefError,$/;"	e	enum:_ErrEnum
List	list.cc	/^List::List() : Link(this,this,this), n(0)$/;"	f	class:simlib3::List	signature:()
List	list.cc	/^List::List(const char *name) : Link(this,this,this), n(0)$/;"	f	class:simlib3::List	signature:(const char *name)
List	simlib.h	/^    List();$/;"	p	class:simlib3::List	access:public	signature:()
List	simlib.h	/^    List(List&);                         \/\/ disable$/;"	p	class:simlib3::List	access:private	signature:(List&)
List	simlib.h	/^    List(const char *_name);$/;"	p	class:simlib3::List	access:public	signature:(const char *_name)
List	simlib.h	/^class List : public Link { \/\/ circular list of Link items$/;"	c	namespace:simlib3	inherits:Link
ListActivityError	errors.h	/^\/* 24 *\/ ListActivityError,$/;"	e	enum:_ErrEnum
ListEmptyError	errors.h	/^\/* 25 *\/ ListEmptyError,$/;"	e	enum:_ErrEnum
ListPtr	intg.cc	/^std::list<Integrator*>* IntegratorContainer::ListPtr=NULL;$/;"	m	class:simlib3::IntegratorContainer	file:
ListPtr	intg.cc	/^std::list<Status*>* StatusContainer::ListPtr=NULL;$/;"	m	class:simlib3::StatusContainer	file:
ListPtr	simlib.h	/^      std::list<Memory*> * ListPtr;  \/\/ which list is memory in$/;"	m	class:simlib3::IntegrationMethod::Memory	access:private
ListPtr	simlib.h	/^  static std::list<Integrator*> * ListPtr;  \/\/ list of integrators$/;"	m	class:simlib3::IntegratorContainer	access:private
ListPtr	simlib.h	/^  static std::list<Status*>* ListPtr;  \/\/ list of integrators$/;"	m	class:simlib3::StatusContainer	access:private
Ln	fun.cc	/^Input Ln(Input x)               { return new Function1(x, log); }$/;"	f	namespace:simlib3	signature:(Input x)
Ln	simlib.h	/^Input Ln(Input x);              \/\/ ln(x)      natural logarithm$/;"	p	namespace:simlib3	signature:(Input x)
Log10	fun.cc	/^Input Log10(Input x)            { return new Function1(x, log10); }$/;"	f	namespace:simlib3	signature:(Input x)
Log10	simlib.h	/^Input Log10(Input x);           \/\/ log10(x)$/;"	p	namespace:simlib3	signature:(Input x)
Logar	random2.cc	/^double Logar(double mi, double delta)$/;"	f	namespace:simlib3	signature:(double mi, double delta)
Logar	simlib.h	/^double Logar(double mi, double delta);$/;"	p	namespace:simlib3	signature:(double mi, double delta)
Low	simlib.h	/^  double Low() const     { return low; }$/;"	f	class:simlib3::Histogram	access:public	signature:() const
LowGreaterHigh	errors.h	/^\/* 56 *\/ LowGreaterHigh,$/;"	e	enum:_ErrEnum
LtoN	intg.cc	/^void IntegratorContainer::LtoN()$/;"	f	class:simlib3::IntegratorContainer	signature:()
LtoN	intg.cc	/^void StatusContainer::LtoN()$/;"	f	class:simlib3::StatusContainer	signature:()
LtoN	simlib.h	/^  static void LtoN();              \/\/ last -> now$/;"	p	class:simlib3::IntegratorContainer	access:public	signature:()
LtoN	simlib.h	/^  static void LtoN();              \/\/ last -> now$/;"	p	class:simlib3::StatusContainer	access:public	signature:()
MAKEFILE	Makefile	/^MAKEFILE = Makefile.`uname -s`-`uname -m`$/;"	m
MAKEFILE32	Makefile	/^MAKEFILE32 = Makefile.`uname -s`-i686$/;"	m
MAKEFILE64	Makefile	/^MAKEFILE64 = Makefile.`uname -s`-x86_64$/;"	m
MAXERR	generr.c	13;"	d	file:
MAXHISTOCOUNT	histo.cc	/^const unsigned MAXHISTOCOUNT = 10000;$/;"	m	namespace:simlib3	file:
MAXIDLEN	generr.c	14;"	d	file:
MAXLINELEN	generr.c	15;"	d	file:
MAXLONGINT	random1.cc	/^const myint32 MAXLONGINT = 0x7FFFFFFFUL;$/;"	m	namespace:simlib3	file:
MAXSIZELIMIT	calendar.cc	/^    static const unsigned MAXSIZELIMIT = 1000000;$/;"	m	class:simlib3::EventNoticeAllocator	file:	access:private
MAX_ATEXIT	atexit.cc	/^static const int MAX_ATEXIT = 10; \/\/ for internal use it is enough$/;"	m	namespace:simlib3	file:
MAX_OP	calendar.cc	618;"	d	file:
MINBUCKETS	calendar.cc	/^const unsigned MINBUCKETS = LIST_MAX>4?LIST_MAX:4; \/\/ should be power of 2 and >=4$/;"	m	namespace:simlib3	file:
MList	simlib.h	/^  std::list<Memory*> MList;  \/\/ list of auxiliary memories$/;"	m	class:simlib3::IntegrationMethod	access:private
MODULES	Makefile	/^	make -f $(MAKEFILE) MODULES="fuzzy" clean$/;"	m
MULCONST	random1.cc	/^const myint32 MULCONST   = 1220703125L;$/;"	m	namespace:simlib3	file:
MUL_PAR	calendar.cc	/^const double MUL_PAR      = 1.0; \/\/ TODO:tune parameter: 1.0--5.0$/;"	m	namespace:simlib3	file:
Max	fun.cc	/^Input Max(Input x, Input y)     { return new Function2(x, y, max); }$/;"	f	namespace:simlib3	signature:(Input x, Input y)
Max	optimize.h	/^    double Max() const { return max; }$/;"	f	class:simlib3::Param	access:public	signature:() const
Max	simlib.h	/^  double Max() const           { \/* test n==0 *\/ return max; }$/;"	f	class:simlib3::Stat	access:public	signature:() const
Max	simlib.h	/^  double Max() const           { return max; }$/;"	f	class:simlib3::TStat	access:public	signature:() const
Max	simlib.h	/^  double Max() const { \/* test n==0 *\/ return max; }$/;"	f	class:simlib3::aStat	access:public	signature:() const
Max	simlib.h	/^Input Max(Input x, Input y);    \/\/ maximum$/;"	p	namespace:simlib3	signature:(Input x, Input y)
MaxIt	simlib.h	/^  unsigned long MaxIt; \/\/ max. number of iterations$/;"	m	class:simlib3::AlgLoop	access:protected
MaxStep	intg.cc	/^const double &MaxStep=SIMLIB_MaxStep;        \/\/!< maximal integration step$/;"	m	namespace:simlib3	file:
MaxStep	simlib.h	/^  double MaxStep;$/;"	m	struct:simlib3::SIMLIB_statistics_t	access:public
MeanValue	simlib.h	/^  double MeanValue() const;$/;"	p	class:simlib3::Stat	access:public	signature:() const
MeanValue	simlib.h	/^  double MeanValue() const;$/;"	p	class:simlib3::TStat	access:public	signature:() const
MeanValue	simlib.h	/^  virtual double MeanValue() = 0;           \/\/!< compute mean value$/;"	p	class:simlib3::aStat	access:public	signature:()
MeanValue	stat.cc	/^double Stat::MeanValue() const$/;"	f	class:simlib3::Stat	signature:() const
MeanValue	tstat.cc	/^double TStat::MeanValue() const$/;"	f	class:simlib3::TStat	signature:() const
Memory	numint.cc	/^IntegrationMethod::Memory::Memory(std::list<Memory*>* PtrList) :$/;"	f	class:simlib3::IntegrationMethod::Memory	signature:(std::list<Memory*>* PtrList)
Memory	simlib.h	/^      Memory(Memory&);  \/\/ forbid copy constructor$/;"	p	class:simlib3::IntegrationMethod::Memory	access:private	signature:(Memory&)
Memory	simlib.h	/^      Memory(const Memory&); \/\/ ## disable$/;"	p	class:simlib3::IntegrationMethod::Memory	access:private	signature:(const Memory&)
Memory	simlib.h	/^      Memory(std::list<Memory*> * PtrList=PtrMList);  \/\/ create empty memory$/;"	p	class:simlib3::IntegrationMethod::Memory	access:public	signature:(std::list<Memory*> * PtrList=PtrMList)
Memory	simlib.h	/^  class Memory {$/;"	c	class:simlib3::IntegrationMethod	access:protected
MemoryError	errors.h	/^\/* 3 *\/ MemoryError,$/;"	e	enum:_ErrEnum
Min	fun.cc	/^Input Min(Input x, Input y)     { return new Function2(x, y, min); }$/;"	f	namespace:simlib3	signature:(Input x, Input y)
Min	optimize.h	/^    double Min() const { return min; }$/;"	f	class:simlib3::Param	access:public	signature:() const
Min	simlib.h	/^  double Min() const           { \/* TODO: test n==0 *\/ return min; }$/;"	f	class:simlib3::Stat	access:public	signature:() const
Min	simlib.h	/^  double Min() const           { \/*TODO: only if(n>0)*\/ return min; }$/;"	f	class:simlib3::TStat	access:public	signature:() const
Min	simlib.h	/^  double Min() const { \/* test n==0 +exception *\/ return min; }$/;"	f	class:simlib3::aStat	access:public	signature:() const
Min	simlib.h	/^Input Min(Input x, Input y);    \/\/ minimum$/;"	p	namespace:simlib3	signature:(Input x, Input y)
MinStep	intg.cc	/^const double &MinStep=SIMLIB_MinStep;        \/\/!< minimal integration step$/;"	m	namespace:simlib3	file:
MinStep	simlib.h	/^  double MinStep;$/;"	m	struct:simlib3::SIMLIB_statistics_t	access:public
MinTime	calendar.cc	/^    double MinTime() const { return mintime; }$/;"	f	class:simlib3::Calendar	access:public	signature:() const
MthLstPtr	numint.cc	/^std::list<IntegrationMethod*>* IntegrationMethod::MthLstPtr=NULL;$/;"	m	class:simlib3::IntegrationMethod	file:
MthLstPtr	simlib.h	/^  static std::list<IntegrationMethod*>* MthLstPtr; \/\/ list of registrated methods$/;"	m	class:simlib3::IntegrationMethod	access:private
MultiStepMethod	numint.cc	/^MultiStepMethod::MultiStepMethod(const char* name, const char* slave_name) :$/;"	f	class:simlib3::MultiStepMethod	signature:(const char* name, const char* slave_name)
MultiStepMethod	simlib.h	/^    MultiStepMethod(const MultiStepMethod&); \/\/ ## disable$/;"	p	class:simlib3::MultiStepMethod	access:private	signature:(const MultiStepMethod&)
MultiStepMethod	simlib.h	/^  MultiStepMethod(const char* name, const char* slave_name);$/;"	p	class:simlib3::MultiStepMethod	access:public	signature:(const char* name, const char* slave_name)
MultiStepMethod	simlib.h	/^class MultiStepMethod : public IntegrationMethod {$/;"	c	namespace:simlib3	inherits:IntegrationMethod
MyStrDup	generr.c	/^char *MyStrDup(char *sp)$/;"	f	signature:(char *sp)
NI_CantSetMethod	errors.h	/^\/* 73 *\/ NI_CantSetMethod,$/;"	e	enum:_ErrEnum
NI_CantSetStarter	errors.h	/^\/* 74 *\/ NI_CantSetStarter,$/;"	e	enum:_ErrEnum
NI_IlStepSize	errors.h	/^\/* 70 *\/ NI_IlStepSize,$/;"	e	enum:_ErrEnum
NI_MultDefMeth	errors.h	/^\/* 69 *\/ NI_MultDefMeth,$/;"	e	enum:_ErrEnum
NI_NotMultiStep	errors.h	/^\/* 72 *\/ NI_NotMultiStep,$/;"	e	enum:_ErrEnum
NI_NotSingleStep	errors.h	/^\/* 71 *\/ NI_NotSingleStep,$/;"	e	enum:_ErrEnum
NI_UnknownMeth	errors.h	/^\/* 68 *\/ NI_UnknownMeth,$/;"	e	enum:_ErrEnum
Name	algloop.cc	/^const char *AlgLoop::Name() const$/;"	f	class:simlib3::AlgLoop	signature:() const
Name	calendar.cc	/^    virtual const char* Name() { return "CalendarList"; }$/;"	f	class:simlib3::CalendarList	access:public	signature:()
Name	calendar.cc	/^    virtual const char* Name() { return "CalendarQueue"; }$/;"	f	class:simlib3::CalendarQueue	access:public	signature:()
Name	cond.cc	/^const char *Condition::Name() const {$/;"	f	class:simlib3::Condition	signature:() const
Name	cond.cc	/^const char *ConditionDown::Name() const {$/;"	f	class:simlib3::ConditionDown	signature:() const
Name	cond.cc	/^const char *ConditionUp::Name() const {$/;"	f	class:simlib3::ConditionUp	signature:() const
Name	continuous.cc	/^  virtual const char *Name() const { return "T(Time)"; }$/;"	f	class:simlib3::_Time	access:public	signature:() const
Name	continuous.cc	/^  virtual const char *Name() const {$/;"	f	class:simlib3::_Add	access:public	signature:() const
Name	continuous.cc	/^  virtual const char *Name() const {$/;"	f	class:simlib3::_Div	access:public	signature:() const
Name	continuous.cc	/^  virtual const char *Name() const {$/;"	f	class:simlib3::_Mul	access:public	signature:() const
Name	continuous.cc	/^  virtual const char *Name() const {$/;"	f	class:simlib3::_Sub	access:public	signature:() const
Name	continuous.cc	/^  virtual const char *Name() const {$/;"	f	class:simlib3::_UMinus	access:public	signature:() const
Name	entity.cc	/^const char *Entity::Name() const$/;"	f	class:simlib3::Entity	signature:() const
Name	event.cc	/^const char *Event::Name() const$/;"	f	class:simlib3::Event	signature:() const
Name	fun.cc	/^const char *Function1::Name() const {$/;"	f	class:simlib3::Function1	signature:() const
Name	fun.cc	/^const char *Function2::Name() const {$/;"	f	class:simlib3::Function2	signature:() const
Name	intg.cc	/^const char *Integrator::Name() const$/;"	f	class:simlib3::Integrator	signature:() const
Name	intg.cc	/^const char *Status::Name() const$/;"	f	class:simlib3::Status	signature:() const
Name	object.cc	/^const char *SimObject::Name() const$/;"	f	class:simlib3::SimObject	signature:() const
Name	optimize.h	/^    const char *Name() const { return name; }$/;"	f	class:simlib3::Param	access:public	signature:() const
Name	process.cc	/^const char *Process::Name() const$/;"	f	class:simlib3::Process	signature:() const
Name	queue.cc	/^const char *Queue::Name() const$/;"	f	class:simlib3::Queue	signature:() const
Name	simlib.h	/^    virtual const char *Name() const;   \/\/!< name of the entity$/;"	p	class:simlib3::Entity	access:public	signature:() const
Name	simlib.h	/^    virtual const char *Name() const;$/;"	p	class:simlib3::Hyst	access:public	signature:() const
Name	simlib.h	/^    virtual const char *Name() const;$/;"	p	class:simlib3::Queue	access:public	signature:() const
Name	simlib.h	/^  virtual const char *Name() const;     \/\/!< name of object$/;"	p	class:simlib3::Event	access:public	signature:() const
Name	simlib.h	/^  virtual const char *Name() const;     \/\/!< name of object$/;"	p	class:simlib3::Process	access:public	signature:() const
Name	simlib.h	/^  virtual const char *Name() const;    \/\/!< get object name$/;"	p	class:simlib3::SimObject	access:public	signature:() const
Name	simlib.h	/^  virtual const char *Name() const;$/;"	p	class:simlib3::AlgLoop	access:public	signature:() const
Name	simlib.h	/^  virtual const char *Name() const;$/;"	p	class:simlib3::Blash	access:public	signature:() const
Name	simlib.h	/^  virtual const char *Name() const;$/;"	p	class:simlib3::Condition	access:public	signature:() const
Name	simlib.h	/^  virtual const char *Name() const;$/;"	p	class:simlib3::ConditionDown	access:public	signature:() const
Name	simlib.h	/^  virtual const char *Name() const;$/;"	p	class:simlib3::ConditionUp	access:public	signature:() const
Name	simlib.h	/^  virtual const char *Name() const;$/;"	p	class:simlib3::Frict	access:public	signature:() const
Name	simlib.h	/^  virtual const char *Name() const;$/;"	p	class:simlib3::Function1	access:public	signature:() const
Name	simlib.h	/^  virtual const char *Name() const;$/;"	p	class:simlib3::Function2	access:public	signature:() const
Name	simlib.h	/^  virtual const char *Name() const;$/;"	p	class:simlib3::Insv	access:public	signature:() const
Name	simlib.h	/^  virtual const char *Name() const;$/;"	p	class:simlib3::Integrator	access:public	signature:() const
Name	simlib.h	/^  virtual const char *Name() const;$/;"	p	class:simlib3::Lim	access:public	signature:() const
Name	simlib.h	/^  virtual const char *Name() const;$/;"	p	class:simlib3::Qntzr	access:public	signature:() const
Name	simlib.h	/^  virtual const char *Name() const;$/;"	p	class:simlib3::Relay	access:public	signature:() const
Name	simlib.h	/^  virtual const char *Name() const;$/;"	p	class:simlib3::Rline	access:public	signature:() const
Name	simlib.h	/^  virtual const char *Name() const;$/;"	p	class:simlib3::Status	access:public	signature:() const
Name	stdblock.cc	/^const char *Blash::Name() const$/;"	f	class:simlib3::Blash	signature:() const
Name	stdblock.cc	/^const char *Frict::Name() const$/;"	f	class:simlib3::Frict	signature:() const
Name	stdblock.cc	/^const char *Hyst::Name() const$/;"	f	class:simlib3::Hyst	signature:() const
Name	stdblock.cc	/^const char *Insv::Name() const$/;"	f	class:simlib3::Insv	signature:() const
Name	stdblock.cc	/^const char *Lim::Name() const$/;"	f	class:simlib3::Lim	signature:() const
Name	stdblock.cc	/^const char *Qntzr::Name() const$/;"	f	class:simlib3::Qntzr	signature:() const
Name	stdblock.cc	/^const char *Relay::Name() const$/;"	f	class:simlib3::Relay	signature:() const
Name	stdblock.cc	/^const char *Rline::Name() const$/;"	f	class:simlib3::Rline	signature:() const
NegBin	random2.cc	/^int NegBin(double q, int k)$/;"	f	namespace:simlib3	signature:(double q, int k)
NegBin	simlib.h	/^int    NegBin(double q, int k);$/;"	p	namespace:simlib3	signature:(double q, int k)
NegBinError	errors.h	/^\/* 44 *\/ NegBinError,$/;"	e	enum:_ErrEnum
NegBinM	random2.cc	/^int NegBinM(double p, int m)$/;"	f	namespace:simlib3	signature:(double p, int m)
NegBinM	simlib.h	/^int    NegBinM(double p,int m);$/;"	p	namespace:simlib3	signature:(double p,int m)
NegBinMError1	errors.h	/^\/* 45 *\/ NegBinMError1,$/;"	e	enum:_ErrEnum
NegBinMError2	errors.h	/^\/* 46 *\/ NegBinMError2,$/;"	e	enum:_ErrEnum
Newton	simlib.h	/^  Newton(Input i, double eps, unsigned long max_it,$/;"	f	class:simlib3::Newton	access:public	signature:(Input i, double eps, unsigned long max_it, double t_min, double t_max, double t0)
Newton	simlib.h	/^class Newton : public AlgLoop {$/;"	c	namespace:simlib3	inherits:AlgLoop
Next	simlib.h	/^    Sampler *Next;                      \/\/ next object$/;"	m	class:simlib3::Sampler	access:private
Next	simlib.h	/^  aCondition *Next;                    \/\/ next condition in list$/;"	m	class:simlib3::aCondition	access:private
NextTime	run.cc	/^const double & NextTime  = SIMLIB_NextTime;     \/\/ next-event time$/;"	m	namespace:simlib3	file:
NoDebugErr	errors.h	/^\/* 77 *\/ NoDebugErr,$/;"	e	enum:_ErrEnum
NoError	generr.c	/^\/* 0 *\/ NoError,$/;"	e	enum:ErrEnum	file:
Normal	random2.cc	/^double Normal(double mi, double sigma)$/;"	f	namespace:simlib3	signature:(double mi, double sigma)
Normal	simlib.h	/^double Normal(double mi, double sigma);$/;"	p	namespace:simlib3	signature:(double mi, double sigma)
NtoL	intg.cc	/^void IntegratorContainer::NtoL()$/;"	f	class:simlib3::IntegratorContainer	signature:()
NtoL	intg.cc	/^void StatusContainer::NtoL()$/;"	f	class:simlib3::StatusContainer	signature:()
NtoL	simlib.h	/^  static void NtoL();              \/\/ now -> last$/;"	p	class:simlib3::IntegratorContainer	access:public	signature:()
NtoL	simlib.h	/^  static void NtoL();              \/\/ now -> last$/;"	p	class:simlib3::StatusContainer	access:public	signature:()
NumErr	generr.c	/^    unsigned NumErr;$/;"	m	struct:__anon3	file:	access:public
Number	simlib.h	/^  unsigned long Number() const { return n; }$/;"	f	class:simlib3::Stat	access:public	signature:() const
Number	simlib.h	/^  unsigned long Number() const { return n; }$/;"	f	class:simlib3::TStat	access:public	signature:() const
NumberOfRecords	simlib.h	/^  unsigned long NumberOfRecords() const { return n; }$/;"	f	class:simlib3::aStat	access:public	signature:() const
OP_ESTIMATE	calendar.cc	/^    OP_ESTIMATE=2,$/;"	e	enum:__anon4::__anon5	file:
OP_MEASURE	calendar.cc	/^int OP_MEASURE = 0;$/;"	m	namespace:__anon4	file:
OP_RESIZE	calendar.cc	/^    OP_RESIZE=1,$/;"	e	enum:__anon4::__anon5	file:
OP_SWITCH2CQ	calendar.cc	/^    OP_SWITCH2CQ=4,$/;"	e	enum:__anon4::__anon5	file:
OP_SWITCH2LIST	calendar.cc	/^    OP_SWITCH2LIST=8,$/;"	e	enum:__anon4::__anon5	file:
OpenInputFile	generr.c	/^FILE *OpenInputFile(char *name)$/;"	f	signature:(char *name)
OpenOutputFile	generr.c	/^FILE *OpenOutputFile(char *name)$/;"	f	signature:(char *name)
OptStep	intg.cc	/^const double &OptStep=SIMLIB_OptStep;        \/\/!< optimal integration step$/;"	m	namespace:simlib3	file:
Optimize_gradient	optimize.h	/^double Optimize_gradient(opt_function_t f, ParameterVector & p,$/;"	p	namespace:simlib3	signature:(opt_function_t f, ParameterVector & p, double MAXITER)
Optimize_hooke	opt-hooke.cc	/^double Optimize_hooke(opt_function_t f, ParameterVector & parameter,$/;"	f	namespace:simlib3	signature:(opt_function_t f, ParameterVector & parameter, double rho, double epsilon, int itermax)
Optimize_hooke	optimize.h	/^double Optimize_hooke(opt_function_t f, ParameterVector & p,$/;"	p	namespace:simlib3	signature:(opt_function_t f, ParameterVector & p, double rho, double epsilon, int itermax)
Optimize_simann	opt-simann.cc	/^double Optimize_simann(double (*f) (const ParameterVector & p),$/;"	f	namespace:simlib3	signature:(double (*f) (const ParameterVector & p), ParameterVector & p, int MAXT)
Optimize_simann	optimize.h	/^double Optimize_simann(opt_function_t f, ParameterVector & p, int MAXT);$/;"	p	namespace:simlib3	signature:(opt_function_t f, ParameterVector & p, int MAXT)
Out	entity.cc	/^void Entity::Out()$/;"	f	class:simlib3::Entity	signature:()
Out	link.cc	/^void Link::Out()$/;"	f	class:simlib3::Link	signature:()
Out	simlib.h	/^    virtual void Out();                 \/\/!< remove entity from queue$/;"	p	class:simlib3::Entity	access:public	signature:()
Out	simlib.h	/^  virtual void Out();                  \/\/!< remove from list$/;"	p	class:simlib3::Link	access:public	signature:()
OutFile	print.cc	/^    static FILE *OutFile;$/;"	m	class:simlib3::_FileWrap	file:	access:private
OutFile	print.cc	/^FILE *_FileWrap::OutFile = 0;$/;"	m	class:simlib3::_FileWrap	file:
OutFile	print.cc	/^} OutFile;$/;"	m	namespace:simlib3	typeref:class:simlib3::_FileWrap	file:
OutFileOpenError	errors.h	/^\/* 52 *\/ OutFileOpenError,$/;"	e	enum:_ErrEnum
OutFilePutError	errors.h	/^\/* 51 *\/ OutFilePutError,$/;"	e	enum:_ErrEnum
Output	barrier.cc	/^void Barrier::Output() const {$/;"	f	class:simlib3::Barrier	signature:() const
Output	object.cc	/^void SimObject::Output() const$/;"	f	class:simlib3::SimObject	signature:() const
Output	output1.cc	/^void Event::Output() const$/;"	f	class:simlib3::Event	signature:() const
Output	output1.cc	/^void List::Output() const$/;"	f	class:simlib3::List	signature:() const
Output	output1.cc	/^void SIMLIB_statistics_t::Output() const$/;"	f	class:simlib3::SIMLIB_statistics_t	signature:() const
Output	output2.cc	/^void Facility::Output() const$/;"	f	class:simlib3::Facility	signature:() const
Output	output2.cc	/^void Histogram::Output() const$/;"	f	class:simlib3::Histogram	signature:() const
Output	output2.cc	/^void Process::Output() const$/;"	f	class:simlib3::Process	signature:() const
Output	output2.cc	/^void Queue::Output() const$/;"	f	class:simlib3::Queue	signature:() const
Output	output2.cc	/^void Stat::Output() const$/;"	f	class:simlib3::Stat	signature:() const
Output	output2.cc	/^void Store::Output() const$/;"	f	class:simlib3::Store	signature:() const
Output	output2.cc	/^void TStat::Output() const$/;"	f	class:simlib3::TStat	signature:() const
Output	sampler.cc	/^void Sampler::Output() const$/;"	f	class:simlib3::Sampler	signature:() const
Output	semaphor.cc	/^void Semaphore::Output() const {$/;"	f	class:simlib3::Semaphore	signature:() const
Output	simlib.h	/^    virtual void Output() const;          \/\/!< print object to default output$/;"	p	class:simlib3::List	access:public	signature:() const
Output	simlib.h	/^    virtual void Output() const;          \/\/!< print object to default output$/;"	p	class:simlib3::Sampler	access:public	signature:() const
Output	simlib.h	/^    virtual void Output() const;         \/\/!< print statistics$/;"	p	class:simlib3::Queue	access:public	signature:() const
Output	simlib.h	/^  virtual void Output() const;                          \/\/!< print statistics$/;"	p	class:simlib3::Store	access:public	signature:() const
Output	simlib.h	/^  virtual void Output() const;                   \/\/!< print statistics$/;"	p	class:simlib3::Facility	access:public	signature:() const
Output	simlib.h	/^  virtual void Output() const;          \/\/!< print object to default output$/;"	p	class:simlib3::Event	access:public	signature:() const
Output	simlib.h	/^  virtual void Output() const;          \/\/!< print object to default output$/;"	p	class:simlib3::Process	access:public	signature:() const
Output	simlib.h	/^  virtual void Output() const;          \/\/!< print object to default output$/;"	p	class:simlib3::TStat	access:public	signature:() const
Output	simlib.h	/^  virtual void Output() const;          \/\/!< print status$/;"	p	class:simlib3::Barrier	access:public	signature:() const
Output	simlib.h	/^  virtual void Output() const;         \/\/!< print object to default output$/;"	p	class:simlib3::SimObject	access:public	signature:() const
Output	simlib.h	/^  virtual void Output() const;         \/\/!< print to default output$/;"	p	class:simlib3::Histogram	access:public	signature:() const
Output	simlib.h	/^  virtual void Output() const;        \/\/!< Print all values to output file$/;"	p	class:simlib3::aStat	access:public	signature:() const
Output	simlib.h	/^  virtual void Output() const;  \/\/!< print statistics$/;"	p	class:simlib3::Stat	access:public	signature:() const
Output	simlib.h	/^  virtual void Output() const;$/;"	p	class:simlib3::Semaphore	access:public	signature:() const
Output	simlib.h	/^  void Output() const;$/;"	p	struct:simlib3::SIMLIB_statistics_t	access:public	signature:() const
OwnQueue	facility.cc	/^bool Facility::OwnQueue() const$/;"	f	class:simlib3::Facility	signature:() const
OwnQueue	simlib.h	/^  bool OwnQueue() const;                         \/\/!< test for default queue$/;"	p	class:simlib3::Facility	access:public	signature:() const
OwnQueue	simlib.h	/^  bool OwnQueue() const;$/;"	p	class:simlib3::Store	access:public	signature:() const
OwnQueue	store.cc	/^bool Store::OwnQueue() const$/;"	f	class:simlib3::Store	signature:() const
P	semaphor.cc	/^void Semaphore::P()$/;"	f	class:simlib3::Semaphore	signature:()
P	simlib.h	/^  virtual void P();                             \/\/!< P operation$/;"	p	class:simlib3::Semaphore	access:public	signature:()
PRED	ni_abm4.h	/^  Memory PRED;  \/\/ auxiliary memories -- value of predictor$/;"	m	class:simlib3::ABM4	access:private
P_Context	process.cc	/^static P_Context_t *volatile P_Context = 0;      \/\/ temporary - process state$/;"	m	namespace:simlib3	file:
P_Context_t	process.cc	/^struct P_Context_t {$/;"	s	namespace:simlib3	file:
Pair	delay.cc	/^        Pair(double t, double v) : time(t), value(v) {}$/;"	f	struct:simlib3::SIMLIB_DelayBuffer::Pair	access:public	signature:(double t, double v)
Pair	delay.cc	/^    struct Pair {$/;"	s	class:simlib3::SIMLIB_DelayBuffer	file:	access:private
Param	optimize.h	/^    Param (const char *n, double a, double b):$/;"	f	class:simlib3::Param	access:public	signature:(const char *n, double a, double b)
Param	optimize.h	/^    Param():$/;"	f	class:simlib3::Param	access:public	signature:()
Param	optimize.h	/^class Param$/;"	c	namespace:simlib3
Parameter	simlib.h	/^  Parameter(double x) : value(x) {}$/;"	f	class:simlib3::Parameter	access:public	signature:(double x)
Parameter	simlib.h	/^class Parameter : public aContiBlock {$/;"	c	namespace:simlib3	inherits:aContiBlock
Parameter2D	simlib2D.h	/^  explicit Parameter2D(Value2D x=Value2D(0,0)) : Variable2D(x) {}$/;"	f	class:simlib3::Parameter2D	access:public	signature:(Value2D x=Value2D(0,0))
Parameter2D	simlib2D.h	/^class Parameter2D : public Variable2D {$/;"	c	namespace:simlib3	inherits:Variable2D
Parameter3D	simlib3D.h	/^  explicit Parameter3D(Value3D x=Value3D(0,0,0)) : Variable3D(x) {}$/;"	f	class:simlib3::Parameter3D	access:public	signature:(Value3D x=Value3D(0,0,0))
Parameter3D	simlib3D.h	/^class Parameter3D : public Variable3D {$/;"	c	namespace:simlib3	inherits:Variable3D
ParameterChangeErr	errors.h	/^\/* 79 *\/ ParameterChangeErr,$/;"	e	enum:_ErrEnum
ParameterVector	opt-param.cc	/^ParameterVector::ParameterVector(const ParameterVector & a):n(a.n),$/;"	f	class:simlib3::ParameterVector	signature:(const ParameterVector & a)
ParameterVector	opt-param.cc	/^ParameterVector::ParameterVector(int sz, Param * a):$/;"	f	class:simlib3::ParameterVector	signature:(int sz, Param * a)
ParameterVector	optimize.h	/^    ParameterVector(const ParameterVector & a);$/;"	p	class:simlib3::ParameterVector	access:public	signature:(const ParameterVector & a)
ParameterVector	optimize.h	/^    ParameterVector(int sz, Param * a); \/\/ initialize by array$/;"	p	class:simlib3::ParameterVector	access:public	signature:(int sz, Param * a)
ParameterVector	optimize.h	/^class ParameterVector$/;"	c	namespace:simlib3
Passivate	entity.cc	/^void Entity::Passivate()$/;"	f	class:simlib3::Entity	signature:()
Passivate	process.cc	/^void Process::Passivate()$/;"	f	class:simlib3::Process	signature:()
Passivate	simlib.h	/^    virtual void Passivate();           \/\/!< deactivation$/;"	p	class:simlib3::Entity	access:public	signature:()
Passivate	simlib.h	/^  virtual void Passivate();             \/\/!< process deactivation (sleep)$/;"	p	class:simlib3::Process	access:public	signature:()
Passivate	simlib.h	/^inline void Passivate(Entity *e) { e->Passivate(); }  \/\/!< passivate entity e$/;"	f	namespace:simlib3	signature:(Entity *e)
Phase	run.cc	/^const SIMLIB_Phase_t & Phase = SIMLIB_Phase;    \/\/ read-only reference$/;"	m	namespace:simlib3	file:
Poisson	random2.cc	/^int Poisson(double lambda)$/;"	f	namespace:simlib3	signature:(double lambda)
Poisson	simlib.h	/^int    Poisson(double lambda);$/;"	p	namespace:simlib3	signature:(double lambda)
PoissonError	errors.h	/^\/* 47 *\/ PoissonError,$/;"	e	enum:_ErrEnum
PostIns	list.cc	/^void List::PostIns(Link *ent, iterator pos)$/;"	f	class:simlib3::List	signature:(Link *ent, iterator pos)
PostIns	queue.cc	/^void Queue::PostIns(Entity *ent, iterator pos)$/;"	f	class:simlib3::Queue	signature:(Entity *ent, iterator pos)
PostIns	simlib.h	/^    void PostIns (Entity *e, iterator pos);$/;"	p	class:simlib3::Queue	access:public	signature:(Entity *e, iterator pos)
PostIns	simlib.h	/^    void PostIns(Link *e, iterator pos); \/\/$/;"	p	class:simlib3::List	access:public	signature:(Link *e, iterator pos)
Pow	fun.cc	/^Input Pow(Input x, Input y)     { return new Function2(x, y, pow); }$/;"	f	namespace:simlib3	signature:(Input x, Input y)
Pow	simlib.h	/^Input Pow(Input x, Input y);    \/\/ pow(x,y)   x ** y$/;"	p	namespace:simlib3	signature:(Input x, Input y)
PredIns	list.cc	/^void List::PredIns(Link *ent, iterator pos)$/;"	f	class:simlib3::List	signature:(Link *ent, iterator pos)
PredIns	queue.cc	/^void Queue::PredIns(Entity *ent, iterator pos)$/;"	f	class:simlib3::Queue	signature:(Entity *ent, iterator pos)
PredIns	simlib.h	/^    void PredIns (Entity *e, iterator pos); \/\/ insert at position$/;"	p	class:simlib3::Queue	access:public	signature:(Entity *e, iterator pos)
PredIns	simlib.h	/^    void PredIns(Link *e, iterator pos); \/\/$/;"	p	class:simlib3::List	access:public	signature:(Link *e, iterator pos)
Prepare	numint.cc	/^bool IntegrationMethod::Prepare(void)$/;"	f	class:simlib3::IntegrationMethod	signature:(void)
Prepare	simlib.h	/^  static bool Prepare(void);  \/\/ prepare system for integration step$/;"	p	class:simlib3::IntegrationMethod	access:private	signature:(void)
PrepareStep	ni_abm4.cc	/^bool ABM4::PrepareStep(void)$/;"	f	class:simlib3::ABM4	signature:(void)
PrepareStep	ni_abm4.h	/^  virtual bool PrepareStep(void);  \/\/ prepare object for integration step$/;"	p	class:simlib3::ABM4	access:public	signature:(void)
PrepareStep	ni_fw.cc	/^bool FW::PrepareStep(void)$/;"	f	class:simlib3::FW	signature:(void)
PrepareStep	ni_fw.h	/^  virtual bool PrepareStep(void);  \/\/ prepare object for integration step$/;"	p	class:simlib3::FW	access:public	signature:(void)
PrepareStep	numint.cc	/^bool IntegrationMethod::PrepareStep(void)$/;"	f	class:simlib3::IntegrationMethod	signature:(void)
PrepareStep	numint.cc	/^bool MultiStepMethod::PrepareStep(void)$/;"	f	class:simlib3::MultiStepMethod	signature:(void)
PrepareStep	numint.cc	/^bool StatusMethod::PrepareStep(void)$/;"	f	class:simlib3::StatusMethod	signature:(void)
PrepareStep	simlib.h	/^  virtual bool PrepareStep(void);  \/\/ prepare integration step$/;"	p	class:simlib3::StatusMethod	access:public	signature:(void)
PrepareStep	simlib.h	/^  virtual bool PrepareStep(void);  \/\/ prepare object for integration step$/;"	p	class:simlib3::IntegrationMethod	access:public	signature:(void)
PrepareStep	simlib.h	/^  virtual bool PrepareStep(void);  \/\/ prepare the object for the step$/;"	p	class:simlib3::MultiStepMethod	access:public	signature:(void)
PrevINum	simlib.h	/^  size_t PrevINum;  \/\/ # of integrators in previous step$/;"	m	class:simlib3::IntegrationMethod	access:private
PrevStatusNum	simlib.h	/^  size_t PrevStatusNum;  \/\/ # of status variables in previous step$/;"	m	class:simlib3::StatusMethod	access:private
Print	opt-param.cc	/^void Param::Print() const$/;"	f	class:simlib3::Param	signature:() const
Print	opt-param.cc	/^void ParameterVector::Print() const$/;"	f	class:simlib3::ParameterVector	signature:() const
Print	optimize.h	/^    void Print() const;$/;"	p	class:simlib3::Param	access:public	signature:() const
Print	optimize.h	/^    void Print() const;$/;"	p	class:simlib3::ParameterVector	access:public	signature:() const
Print	print.cc	/^int Print(const char *fmt, ...)$/;"	f	namespace:simlib3	signature:(const char *fmt, ...)
Print	print.cc	/^int Print(const double x)$/;"	f	namespace:simlib3	signature:(const double x)
Print	print.cc	/^int Print(const double x, const double y)$/;"	f	namespace:simlib3	signature:(const double x, const double y)
Print	print.cc	/^int Print(const double x, const double y, const double z)$/;"	f	namespace:simlib3	signature:(const double x, const double y, const double z)
Print	simlib.h	/^int  Print(const char *fmt, ...);$/;"	p	namespace:simlib3	signature:(const char *fmt, ...)
Print	simlib.h	/^int  Print(const double x);$/;"	p	namespace:simlib3	signature:(const double x)
Print	simlib.h	/^int  Print(const double x, const double y);$/;"	p	namespace:simlib3	signature:(const double x, const double y)
Print	simlib.h	/^int  Print(const double x, const double y, const double z);$/;"	p	namespace:simlib3	signature:(const double x, const double y, const double z)
Print	simlib2D.cc	/^void aContiBlock2D::Print() {$/;"	f	class:simlib3::aContiBlock2D	signature:()
Print	simlib2D.h	/^  void Print() { ::Print(" %g %g ", _x, _y); }$/;"	f	class:simlib3::Value2D	access:public	signature:()
Print	simlib2D.h	/^  void Print();                      \/\/ print value$/;"	p	class:simlib3::aContiBlock2D	access:public	signature:()
Print	simlib2D.h	/^inline void Print(Value2D a) { a.Print(); }$/;"	f	namespace:simlib3	signature:(Value2D a)
Print	simlib3D.cc	/^void aContiBlock3D::Print() {$/;"	f	class:simlib3::aContiBlock3D	signature:()
Print	simlib3D.h	/^  void Print() { ::Print(" %g %g %g ", _x, _y, _z); }$/;"	f	class:simlib3::Value3D	access:public	signature:()
Print	simlib3D.h	/^  void Print();                      \/\/ print value$/;"	p	class:simlib3::aContiBlock3D	access:public	signature:()
Print	simlib3D.h	/^inline void Print(Value3D a) { a.Print(); }$/;"	f	namespace:simlib3	signature:(Value3D a)
PrintValues	opt-param.cc	/^void ParameterVector::PrintValues() const$/;"	f	class:simlib3::ParameterVector	signature:() const
PrintValues	optimize.h	/^    void PrintValues() const;$/;"	p	class:simlib3::ParameterVector	access:public	signature:() const
Priority	simlib.h	/^    Priority_t Priority;                \/\/!< priority of the entity$/;"	m	class:simlib3::Entity	access:public
Priority_t	simlib.h	/^    typedef EntityPriority_t Priority_t;$/;"	t	class:simlib3::Entity	access:public
Process	process.cc	/^Process::Process(Priority_t p) : Entity(p) {$/;"	f	class:simlib3::Process	signature:(Priority_t p)
Process	simlib.h	/^  Process(Priority_t p=DEFAULT_PRIORITY);$/;"	p	class:simlib3::Process	access:public	signature:(Priority_t p=DEFAULT_PRIORITY)
Process	simlib.h	/^  Process(const Process&);              \/\/ disable copying$/;"	p	class:simlib3::Process	access:private	signature:(const Process&)
Process	simlib.h	/^class Process : public Entity {$/;"	c	namespace:simlib3	inherits:Entity
ProcessNotInitialized	errors.h	/^\/* 21 *\/ ProcessNotInitialized,$/;"	e	enum:_ErrEnum
ProcessStatus_t	simlib.h	/^  enum ProcessStatus_t {$/;"	g	class:simlib3::Process	access:private
PtrMList	numint.cc	/^std::list<IntegrationMethod::Memory*>* IntegrationMethod::PtrMList;$/;"	m	class:simlib3::IntegrationMethod	file:
PtrMList	simlib.h	/^  static std::list<Memory*> * PtrMList;  \/\/ pointer to list being filled$/;"	m	class:simlib3::IntegrationMethod	access:private
PtrStatusMList	numint.cc	/^std::list<IntegrationMethod::Memory*>* StatusMethod::PtrStatusMList;$/;"	m	class:simlib3::StatusMethod	file:
PtrStatusMList	simlib.h	/^  static std::list<Memory*>* PtrStatusMList;  \/\/ pointer to list being filled$/;"	m	class:simlib3::StatusMethod	access:private
Q	simlib.h	/^  Queue *Q;                     \/\/!< input queue$/;"	m	class:simlib3::Store	access:public
Q	simlib.h	/^  Queue Q;                                      \/\/!< internal quqeue$/;"	m	class:simlib3::Semaphore	access:public
Q1	simlib.h	/^  Queue  *Q1;                \/\/!< input queue$/;"	m	class:simlib3::Facility	access:public
Q2	simlib.h	/^  Queue  *Q2;                \/\/!< interrupted requests queue$/;"	m	class:simlib3::Facility	access:public
Qntzr	simlib.h	/^  Qntzr(Input in, double qstep=1.0);$/;"	p	class:simlib3::Qntzr	access:public	signature:(Input in, double qstep=1.0)
Qntzr	simlib.h	/^class Qntzr : public aContiBlock1 {$/;"	c	namespace:simlib3	inherits:aContiBlock1
Qntzr	stdblock.cc	/^Qntzr::Qntzr(Input in, double p) \/\/ p = quantiz. step$/;"	f	class:simlib3::Qntzr	signature:(Input in, double p)
Quantizer	simlib.h	/^typedef Qntzr Quantizer;$/;"	t	namespace:simlib3
Queue	queue.cc	/^Queue::Queue()$/;"	f	class:simlib3::Queue	signature:()
Queue	queue.cc	/^Queue::Queue(const char *name)$/;"	f	class:simlib3::Queue	signature:(const char *name)
Queue	simlib.h	/^    Queue();$/;"	p	class:simlib3::Queue	access:public	signature:()
Queue	simlib.h	/^    Queue(const char *_name);$/;"	p	class:simlib3::Queue	access:public	signature:(const char *_name)
Queue	simlib.h	/^class Queue : public List { \/\/ don't inherit interface for now$/;"	c	namespace:simlib3	inherits:List
QueueIn	facility.cc	/^void Facility::QueueIn(Entity * e, ServicePriority_t sp)$/;"	f	class:simlib3::Facility	signature:(Entity * e, ServicePriority_t sp)
QueueIn	simlib.h	/^  virtual void QueueIn(Entity *e, ServicePriority_t sp); \/\/ go into queue Q1$/;"	p	class:simlib3::Facility	access:public	signature:(Entity *e, ServicePriority_t sp)
QueueIn	simlib.h	/^  virtual void QueueIn(Entity *e, unsigned long c);     \/\/!< insert entity into queue$/;"	p	class:simlib3::Store	access:public	signature:(Entity *e, unsigned long c)
QueueIn	store.cc	/^void Store::QueueIn(Entity *e, unsigned long c)$/;"	f	class:simlib3::Store	signature:(Entity *e, unsigned long c)
QueueIn2	facility.cc	/^void Facility::QueueIn2(Entity * e)$/;"	f	class:simlib3::Facility	signature:(Entity * e)
QueueIn2	simlib.h	/^  virtual void QueueIn2(Entity *e);              \/\/ do into Q2$/;"	p	class:simlib3::Facility	access:protected	signature:(Entity *e)
QueueLen	simlib.h	/^  unsigned QueueLen() const { return Q->size(); }$/;"	f	class:simlib3::Store	access:public	signature:() const
QueueLen	simlib.h	/^  unsigned QueueLen() const { return Q1->size(); }$/;"	f	class:simlib3::Facility	access:public	signature:() const
QueueRefError	errors.h	/^\/* 26 *\/ QueueRefError,$/;"	e	enum:_ErrEnum
RKE	ni_rke.h	/^  RKE(const char* name) :  \/\/ registrate method and name it$/;"	f	class:simlib3::RKE	access:public	signature:(const char* name)
RKE	ni_rke.h	/^class RKE : public StatusMethod {$/;"	c	namespace:simlib3	inherits:StatusMethod
RKF3	ni_rkf3.h	/^  RKF3(const char* name) :  \/\/ registrate method and name it$/;"	f	class:simlib3::RKF3	access:public	signature:(const char* name)
RKF3	ni_rkf3.h	/^class RKF3 : public SingleStepMethod {$/;"	c	namespace:simlib3	inherits:SingleStepMethod
RKF5	ni_rkf5.h	/^  RKF5(const char* name) :  \/\/ registrate method and name it$/;"	f	class:simlib3::RKF5	access:public	signature:(const char* name)
RKF5	ni_rkf5.h	/^class RKF5 : public SingleStepMethod {$/;"	c	namespace:simlib3	inherits:SingleStepMethod
RKF8	ni_rkf8.h	/^  RKF8(const char* name) :  \/\/ registrate method and name it$/;"	f	class:simlib3::RKF8	access:public	signature:(const char* name)
RKF8	ni_rkf8.h	/^class RKF8 : public SingleStepMethod {$/;"	c	namespace:simlib3	inherits:SingleStepMethod
Random	random1.cc	/^double Random()$/;"	f	namespace:simlib3	signature:()
Random	random1.cc	/^double Random();                  \/\/ base uniform generator 0-0.999999...$/;"	p	namespace:simlib3	file:	signature:()
Random	simlib.h	/^double Random();$/;"	p	namespace:simlib3	signature:()
RandomSeed	random1.cc	/^void   RandomSeed(long seed);     \/\/ initialize random number seed$/;"	p	namespace:simlib3	file:	signature:(long seed)
RandomSeed	random1.cc	/^void RandomSeed(long seed)$/;"	f	namespace:simlib3	signature:(long seed)
RandomSeed	simlib.h	/^void   RandomSeed(long seed);$/;"	p	namespace:simlib3	signature:(long seed)
Range	optimize.h	/^    double Range() const { return max - min; }$/;"	f	class:simlib3::Param	access:public	signature:() const
Rayle	random2.cc	/^double Rayle(double delta)$/;"	f	namespace:simlib3	signature:(double delta)
Rayle	simlib.h	/^double Rayle(double delta);$/;"	p	namespace:simlib3	signature:(double delta)
Record	simlib.h	/^  virtual void Record(double x) = 0;        \/\/!< record value$/;"	p	class:simlib3::aStat	access:public	signature:(double x)
Register	delay.cc	/^    static void Register(Delay *p) {    \/\/!< must be called by Delay ctr$/;"	f	class:simlib3::SIMLIB_Delay	access:public	signature:(Delay *p)
Register	zdelay.cc	/^    static void Register(ZDelayTimer *p) { \/\/ called from ZDelayTimer constructor$/;"	f	class:simlib3::SIMLIB_ZDelayTimer	access:public	signature:(ZDelayTimer *p)
Register	zdelay.cc	/^void ZDelayTimer::Register(ZDelay*p)$/;"	f	class:simlib3::ZDelayTimer	signature:(ZDelay*p)
Register	zdelay.h	/^    void Register(ZDelay*);   \/\/ insert into container$/;"	p	class:simlib3::ZDelayTimer	access:private	signature:(ZDelay*)
RegisterReference	simlib.h	877;"	d
RegulaFalsi	simlib.h	/^  RegulaFalsi(Input i, double eps, unsigned long max_it,$/;"	f	class:simlib3::RegulaFalsi	access:public	signature:(Input i, double eps, unsigned long max_it, double t_min, double t_max)
RegulaFalsi	simlib.h	/^class RegulaFalsi : public AlgLoop {$/;"	c	namespace:simlib3	inherits:AlgLoop
RelativeError	intg.cc	/^const double &RelativeError=SIMLIB_RelativeError; \/\/!< max. rel. error$/;"	m	namespace:simlib3	file:
Relay	simlib.h	/^  Relay(Input i, double p1, double p2, double p3, double p4,$/;"	p	class:simlib3::Relay	access:public	signature:(Input i, double p1, double p2, double p3, double p4, double y1, double y2)
Relay	simlib.h	/^class Relay : public Status {   \/\/ general relay block$/;"	c	namespace:simlib3	inherits:Status
Relay	stdblock.cc	/^Relay::Relay(Input i, double _p1, double _p2, double _p3, double _p4, double _y1, double _y2)$/;"	f	class:simlib3::Relay	signature:(Input i, double _p1, double _p2, double _p3, double _p4, double _y1, double _y2)
Release	facility.cc	/^void Facility::Release(Entity * e)$/;"	f	class:simlib3::Facility	signature:(Entity * e)
Release	process.cc	/^void Process::Release(Facility & f)$/;"	f	class:simlib3::Process	signature:(Facility & f)
Release	simlib.h	/^  virtual void Release(Entity *e);$/;"	p	class:simlib3::Facility	access:public	signature:(Entity *e)
Release	simlib.h	/^  void Release(Facility &f);                        \/\/!< release facility$/;"	p	class:simlib3::Process	access:public	signature:(Facility &f)
ReleaseError	errors.h	/^\/* 36 *\/ ReleaseError,$/;"	e	enum:_ErrEnum
ReleaseNotSeized	errors.h	/^\/* 37 *\/ ReleaseNotSeized,$/;"	e	enum:_ErrEnum
Remove	waitunti.cc	/^    static void Remove(Process *p) { \/\/ find and remove p$/;"	f	class:simlib3::WaitUntilList	access:public	signature:(Process *p)
RemoveName	name.cc	/^void RemoveName(SimObject & o)$/;"	f	namespace:simlib3	signature:(SimObject & o)
RemoveName	name.cc	/^void RemoveName(SimObject * o)$/;"	f	namespace:simlib3	signature:(SimObject * o)
RemoveName	simlib.h	/^void RemoveName(SimObject &o);$/;"	p	namespace:simlib3	signature:(SimObject &o)
RemoveName	simlib.h	/^void RemoveName(SimObject *o);$/;"	p	namespace:simlib3	signature:(SimObject *o)
Resize	calendar.cc	/^    void Resize(int grow=0);                \/\/ grow\/shrink operation$/;"	p	class:simlib3::CalendarQueue	file:	access:private	signature:(int grow=0)
Resize	calendar.cc	/^void CalendarQueue::Resize(int grow)  \/\/ TODO: is it better to use target size?$/;"	f	class:simlib3::CalendarQueue	signature:(int grow)
Resize	numint.cc	/^void IntegrationMethod::Memory::Resize(size_t cs)$/;"	f	class:simlib3::IntegrationMethod::Memory	signature:(size_t cs)
Resize	numint.cc	/^void IntegrationMethod::Resize(size_t size)$/;"	f	class:simlib3::IntegrationMethod	signature:(size_t size)
Resize	simlib.h	/^      virtual void Resize(size_t cs); \/\/ change size, content will be undefined!$/;"	p	class:simlib3::IntegrationMethod::Memory	access:public	signature:(size_t cs)
Resize	simlib.h	/^  virtual void Resize(size_t size);  \/\/ resize all memories to given size$/;"	p	class:simlib3::IntegrationMethod	access:public	signature:(size_t size)
Restore	intg.cc	/^void Status::Restore()$/;"	f	class:simlib3::Status	signature:()
Restore	simlib.h	/^  void Restore();                      \/\/ restore saved status$/;"	p	class:simlib3::Status	access:public	signature:()
Restore	simlib.h	/^  void Restore(void) { dd=ddl; ss=ssl; }  \/\/ restore saved status$/;"	f	class:simlib3::Integrator	access:public	signature:(void)
RestoreState	numint.cc	/^void StatusMethod::RestoreState(double dthlf, Memory& di, Memory& si,$/;"	f	class:simlib3::StatusMethod	signature:(double dthlf, Memory& di, Memory& si, StatusMemory& xi)
RestoreState	simlib.h	/^  static void RestoreState(double dthlf, Memory& di,$/;"	p	class:simlib3::StatusMethod	access:protected	signature:(double dthlf, Memory& di, Memory& si, StatusMemory& xi)
Rline	simlib.h	/^    Rline(const Rline&); \/\/ ## disable$/;"	p	class:simlib3::Rline	access:private	signature:(const Rline&)
Rline	simlib.h	/^  Rline(Input in, int num, double *X, double *Y);$/;"	p	class:simlib3::Rline	access:public	signature:(Input in, int num, double *X, double *Y)
Rline	simlib.h	/^class Rline : public aContiBlock1 {$/;"	c	namespace:simlib3	inherits:aContiBlock1
Rline	stdblock.cc	/^Rline::Rline(Input in, int num, double *X, double *Y)$/;"	f	class:simlib3::Rline	signature:(Input in, int num, double *X, double *Y)
RlineErr1	errors.h	/^\/* 75 *\/ RlineErr1,$/;"	e	enum:_ErrEnum
RlineErr2	errors.h	/^\/* 76 *\/ RlineErr2,$/;"	e	enum:_ErrEnum
Run	run.cc	/^void Run() {$/;"	f	namespace:simlib3	signature:()
Run	simlib.h	/^void Run();$/;"	p	namespace:simlib3	signature:()
RunUseError	errors.h	/^\/* 7 *\/ RunUseError,$/;"	e	enum:_ErrEnum
S	_test_.cc	/^Sampler S(Sample, 1);  \/\/ periodic event$/;"	p	file:	signature:(Sample, 1)
SFunctionUseError	errors.h	/^\/* 12 *\/ SFunctionUseError,$/;"	e	enum:_ErrEnum
SIGNBIT	random1.cc	/^const myint32 SIGNBIT    = 0x80000000UL;$/;"	m	namespace:simlib3	file:
SIMLIB_AbsoluteError	intg.cc	/^double SIMLIB_AbsoluteError=0;       \/\/!< absolute error$/;"	m	namespace:simlib3	file:
SIMLIB_COMPILER	simlib.h	68;"	d
SIMLIB_COMPILER	simlib.h	74;"	d
SIMLIB_COMPILER	simlib.h	76;"	d
SIMLIB_COMPILER	simlib.h	82;"	d
SIMLIB_COPYRIGHT	simlib.h	11;"	d
SIMLIB_ConditionFlag	cond.cc	/^bool SIMLIB_ConditionFlag = false;       \/\/ condition vector changed$/;"	m	namespace:simlib3	file:
SIMLIB_ContinueInit	internal.h	/^void SIMLIB_ContinueInit();          \/\/ initialize variables$/;"	p	namespace:simlib3	signature:()
SIMLIB_ContinueInit	intg.cc	/^void SIMLIB_ContinueInit()$/;"	f	namespace:simlib3	signature:()
SIMLIB_ContractStep	intg.cc	/^double  SIMLIB_ContractStep = SIMLIB_MAXTIME;    \/\/!< requested step size$/;"	m	namespace:simlib3	file:
SIMLIB_ContractStepFlag	intg.cc	/^bool SIMLIB_ContractStepFlag = false;     \/\/!< requests shorter step$/;"	m	namespace:simlib3	file:
SIMLIB_Current	run.cc	/^Entity *SIMLIB_Current = NULL;$/;"	m	namespace:simlib3	file:
SIMLIB_DEBUG	_test_.cc	4;"	d	file:
SIMLIB_Delay	delay.cc	/^class SIMLIB_Delay {$/;"	c	namespace:simlib3	file:
SIMLIB_DelayBuffer	delay.cc	/^    SIMLIB_DelayBuffer(): buf(), last_insert(-2,0) { \/*empty*\/ }$/;"	f	class:simlib3::SIMLIB_DelayBuffer	access:public	signature:()
SIMLIB_DelayBuffer	delay.cc	/^class SIMLIB_DelayBuffer : public Delay::Buffer { \/\/ memory for delayed signal$/;"	c	namespace:simlib3	file:	inherits:Delay::Buffer
SIMLIB_DeltaTime	intg.cc	/^double SIMLIB_DeltaTime;             \/\/!< Time-SIMLIB_StepStartTime$/;"	m	namespace:simlib3	file:
SIMLIB_DoActions	internal.h	/^void SIMLIB_DoActions();             \/\/ dispatch events and processes$/;"	p	namespace:simlib3	signature:()
SIMLIB_DoActions	run.cc	/^void SIMLIB_DoActions()$/;"	f	namespace:simlib3	signature:()
SIMLIB_DoActions	simlib.h	/^    friend void SIMLIB_DoActions();     \/\/ internal function - event dispatcher$/;"	p	class:simlib3::Entity	access:friend	signature:()
SIMLIB_DoConditions	cond.cc	/^void SIMLIB_DoConditions()$/;"	f	namespace:simlib3	signature:()
SIMLIB_DoConditions	internal.h	/^void SIMLIB_DoConditions();          \/\/ perform state events$/;"	p	namespace:simlib3	signature:()
SIMLIB_Dynamic	continuous.cc	/^void SIMLIB_Dynamic() \/\/ called each step$/;"	f	namespace:simlib3	signature:()
SIMLIB_Dynamic	internal.h	/^void SIMLIB_Dynamic();               \/\/ optimize!$/;"	p	namespace:simlib3	signature:()
SIMLIB_DynamicFlag	intg.cc	/^bool SIMLIB_DynamicFlag = false;          \/\/!< in dynamic section$/;"	m	namespace:simlib3	file:
SIMLIB_ERRNO	intg.cc	/^int SIMLIB_ERRNO=0;$/;"	m	namespace:simlib3	file:
SIMLIB_EndTime	run.cc	/^double SIMLIB_EndTime;         \/\/ time of simulation end$/;"	m	namespace:simlib3	file:
SIMLIB_Entity_Count	entity.cc	/^static unsigned long SIMLIB_Entity_Count = 0L; \/\/ # of entities in model$/;"	m	namespace:simlib3	file:
SIMLIB_IMPLEMENTATION	algloop.cc	/^SIMLIB_IMPLEMENTATION;$/;"	m	namespace:simlib3	file:
SIMLIB_IMPLEMENTATION	atexit.cc	/^SIMLIB_IMPLEMENTATION;$/;"	m	namespace:simlib3	file:
SIMLIB_IMPLEMENTATION	barrier.cc	/^SIMLIB_IMPLEMENTATION;$/;"	m	namespace:simlib3	file:
SIMLIB_IMPLEMENTATION	calendar.cc	/^SIMLIB_IMPLEMENTATION;$/;"	m	namespace:simlib3	file:
SIMLIB_IMPLEMENTATION	cond.cc	/^SIMLIB_IMPLEMENTATION;$/;"	m	namespace:simlib3	file:
SIMLIB_IMPLEMENTATION	continuous.cc	/^SIMLIB_IMPLEMENTATION;$/;"	m	namespace:simlib3	file:
SIMLIB_IMPLEMENTATION	debug.cc	/^SIMLIB_IMPLEMENTATION;$/;"	m	namespace:simlib3	file:
SIMLIB_IMPLEMENTATION	delay.cc	/^SIMLIB_IMPLEMENTATION;$/;"	m	namespace:simlib3	file:
SIMLIB_IMPLEMENTATION	entity.cc	/^SIMLIB_IMPLEMENTATION;$/;"	m	namespace:simlib3	file:
SIMLIB_IMPLEMENTATION	error.cc	/^SIMLIB_IMPLEMENTATION;$/;"	m	namespace:simlib3	file:
SIMLIB_IMPLEMENTATION	event.cc	/^SIMLIB_IMPLEMENTATION;$/;"	m	namespace:simlib3	file:
SIMLIB_IMPLEMENTATION	facility.cc	/^SIMLIB_IMPLEMENTATION;$/;"	m	namespace:simlib3	file:
SIMLIB_IMPLEMENTATION	fun.cc	/^SIMLIB_IMPLEMENTATION;$/;"	m	namespace:simlib3	file:
SIMLIB_IMPLEMENTATION	graph.cc	/^SIMLIB_IMPLEMENTATION;$/;"	m	namespace:simlib3	file:
SIMLIB_IMPLEMENTATION	histo.cc	/^SIMLIB_IMPLEMENTATION;$/;"	m	namespace:simlib3	file:
SIMLIB_IMPLEMENTATION	internal.h	119;"	d
SIMLIB_IMPLEMENTATION	intg.cc	/^SIMLIB_IMPLEMENTATION;$/;"	m	namespace:simlib3	file:
SIMLIB_IMPLEMENTATION	link.cc	/^SIMLIB_IMPLEMENTATION;$/;"	m	namespace:simlib3	file:
SIMLIB_IMPLEMENTATION	list.cc	/^SIMLIB_IMPLEMENTATION;$/;"	m	namespace:simlib3	file:
SIMLIB_IMPLEMENTATION	name.cc	/^SIMLIB_IMPLEMENTATION;$/;"	m	namespace:simlib3	file:
SIMLIB_IMPLEMENTATION	ni_abm4.cc	/^SIMLIB_IMPLEMENTATION;$/;"	m	namespace:simlib3	file:
SIMLIB_IMPLEMENTATION	ni_euler.cc	/^SIMLIB_IMPLEMENTATION;$/;"	m	namespace:simlib3	file:
SIMLIB_IMPLEMENTATION	ni_fw.cc	/^SIMLIB_IMPLEMENTATION;$/;"	m	namespace:simlib3	file:
SIMLIB_IMPLEMENTATION	ni_rke.cc	/^SIMLIB_IMPLEMENTATION;$/;"	m	namespace:simlib3	file:
SIMLIB_IMPLEMENTATION	ni_rkf3.cc	/^SIMLIB_IMPLEMENTATION;$/;"	m	namespace:simlib3	file:
SIMLIB_IMPLEMENTATION	ni_rkf5.cc	/^SIMLIB_IMPLEMENTATION;$/;"	m	namespace:simlib3	file:
SIMLIB_IMPLEMENTATION	ni_rkf8.cc	/^SIMLIB_IMPLEMENTATION;$/;"	m	namespace:simlib3	file:
SIMLIB_IMPLEMENTATION	numint.cc	/^SIMLIB_IMPLEMENTATION;$/;"	m	namespace:simlib3	file:
SIMLIB_IMPLEMENTATION	object.cc	/^SIMLIB_IMPLEMENTATION;$/;"	m	namespace:simlib3	file:
SIMLIB_IMPLEMENTATION	opt-hooke.cc	/^SIMLIB_IMPLEMENTATION;$/;"	m	namespace:simlib3	file:
SIMLIB_IMPLEMENTATION	opt-param.cc	/^SIMLIB_IMPLEMENTATION;$/;"	m	namespace:simlib3	file:
SIMLIB_IMPLEMENTATION	opt-simann.cc	/^SIMLIB_IMPLEMENTATION;$/;"	m	namespace:simlib3	file:
SIMLIB_IMPLEMENTATION	output1.cc	/^SIMLIB_IMPLEMENTATION;$/;"	m	namespace:simlib3	file:
SIMLIB_IMPLEMENTATION	output2.cc	/^SIMLIB_IMPLEMENTATION;$/;"	m	namespace:simlib3	file:
SIMLIB_IMPLEMENTATION	print.cc	/^SIMLIB_IMPLEMENTATION;$/;"	m	namespace:simlib3	file:
SIMLIB_IMPLEMENTATION	process.cc	/^SIMLIB_IMPLEMENTATION;$/;"	m	namespace:simlib3	file:
SIMLIB_IMPLEMENTATION	queue.cc	/^SIMLIB_IMPLEMENTATION;$/;"	m	namespace:simlib3	file:
SIMLIB_IMPLEMENTATION	random1.cc	/^SIMLIB_IMPLEMENTATION;$/;"	m	namespace:simlib3	file:
SIMLIB_IMPLEMENTATION	random2.cc	/^SIMLIB_IMPLEMENTATION;$/;"	m	namespace:simlib3	file:
SIMLIB_IMPLEMENTATION	run.cc	/^SIMLIB_IMPLEMENTATION;$/;"	m	namespace:simlib3	file:
SIMLIB_IMPLEMENTATION	sampler.cc	/^SIMLIB_IMPLEMENTATION;$/;"	m	namespace:simlib3	file:
SIMLIB_IMPLEMENTATION	semaphor.cc	/^SIMLIB_IMPLEMENTATION;$/;"	m	namespace:simlib3	file:
SIMLIB_IMPLEMENTATION	simlib2D.cc	/^SIMLIB_IMPLEMENTATION;$/;"	m	namespace:simlib3	file:
SIMLIB_IMPLEMENTATION	simlib3D.cc	/^SIMLIB_IMPLEMENTATION;$/;"	m	namespace:simlib3	file:
SIMLIB_IMPLEMENTATION	stat.cc	/^SIMLIB_IMPLEMENTATION;$/;"	m	namespace:simlib3	file:
SIMLIB_IMPLEMENTATION	stdblock.cc	/^SIMLIB_IMPLEMENTATION;$/;"	m	namespace:simlib3	file:
SIMLIB_IMPLEMENTATION	store.cc	/^SIMLIB_IMPLEMENTATION;$/;"	m	namespace:simlib3	file:
SIMLIB_IMPLEMENTATION	tstat.cc	/^SIMLIB_IMPLEMENTATION;$/;"	m	namespace:simlib3	file:
SIMLIB_IMPLEMENTATION	version.cc	/^SIMLIB_IMPLEMENTATION;$/;"	m	namespace:simlib3	file:
SIMLIB_IMPLEMENTATION	waitunti.cc	/^SIMLIB_IMPLEMENTATION;$/;"	m	namespace:simlib3	file:
SIMLIB_IMPLEMENTATION	zdelay.cc	/^SIMLIB_IMPLEMENTATION;$/;"	m	namespace:simlib3	file:
SIMLIB_Init	run.cc	/^void SIMLIB_Init(double T0, double T1, unsigned version)$/;"	f	namespace:simlib3	signature:(double T0, double T1, unsigned version)
SIMLIB_MAXTIME	simlib.h	/^const double SIMLIB_MAXTIME = 1.0e30; \/\/!< maximum time (1e30 works for float, too)$/;"	m	namespace:simlib3
SIMLIB_MINTIME	simlib.h	/^const double SIMLIB_MINTIME = 0.0;    \/\/!< minimal time value$/;"	m	namespace:simlib3
SIMLIB_MaxStep	intg.cc	/^double SIMLIB_MaxStep=1;             \/\/!< max. step$/;"	m	namespace:simlib3	file:
SIMLIB_MinStep	intg.cc	/^double SIMLIB_MinStep=1e-10;         \/\/!< minimal step$/;"	m	namespace:simlib3	file:
SIMLIB_NextTime	run.cc	/^double SIMLIB_NextTime;        \/\/ next-event time$/;"	m	namespace:simlib3	file:
SIMLIB_OptStep	intg.cc	/^double SIMLIB_OptStep;               \/\/!< optimal step$/;"	m	namespace:simlib3	file:
SIMLIB_Phase	run.cc	/^SIMLIB_Phase_t SIMLIB_Phase = START;$/;"	m	namespace:simlib3	file:
SIMLIB_Phase_t	internal.h	/^enum SIMLIB_Phase_t {$/;"	g	namespace:simlib3
SIMLIB_RandomBase	random1.cc	/^double SIMLIB_RandomBase()  \/\/ range <0..1)$/;"	f	namespace:simlib3	signature:()
SIMLIB_RandomBasePtr	random1.cc	/^static double (*SIMLIB_RandomBasePtr)() = SIMLIB_RandomBase;$/;"	m	namespace:simlib3	file:
SIMLIB_RandomSeed	random1.cc	/^static myint32 SIMLIB_RandomSeed = INICONST ;$/;"	m	namespace:simlib3	file:
SIMLIB_RelativeError	intg.cc	/^double SIMLIB_RelativeError=0.001;   \/\/!< relative error$/;"	m	namespace:simlib3	file:
SIMLIB_ResetStatus	intg.cc	/^bool SIMLIB_ResetStatus = false;$/;"	m	namespace:simlib3	file:
SIMLIB_SYSTEM	simlib.h	67;"	d
SIMLIB_SYSTEM	simlib.h	72;"	d
SIMLIB_SYSTEM	simlib.h	81;"	d
SIMLIB_StartTime	run.cc	/^double SIMLIB_StartTime;       \/\/ time of simulation start$/;"	m	namespace:simlib3	file:
SIMLIB_StepSize	intg.cc	/^double SIMLIB_StepSize;              \/\/!< actual step$/;"	m	namespace:simlib3	file:
SIMLIB_StepStartTime	intg.cc	/^double SIMLIB_StepStartTime;         \/\/!< last step time$/;"	m	namespace:simlib3	file:
SIMLIB_Time	run.cc	/^double SIMLIB_Time;            \/\/ simulation time$/;"	m	namespace:simlib3	file:
SIMLIB_VERSION	simlib.h	9;"	d
SIMLIB_WUClear	internal.h	/^void SIMLIB_WUClear();               \/\/ clear WUList$/;"	p	namespace:simlib3	signature:()
SIMLIB_WUClear	run.cc	/^void SIMLIB_WUClear() \/\/ should be removed -- ise CALL_HOOK instead$/;"	f	namespace:simlib3	signature:()
SIMLIB_ZDelayTimer	zdelay.cc	/^class SIMLIB_ZDelayTimer {$/;"	c	namespace:simlib3	file:
SIMLIB_atexit	atexit.cc	/^void SIMLIB_atexit(SIMLIB_atexit_function_t p) {$/;"	f	namespace:simlib3	signature:(SIMLIB_atexit_function_t p)
SIMLIB_atexit	internal.h	/^void SIMLIB_atexit(SIMLIB_atexit_function_t p);$/;"	p	namespace:simlib3	signature:(SIMLIB_atexit_function_t p)
SIMLIB_atexit_call	atexit.cc	/^static void SIMLIB_atexit_call() {$/;"	f	namespace:simlib3	signature:()
SIMLIB_atexit_function_t	internal.h	/^typedef void (*SIMLIB_atexit_function_t)();$/;"	t	namespace:simlib3
SIMLIB_create_tmp_name	internal.h	/^const char *SIMLIB_create_tmp_name(const char *fmt, ...);$/;"	p	namespace:simlib3	signature:(const char *fmt, ...)
SIMLIB_create_tmp_name	name.cc	/^const char *SIMLIB_create_tmp_name(const char *fmt, ...)$/;"	f	namespace:simlib3	signature:(const char *fmt, ...)
SIMLIB_debug_flag	debug.cc	/^unsigned long SIMLIB_debug_flag = 0UL; \/\/ default = no debugging$/;"	m	namespace:simlib3	file:
SIMLIB_error	error.cc	/^void SIMLIB_error(const char *fmt, ... )$/;"	f	namespace:simlib3	signature:(const char *fmt, ... )
SIMLIB_error	error.cc	/^void SIMLIB_error(const char*filename, const int linenum)$/;"	f	namespace:simlib3	signature:(const char*filename, const int linenum)
SIMLIB_error	error.cc	/^void SIMLIB_error(const enum _ErrEnum N)$/;"	f	namespace:simlib3	signature:(const enum _ErrEnum N)
SIMLIB_error	internal.h	/^void SIMLIB_error(const char *file, const int line);$/;"	p	namespace:simlib3	signature:(const char *file, const int line)
SIMLIB_error	internal.h	/^void SIMLIB_error(const char *fmt, ... );$/;"	p	namespace:simlib3	signature:(const char *fmt, ... )
SIMLIB_error	internal.h	/^void SIMLIB_error(const enum _ErrEnum ErrMsgNum);$/;"	p	namespace:simlib3	signature:(const enum _ErrEnum ErrMsgNum)
SIMLIB_experiment_no	run.cc	/^unsigned long SIMLIB_experiment_no = 0;$/;"	m	namespace:simlib3	file:
SIMLIB_internal_error	internal.h	151;"	d
SIMLIB_module	atexit.cc	/^SIMLIB_module::SIMLIB_module():$/;"	f	class:simlib3::SIMLIB_module	signature:()
SIMLIB_module	internal.h	/^  SIMLIB_module();$/;"	p	class:simlib3::SIMLIB_module	access:public	signature:()
SIMLIB_module	internal.h	/^  SIMLIB_module(const SIMLIB_module&); \/\/ disable copy-ctr$/;"	p	class:simlib3::SIMLIB_module	access:private	signature:(const SIMLIB_module&)
SIMLIB_module	internal.h	/^class SIMLIB_module { \/\/ internal class for SIMLIB cleanup (atexit)$/;"	c	namespace:simlib3
SIMLIB_module_id	internal.h	/^static SIMLIB_module SIMLIB_module_id;$/;"	m	namespace:simlib3
SIMLIB_old_debug_flags	simlib.h	/^static unsigned long SIMLIB_old_debug_flags = Debug(SIMLIB_DEBUG);$/;"	m	namespace:simlib3
SIMLIB_run_statistics	run.cc	/^static SIMLIB_statistics_t SIMLIB_run_statistics;$/;"	m	namespace:simlib3	file:
SIMLIB_statistics	run.cc	/^const SIMLIB_statistics_t &SIMLIB_statistics = SIMLIB_run_statistics;$/;"	m	namespace:simlib3	file:
SIMLIB_statistics_t	run.cc	/^SIMLIB_statistics_t::SIMLIB_statistics_t() {$/;"	f	class:simlib3::SIMLIB_statistics_t	signature:()
SIMLIB_statistics_t	simlib.h	/^  SIMLIB_statistics_t();$/;"	p	struct:simlib3::SIMLIB_statistics_t	access:public	signature:()
SIMLIB_statistics_t	simlib.h	/^struct SIMLIB_statistics_t {$/;"	s	namespace:simlib3
SIMLIB_version	version.cc	/^const unsigned SIMLIB_version = __SIMLIB__;  \/\/!< library version$/;"	m	namespace:simlib3	file:
SIMLIB_version_string	simlib.h	/^const char *SIMLIB_version_string();    \/\/ get SIMLIB version string$/;"	p	namespace:simlib3	signature:()
SIMLIB_version_string	version.cc	/^const char *SIMLIB_version_string() {$/;"	f	namespace:simlib3	signature:()
SIMLIB_warning	error.cc	/^void SIMLIB_warning( const enum _ErrEnum N )$/;"	f	namespace:simlib3	signature:( const enum _ErrEnum N )
SIMLIB_warning	error.cc	/^void SIMLIB_warning(const char *fmt, ... )$/;"	f	namespace:simlib3	signature:(const char *fmt, ... )
SIMLIB_warning	internal.h	/^void SIMLIB_warning(const char *fmt, ... );$/;"	p	namespace:simlib3	signature:(const char *fmt, ... )
SIMLIB_warning	internal.h	/^void SIMLIB_warning(const enum _ErrEnum ErrMsgNum);$/;"	p	namespace:simlib3	signature:(const enum _ErrEnum ErrMsgNum)
SIMULATION	internal.h	/^    SIMULATION,     \/\/ inside Run() call$/;"	e	enum:simlib3::SIMLIB_Phase_t
SQS	internal.h	/^namespace SQS {$/;"	n	namespace:simlib3
STACK_RESERVED	process.cc	412;"	d	file:
START	internal.h	/^    START,          \/\/ before first Init() call$/;"	e	enum:simlib3::SIMLIB_Phase_t
START_T	calendar.cc	/^inline void START_T() {$/;"	f	namespace:__anon4	signature:()
STOP_T	calendar.cc	/^inline double STOP_T() {$/;"	f	namespace:__anon4	signature:()
Sample	_test_.cc	/^void Sample() {$/;"	f	signature:()
Sample	delay.cc	/^void Delay::Sample()$/;"	f	class:simlib3::Delay	signature:()
Sample	delay.h	/^    void Sample();              \/\/!< sample input (called automatically)$/;"	p	class:simlib3::Delay	access:public	signature:()
Sample	graph.cc	/^void Graph::Sample()$/;"	f	class:simlib3::Graph	signature:()
Sample	sampler.cc	/^void Sampler::Sample()$/;"	f	class:simlib3::Sampler	signature:()
Sample	simlib.h	/^    void Sample();                  \/\/!< performs sample (function call)$/;"	p	class:simlib3::Sampler	access:public	signature:()
SampleAll	delay.cc	/^    static void SampleAll() {   \/\/ called each continuous step (and more)$/;"	f	class:simlib3::SIMLIB_Delay	file:	access:private	signature:()
SampleDelays	run.cc	/^void SampleDelays() { \/\/ used at step-wise changes !!!###$/;"	f	namespace:simlib3	signature:()
SampleIn	zdelay.cc	/^void ZDelay::SampleIn()$/;"	f	class:simlib3::ZDelay	signature:()
SampleIn	zdelay.h	/^    virtual void SampleIn();    \/\/ sample input (called automatically by ZDelayTimer)$/;"	p	class:simlib3::ZDelay	access:protected	signature:()
SampleOut	zdelay.cc	/^void ZDelay::SampleOut()$/;"	f	class:simlib3::ZDelay	signature:()
SampleOut	zdelay.h	/^    virtual void SampleOut();   \/\/ sample output (called automatically)$/;"	p	class:simlib3::ZDelay	access:protected	signature:()
Sampler	sampler.cc	/^Sampler::Sampler(void(*pf)(), double dt) :$/;"	f	class:simlib3::Sampler	signature:(void(*pf)(), double dt)
Sampler	simlib.h	/^    Sampler(const Sampler&);            \/\/## disable$/;"	p	class:simlib3::Sampler	access:private	signature:(const Sampler&)
Sampler	simlib.h	/^    Sampler(void (*pf)(), double dt=0.0);$/;"	p	class:simlib3::Sampler	access:public	signature:(void (*pf)(), double dt=0.0)
Sampler	simlib.h	/^class Sampler: public Event {$/;"	c	namespace:simlib3	inherits:Event
Save	simlib.h	/^  void Save() { stl = st; }            \/\/ save status$/;"	f	class:simlib3::Status	access:public	signature:()
Save	simlib.h	/^  void Save(void) { ddl=dd; ssl=ss; }     \/\/ save status$/;"	f	class:simlib3::Integrator	access:public	signature:(void)
ScalarProduct	simlib2D.cc	/^Input ScalarProduct(Input2D x, Input2D y) { return new _ScalarProduct2D(x,y); }$/;"	f	namespace:simlib3	signature:(Input2D x, Input2D y)
ScalarProduct	simlib2D.h	/^Input ScalarProduct(Input2D x, Input2D y);$/;"	p	namespace:simlib3	signature:(Input2D x, Input2D y)
ScalarProduct	simlib3D.cc	/^Input ScalarProduct(Input3D x, Input3D y) { return new _ScalarProduct3D(x,y); }$/;"	f	namespace:simlib3	signature:(Input3D x, Input3D y)
ScalarProduct	simlib3D.h	/^Input   ScalarProduct(Input3D x, Input3D y);$/;"	p	namespace:simlib3	signature:(Input3D x, Input3D y)
ScheduleAt	calendar.cc	/^    virtual void     ScheduleAt(Entity *e, double t) = 0;$/;"	p	class:simlib3::Calendar	file:	access:public	signature:(Entity *e, double t)
ScheduleAt	calendar.cc	/^    virtual void ScheduleAt(Entity *p, double t);$/;"	p	class:simlib3::CalendarList	file:	access:public	signature:(Entity *p, double t)
ScheduleAt	calendar.cc	/^    virtual void ScheduleAt(Entity *p, double t);$/;"	p	class:simlib3::CalendarQueue	file:	access:public	signature:(Entity *p, double t)
ScheduleAt	calendar.cc	/^void CalendarList::ScheduleAt(Entity *e, double t)$/;"	f	class:simlib3::CalendarList	signature:(Entity *e, double t)
ScheduleAt	calendar.cc	/^void CalendarQueue::ScheduleAt(Entity *e, double t)$/;"	f	class:simlib3::CalendarQueue	signature:(Entity *e, double t)
ScheduleAt	calendar.cc	/^void SQS::ScheduleAt(Entity *e, double t) { \/\/ used by scheduling operations$/;"	f	class:simlib3::SQS	signature:(Entity *e, double t)
ScheduleAt	internal.h	/^    void ScheduleAt(Entity *e, double t);\/\/ time t$/;"	p	namespace:simlib3::SQS	signature:(Entity *e, double t)
SchedulingBeforeTime	errors.h	/^\/* 19 *\/ SchedulingBeforeTime,$/;"	e	enum:_ErrEnum
SearchMethod	numint.cc	/^IntegrationMethod* IntegrationMethod::SearchMethod(const char* name)$/;"	f	class:simlib3::IntegrationMethod	signature:(const char* name)
SearchMethod	simlib.h	/^  static IntegrationMethod* SearchMethod(const char* name);  \/\/ find method$/;"	p	class:simlib3::IntegrationMethod	access:protected	signature:(const char* name)
SearchMinTime	calendar.cc	/^    void SearchMinTime(double starttime);   \/\/ search for new minimum$/;"	p	class:simlib3::CalendarQueue	file:	access:private	signature:(double starttime)
SearchMinTime	calendar.cc	/^void CalendarQueue::SearchMinTime (double starttime)$/;"	f	class:simlib3::CalendarQueue	signature:(double starttime)
Seize	facility.cc	/^void Facility::Seize(Entity * e, ServicePriority_t sp)$/;"	f	class:simlib3::Facility	signature:(Entity * e, ServicePriority_t sp)
Seize	process.cc	/^void Process::Seize(Facility & f, ServicePriority_t sp \/* = 0 *\/ )$/;"	f	class:simlib3::Process	signature:(Facility & f, ServicePriority_t sp )
Seize	simlib.h	/^  virtual void Seize(Entity *e, ServicePriority_t sp=DEFAULT_PRIORITY);$/;"	p	class:simlib3::Facility	access:public	signature:(Entity *e, ServicePriority_t sp=DEFAULT_PRIORITY)
Seize	simlib.h	/^  void Seize(Facility &f, ServicePriority_t sp=0);  \/\/!< seize facility$/;"	p	class:simlib3::Process	access:public	signature:(Facility &f, ServicePriority_t sp=0)
Semaphore	semaphor.cc	/^Semaphore::Semaphore()$/;"	f	class:simlib3::Semaphore	signature:()
Semaphore	semaphor.cc	/^Semaphore::Semaphore(const char *name)$/;"	f	class:simlib3::Semaphore	signature:(const char *name)
Semaphore	simlib.h	/^  Semaphore();                                  \/\/ constructor$/;"	p	class:simlib3::Semaphore	access:public	signature:()
Semaphore	simlib.h	/^  Semaphore(const char *_name);                 \/\/ with associated name$/;"	p	class:simlib3::Semaphore	access:public	signature:(const char *_name)
Semaphore	simlib.h	/^class Semaphore : public SimObject {$/;"	c	namespace:simlib3	inherits:SimObject
SemaphoreError	errors.h	/^\/* 59 *\/ SemaphoreError,$/;"	e	enum:_ErrEnum
ServicePriority_t	simlib.h	/^typedef unsigned char ServicePriority_t;$/;"	t	namespace:simlib3
Set	algloop.cc	/^void AlgLoop::Set(double eps, unsigned long max_it,$/;"	f	class:simlib3::AlgLoop	signature:(double eps, unsigned long max_it, double t_min, double t_max)
Set	algloop.cc	/^void AlgLoop::Set(double eps, unsigned long max_it,$/;"	f	class:simlib3::AlgLoop	signature:(double eps, unsigned long max_it, double t_min, double t_max, double t0)
Set	calendar.cc	/^    void Set(Entity *e, double t) {$/;"	f	struct:simlib3::EventNotice	access:public	signature:(Entity *e, double t)
Set	delay.cc	/^double Delay::Set(double newdelay)$/;"	f	class:simlib3::Delay	signature:(double newdelay)
Set	delay.h	/^    double Set(double newDT);   \/\/!< change delay time (EXPERIMENTAL)$/;"	p	class:simlib3::Delay	access:public	signature:(double newDT)
Set	intg.cc	/^void Integrator::Set(double value)$/;"	f	class:simlib3::Integrator	signature:(double value)
Set	intg.cc	/^void Status::Set(double value)$/;"	f	class:simlib3::Status	signature:(double value)
Set	simlib.h	/^  Input Set(Input i)     {$/;"	f	class:simlib3::Input	access:public	signature:(Input i)
Set	simlib.h	/^  void Set(double eps, unsigned long max_it, \/\/ set parameters$/;"	p	class:simlib3::AlgLoop	access:public	signature:(double eps, unsigned long max_it, double t_min, double t_max)
Set	simlib.h	/^  void Set(double eps, unsigned long max_it, \/\/ set parameters$/;"	p	class:simlib3::AlgLoop	access:public	signature:(double eps, unsigned long max_it, double t_min, double t_max, double t0)
Set	simlib.h	/^  void Set(double value);              \/\/ set integrator state value$/;"	p	class:simlib3::Integrator	access:public	signature:(double value)
Set	simlib.h	/^  void Set(double value);              \/\/ set status of block$/;"	p	class:simlib3::Status	access:public	signature:(double value)
Set	simlib2D.h	/^  Input2D Set(Input2D i)    { Input2D p=bp; bp=i.bp; return p; }$/;"	f	class:simlib3::Input2D	access:public	signature:(Input2D i)
Set	simlib3D.h	/^  Input3D Set(Input3D i)     { Input3D p=bp; bp=i.bp; return p; }$/;"	f	class:simlib3::Input3D	access:public	signature:(Input3D i)
Set	zdelay.h	/^    void Set(double new_dt) { dt = new_dt; }$/;"	f	class:simlib3::ZDelayTimer	access:public	signature:(double new_dt)
SetAccuracy	intg.cc	/^void SetAccuracy(double _abserr, double _relerr)$/;"	f	namespace:simlib3	signature:(double _abserr, double _relerr)
SetAccuracy	intg.cc	/^void SetAccuracy(double relerr)$/;"	f	namespace:simlib3	signature:(double relerr)
SetAccuracy	simlib.h	/^void SetAccuracy(double abserr, double relerr);$/;"	p	namespace:simlib3	signature:(double abserr, double relerr)
SetAccuracy	simlib.h	/^void SetAccuracy(double relerr);$/;"	p	namespace:simlib3	signature:(double relerr)
SetAccuracyError	errors.h	/^\/* 11 *\/ SetAccuracyError,$/;"	e	enum:_ErrEnum
SetAll	cond.cc	/^void aCondition::SetAll() {$/;"	f	class:simlib3::aCondition	signature:()
SetAll	simlib.h	/^  static void SetAll();$/;"	p	class:simlib3::aCondition	access:public	signature:()
SetBaseRandomGenerator	random1.cc	/^void   SetBaseRandomGenerator(double (*new_gen)()); \/\/ change base gen.$/;"	p	namespace:simlib3	file:	signature:(double (*new_gen)())
SetBaseRandomGenerator	random1.cc	/^void SetBaseRandomGenerator(double (*new_gen)())$/;"	f	namespace:simlib3	signature:(double (*new_gen)())
SetBaseRandomGenerator	simlib.h	/^void   SetBaseRandomGenerator(double (*new_gen)());$/;"	p	namespace:simlib3	signature:(double (*new_gen)())
SetCalendar	calendar.cc	/^  friend void SetCalendar(const char *name); \/\/ sets _instance$/;"	p	class:simlib3::Calendar	file:	access:friend	signature:(const char *name)
SetCalendar	calendar.cc	/^void SetCalendar(const char *name) {$/;"	f	namespace:simlib3	signature:(const char *name)
SetCalendar	simlib.h	/^void SetCalendar(const char *name);$/;"	p	namespace:simlib3	signature:(const char *name)
SetCapacity	simlib.h	/^  void SetCapacity(unsigned long _capacity);            \/\/!< change the capacity$/;"	p	class:simlib3::Store	access:public	signature:(unsigned long _capacity)
SetCapacity	store.cc	/^void Store::SetCapacity(unsigned long newcapacity)$/;"	f	class:simlib3::Store	signature:(unsigned long newcapacity)
SetCapacityError	errors.h	/^\/* 40 *\/ SetCapacityError,$/;"	e	enum:_ErrEnum
SetDiff	simlib.h	/^  void SetDiff(double d) { dd=d; }$/;"	f	class:simlib3::Integrator	access:public	signature:(double d)
SetErrNo	simlib.h	/^  static void SetErrNo(int num) { \/\/ set # of errors$/;"	f	class:simlib3::IntegrationMethod	access:public	signature:(int num)
SetInput	simlib.h	/^  Input SetInput(Input inp) { return in.Set(inp); } \/\/ change input block$/;"	f	class:simlib3::Condition	access:public	signature:(Input inp)
SetInput	simlib.h	/^  Input SetInput(Input inp) { return input.Set(inp); }$/;"	f	class:simlib3::Integrator	access:public	signature:(Input inp)
SetInput	simlib2D.h	/^  Input2D SetInput(Input2D i) { return in.in.Set(i); }$/;"	f	class:simlib3::Integrator2D	access:public	signature:(Input2D i)
SetInput	simlib2D.h	/^  Input2D SetInput(Input2D i) { return input.Set(i); }$/;"	f	class:simlib3::aContiBlock2D1	access:public	signature:(Input2D i)
SetInput	simlib3D.h	/^  Input3D SetInput(Input3D i) { return in.in.Set(i); }$/;"	f	class:simlib3::Integrator3D	access:public	signature:(Input3D i)
SetInput	simlib3D.h	/^  Input3D SetInput(Input3D i) { return input.Set(i); }$/;"	f	class:simlib3::aContiBlock3D1	access:public	signature:(Input3D i)
SetMethod	numint.cc	/^void IntegrationMethod::SetMethod(const char* name)$/;"	f	class:simlib3::IntegrationMethod	signature:(const char* name)
SetMethod	simlib.h	/^  static void SetMethod(const char* name);  \/\/ set method which will be used$/;"	p	class:simlib3::IntegrationMethod	access:public	signature:(const char* name)
SetMethod	simlib.h	/^inline void SetMethod(const char* name)$/;"	f	namespace:simlib3	signature:(const char* name)
SetMinTime	calendar.cc	/^    void SetMinTime(double t) { mintime=t; }$/;"	f	class:simlib3::Calendar	access:protected	signature:(double t)
SetName	name.cc	/^void SetName(SimObject & o, const char *name)$/;"	f	namespace:simlib3	signature:(SimObject & o, const char *name)
SetName	name.cc	/^void SetName(SimObject * o, const char *name)$/;"	f	namespace:simlib3	signature:(SimObject * o, const char *name)
SetName	object.cc	/^void SimObject::SetName(const char *name)$/;"	f	class:simlib3::SimObject	signature:(const char *name)
SetName	simlib.h	/^  void SetName(const char *name);      \/\/!< assign the name$/;"	p	class:simlib3::SimObject	access:public	signature:(const char *name)
SetName	simlib.h	/^void SetName(SimObject &o, const char *name);$/;"	p	namespace:simlib3	signature:(SimObject &o, const char *name)
SetName	simlib.h	/^void SetName(SimObject *o, const char *name);$/;"	p	namespace:simlib3	signature:(SimObject *o, const char *name)
SetNewStatus	cond.cc	/^void Condition::SetNewStatus()$/;"	f	class:simlib3::Condition	signature:()
SetNewStatus	simlib.h	/^  virtual void SetNewStatus();$/;"	p	class:simlib3::Condition	access:private	signature:()
SetNewStatus	simlib.h	/^  virtual void SetNewStatus()=0;       \/\/!< update$/;"	p	class:simlib3::aCondition	access:private	signature:()
SetOldDiff	simlib.h	/^  void SetOldDiff(double d) { ddl=d; }$/;"	f	class:simlib3::Integrator	access:public	signature:(double d)
SetOldState	simlib.h	/^  void SetOldState(double s) { ssl=s; }$/;"	f	class:simlib3::Integrator	access:public	signature:(double s)
SetOldState	simlib.h	/^  void SetOldState(double s) { stl=s; }$/;"	f	class:simlib3::Status	access:public	signature:(double s)
SetOptStep	simlib.h	/^  static void SetOptStep(double opt_step) { \/\/ set optimal step size$/;"	f	class:simlib3::IntegrationMethod	access:public	signature:(double opt_step)
SetOutput	print.cc	/^void SetOutput(const char *name)$/;"	f	namespace:simlib3	signature:(const char *name)
SetOutput	simlib.h	/^void SetOutput(const char *name);$/;"	p	namespace:simlib3	signature:(const char *name)
SetQueue	facility.cc	/^void Facility::SetQueue(Queue * queue)$/;"	f	class:simlib3::Facility	signature:(Queue * queue)
SetQueue	simlib.h	/^  void SetQueue(Queue *queue);                          \/\/!< change input queue$/;"	p	class:simlib3::Store	access:public	signature:(Queue *queue)
SetQueue	simlib.h	/^  void SetQueue(Queue *queue1);                  \/\/!< change input queue$/;"	p	class:simlib3::Facility	access:public	signature:(Queue *queue1)
SetQueue	store.cc	/^void Store::SetQueue(Queue *queue)$/;"	f	class:simlib3::Store	signature:(Queue *queue)
SetQueueError	errors.h	/^\/* 41 *\/ SetQueueError,$/;"	e	enum:_ErrEnum
SetStartMode	simlib.h	/^  void SetStartMode(bool start_mode) {  \/\/ set flag on\/off$/;"	f	class:simlib3::SingleStepMethod	access:public	signature:(bool start_mode)
SetStarter	numint.cc	/^void MultiStepMethod::SetStarter(const char* name, const char* slave_name)$/;"	f	class:simlib3::MultiStepMethod	signature:(const char* name, const char* slave_name)
SetStarter	numint.cc	/^void MultiStepMethod::SetStarter(const char* slave_name)$/;"	f	class:simlib3::MultiStepMethod	signature:(const char* slave_name)
SetStarter	simlib.h	/^  static void SetStarter(const char* name, const char* slave_name);$/;"	p	class:simlib3::MultiStepMethod	access:public	signature:(const char* name, const char* slave_name)
SetStarter	simlib.h	/^  virtual void SetStarter(const char* slave_name);$/;"	p	class:simlib3::MultiStepMethod	access:public	signature:(const char* slave_name)
SetStarter	simlib.h	/^inline void SetStarter(const char* name, const char* slave_name)$/;"	f	namespace:simlib3	signature:(const char* name, const char* slave_name)
SetStarter	simlib.h	/^inline void SetStarter(const char* slave_name)$/;"	f	namespace:simlib3	signature:(const char* slave_name)
SetState	simlib.h	/^  void SetState(double s) { ss=s; }$/;"	f	class:simlib3::Integrator	access:public	signature:(double s)
SetState	simlib.h	/^  void SetState(double s) { st=s; }$/;"	f	class:simlib3::Status	access:public	signature:(double s)
SetStep	intg.cc	/^void SetStep(double _dtmin, double _dtmax)$/;"	f	namespace:simlib3	signature:(double _dtmin, double _dtmax)
SetStep	sampler.cc	/^double Sampler::SetStep(double dt)$/;"	f	class:simlib3::Sampler	signature:(double dt)
SetStep	simlib.h	/^    double SetStep(double dt=0.0);  \/\/!< change step$/;"	p	class:simlib3::Sampler	access:public	signature:(double dt=0.0)
SetStep	simlib.h	/^inline void SetStep(double dt) { SetStep(dt,dt); }$/;"	f	namespace:simlib3	signature:(double dt)
SetStep	simlib.h	/^void SetStep(double dtmin, double dtmax);$/;"	p	namespace:simlib3	signature:(double dtmin, double dtmax)
SetStepError	errors.h	/^\/* 8 *\/ SetStepError,$/;"	e	enum:_ErrEnum
SetStepError2	errors.h	/^\/* 10 *\/ SetStepError2,$/;"	e	enum:_ErrEnum
SetStepSize	simlib.h	/^  static void SetStepSize(double step_size) { \/\/ set step size$/;"	f	class:simlib3::IntegrationMethod	access:public	signature:(double step_size)
SetValid	simlib.h	/^  void SetValid(bool flag) { ValueOK = flag; } \/\/ set valid flag$/;"	f	class:simlib3::Status	access:public	signature:(bool flag)
Sign	fun.cc	/^Input Sign(Input x)             { return new Function1(x, sign); }$/;"	f	namespace:simlib3	signature:(Input x)
Sign	simlib.h	/^Input Sign(Input x);            \/\/ signum  ###warning-steps-not-detected$/;"	p	namespace:simlib3	signature:(Input x)
SimObject	object.cc	/^SimObject::SimObject() :$/;"	f	class:simlib3::SimObject	signature:()
SimObject	simlib.h	/^  SimObject();$/;"	p	class:simlib3::SimObject	access:public	signature:()
SimObject	simlib.h	/^  SimObject(SimObject&);               \/\/!< disabled operation$/;"	p	class:simlib3::SimObject	access:private	signature:(SimObject&)
SimObject	simlib.h	/^class SimObject {$/;"	c	namespace:simlib3
SimObject_allocated	object.cc	/^static bool SimObject_allocated = false;$/;"	m	namespace:simlib3	file:
Sin	fun.cc	/^Input Sin(Input x)              { return new Function1(x, sin); }$/;"	f	namespace:simlib3	signature:(Input x)
Sin	simlib.h	/^Input Sin(Input x);             \/\/ sin(x)$/;"	p	namespace:simlib3	signature:(Input x)
SingleStepMethod	simlib.h	/^  SingleStepMethod(const char* name) :  \/\/ initialize method and registrate it$/;"	f	class:simlib3::SingleStepMethod	access:public	signature:(const char* name)
SingleStepMethod	simlib.h	/^class SingleStepMethod : public IntegrationMethod {$/;"	c	namespace:simlib3	inherits:IntegrationMethod
Size	calendar.cc	/^    unsigned Size()  const { return _size; }$/;"	f	class:simlib3::Calendar	access:public	signature:() const
Size	simlib.h	/^  static size_t Size(void) {$/;"	f	class:simlib3::IntegratorContainer	access:public	signature:(void)
Size	simlib.h	/^  static size_t Size(void) {$/;"	f	class:simlib3::StatusContainer	access:public	signature:(void)
SkipBlanks	generr.c	/^void SkipBlanks(void)$/;"	f	signature:(void)
SlaveName	simlib.h	/^  char* SlaveName;  \/\/ the name of the method used for starting$/;"	m	class:simlib3::MultiStepMethod	access:private
SlavePtr	numint.cc	/^SingleStepMethod* MultiStepMethod::SlavePtr(void)$/;"	f	class:simlib3::MultiStepMethod	signature:(void)
SlavePtr	simlib.h	/^  SingleStepMethod* SlavePtr(void);  \/\/ return pointer to the starting method$/;"	p	class:simlib3::MultiStepMethod	access:protected	signature:(void)
Slave_Ptr	simlib.h	/^  SingleStepMethod* Slave_Ptr;  \/\/ pointer to the method used for starting$/;"	m	class:simlib3::MultiStepMethod	access:private
Sqr	continuous.cc	/^Input Sqr(Input x) { return new _Mul(x,x); }$/;"	f	namespace:simlib3	signature:(Input x)
Sqr	simlib.h	/^Input Sqr(Input x);             \/\/ square     x * x$/;"	p	namespace:simlib3	signature:(Input x)
Sqrt	fun.cc	/^Input Sqrt(Input x)             { return new Function1(x, sqrt); }$/;"	f	namespace:simlib3	signature:(Input x)
Sqrt	simlib.h	/^Input Sqrt(Input x);            \/\/ square root$/;"	p	namespace:simlib3	signature:(Input x)
Start	sampler.cc	/^void Sampler::Start()$/;"	f	class:simlib3::Sampler	signature:()
Start	simlib.h	/^    void Start();                   \/\/!< start + sample$/;"	p	class:simlib3::Sampler	access:public	signature:()
Start	zdelay.cc	/^void ZDelayTimer::Start() \/\/ clock activation$/;"	f	class:simlib3::ZDelayTimer	signature:()
Start	zdelay.h	/^    void Start(); \/\/ clock activation$/;"	p	class:simlib3::ZDelayTimer	access:public	signature:()
StartMode	simlib.h	/^  bool StartMode;$/;"	m	class:simlib3::SingleStepMethod	access:private
StartSampling	graph.cc	/^void Graph::StartSampling()$/;"	f	class:simlib3::Graph	signature:()
StartTime	run.cc	/^const double & StartTime = SIMLIB_StartTime;    \/\/ time of simulation start$/;"	m	namespace:simlib3	file:
StartTime	simlib.h	/^  double StartTime() const     { return t0; }$/;"	f	class:simlib3::TStat	access:public	signature:() const
StartTime	simlib.h	/^  double StartTime;$/;"	m	struct:simlib3::SIMLIB_statistics_t	access:public
Stat	simlib.h	/^  Stat();$/;"	p	class:simlib3::Stat	access:public	signature:()
Stat	simlib.h	/^  Stat(const char *name);$/;"	p	class:simlib3::Stat	access:public	signature:(const char *name)
Stat	simlib.h	/^class Stat : public SimObject {$/;"	c	namespace:simlib3	inherits:SimObject
Stat	stat.cc	/^Stat::Stat() :$/;"	f	class:simlib3::Stat	signature:()
Stat	stat.cc	/^Stat::Stat(const char *name) :$/;"	f	class:simlib3::Stat	signature:(const char *name)
StatDT	simlib.h	/^    Stat  StatDT;                        \/\/ statistics$/;"	m	class:simlib3::Queue	access:public
StatDispError	errors.h	/^\/* 62 *\/ StatDispError,$/;"	e	enum:_ErrEnum
StatN	simlib.h	/^    TStat StatN;$/;"	m	class:simlib3::Queue	access:public
StatNoRecError	errors.h	/^\/* 61 *\/ StatNoRecError,$/;"	e	enum:_ErrEnum
StateCond	numint.cc	/^bool IntegrationMethod::StateCond(void)$/;"	f	class:simlib3::IntegrationMethod	signature:(void)
StateCond	simlib.h	/^  static bool StateCond(void);  \/\/ check on changes of state conditions$/;"	p	class:simlib3::IntegrationMethod	access:protected	signature:(void)
Status	intg.cc	/^Status::Status(Input i, double initvalue): aContiBlock1(i)$/;"	f	class:simlib3::Status	signature:(Input i, double initvalue)
Status	simlib.h	/^  Status(Input i, double initvalue=0);$/;"	p	class:simlib3::Status	access:public	signature:(Input i, double initvalue=0)
Status	simlib.h	/^  Status(Status&);                     \/\/ disable copy ctor$/;"	p	class:simlib3::Status	access:private	signature:(Status&)
Status	simlib.h	/^class Status : public aContiBlock1 {   \/\/ state-variables$/;"	c	namespace:simlib3	inherits:aContiBlock1
StatusContainer	simlib.h	/^  StatusContainer();  \/\/ forbid constructor$/;"	p	class:simlib3::StatusContainer	access:private	signature:()
StatusContainer	simlib.h	/^class StatusContainer {$/;"	c	namespace:simlib3
StatusIterator	simlib.h	/^  typedef StatusContainer::iterator StatusIterator;  \/\/ iterator of intg. list$/;"	t	class:simlib3::StatusMethod	access:protected
StatusMList	simlib.h	/^  std::list<Memory*> StatusMList;  \/\/ list of auxiliary memories$/;"	m	class:simlib3::StatusMethod	access:private
StatusMemory	simlib.h	/^    StatusMemory(StatusMemory&);  \/\/ forbid copy constructor$/;"	p	class:simlib3::StatusMethod::StatusMemory	access:private	signature:(StatusMemory&)
StatusMemory	simlib.h	/^    StatusMemory(std::list<Memory*>* PtrList=PtrStatusMList) : Memory(PtrList) { }$/;"	f	class:simlib3::StatusMethod::StatusMemory	access:public	signature:(std::list<Memory*>* PtrList=PtrStatusMList)
StatusMemory	simlib.h	/^  class StatusMemory : public Memory {$/;"	c	class:simlib3::StatusMethod	inherits:Memory	access:protected
StatusMethod	numint.cc	/^StatusMethod::StatusMethod(const char* name):$/;"	f	class:simlib3::StatusMethod	signature:(const char* name)
StatusMethod	simlib.h	/^  StatusMethod();  \/\/ forbid implicit constructor$/;"	p	class:simlib3::StatusMethod	access:private	signature:()
StatusMethod	simlib.h	/^  StatusMethod(StatusMethod&);  \/\/ forbid implicit copy-constructor$/;"	p	class:simlib3::StatusMethod	access:private	signature:(StatusMethod&)
StatusMethod	simlib.h	/^  StatusMethod(const char* name);  \/\/ initailization$/;"	p	class:simlib3::StatusMethod	access:public	signature:(const char* name)
StatusMethod	simlib.h	/^class StatusMethod : public SingleStepMethod {$/;"	c	namespace:simlib3	inherits:SingleStepMethod
StatusResize	numint.cc	/^void StatusMethod::StatusResize(size_t size)$/;"	f	class:simlib3::StatusMethod	signature:(size_t size)
StatusResize	simlib.h	/^  virtual void StatusResize(size_t size);  \/\/ resize status memories$/;"	p	class:simlib3::StatusMethod	access:public	signature:(size_t size)
StdDev	simlib.h	/^  double StdDev() const;$/;"	p	class:simlib3::Stat	access:public	signature:() const
StdDev	stat.cc	/^double Stat::StdDev() const$/;"	f	class:simlib3::Stat	signature:() const
Step	simlib.h	/^  double Step() const    { return step; }$/;"	f	class:simlib3::Histogram	access:public	signature:() const
StepCount	simlib.h	/^  long   StepCount;     \/\/ for continuous simulation$/;"	m	struct:simlib3::SIMLIB_statistics_t	access:public
StepSim	numint.cc	/^void IntegrationMethod::StepSim(void)$/;"	f	class:simlib3::IntegrationMethod	signature:(void)
StepSim	simlib.h	/^  static void StepSim(void);  \/\/ single step of numerical integration method$/;"	p	class:simlib3::IntegrationMethod	access:public	signature:(void)
StepSize	intg.cc	/^const double &StepSize=SIMLIB_StepSize;      \/\/!< actual integration step$/;"	m	namespace:simlib3	file:
Stop	run.cc	/^void Stop()$/;"	f	namespace:simlib3	signature:()
Stop	sampler.cc	/^void Sampler::Stop()$/;"	f	class:simlib3::Sampler	signature:()
Stop	simlib.h	/^    void Stop();                    \/\/!< sample + stop$/;"	p	class:simlib3::Sampler	access:public	signature:()
Stop	simlib.h	/^void Stop();$/;"	p	namespace:simlib3	signature:()
Stop	zdelay.cc	/^void ZDelayTimer::Stop() \/\/ clock deactivation$/;"	f	class:simlib3::ZDelayTimer	signature:()
Stop	zdelay.h	/^    void Stop();  \/\/ stop clock$/;"	p	class:simlib3::ZDelayTimer	access:public	signature:()
StopFlag	run.cc	/^static bool StopFlag = false;           \/\/ if set, stop simulation run$/;"	m	namespace:simlib3	file:
StopSampling	graph.cc	/^void Graph::StopSampling()$/;"	f	class:simlib3::Graph	signature:()
Store	simlib.h	/^    Store(const Store&);              \/\/ disable$/;"	p	class:simlib3::Store	access:private	signature:(const Store&)
Store	simlib.h	/^  Store();$/;"	p	class:simlib3::Store	access:public	signature:()
Store	simlib.h	/^  Store(const char *_name, unsigned long _capacity);$/;"	p	class:simlib3::Store	access:public	signature:(const char *_name, unsigned long _capacity)
Store	simlib.h	/^  Store(const char *_name, unsigned long _capacity, Queue *queue);$/;"	p	class:simlib3::Store	access:public	signature:(const char *_name, unsigned long _capacity, Queue *queue)
Store	simlib.h	/^  Store(unsigned long _capacity);$/;"	p	class:simlib3::Store	access:public	signature:(unsigned long _capacity)
Store	simlib.h	/^  Store(unsigned long _capacity, Queue *queue);$/;"	p	class:simlib3::Store	access:public	signature:(unsigned long _capacity, Queue *queue)
Store	simlib.h	/^class Store : public SimObject {$/;"	c	namespace:simlib3	inherits:SimObject
Store	store.cc	/^Store::Store() :$/;"	f	class:simlib3::Store	signature:()
Store	store.cc	/^Store::Store(const char * name, unsigned long _capacity) :$/;"	f	class:simlib3::Store	signature:(const char * name, unsigned long _capacity)
Store	store.cc	/^Store::Store(const char *name, unsigned long _capacity, Queue *queue) :$/;"	f	class:simlib3::Store	signature:(const char *name, unsigned long _capacity, Queue *queue)
Store	store.cc	/^Store::Store(unsigned long _capacity) :$/;"	f	class:simlib3::Store	signature:(unsigned long _capacity)
Store	store.cc	/^Store::Store(unsigned long _capacity, Queue *queue) :$/;"	f	class:simlib3::Store	signature:(unsigned long _capacity, Queue *queue)
StoreState	numint.cc	/^void StatusMethod::StoreState(Memory& di, Memory& si, StatusMemory& xi)$/;"	f	class:simlib3::StatusMethod	signature:(Memory& di, Memory& si, StatusMemory& xi)
StoreState	simlib.h	/^  static void StoreState(Memory& di, Memory& si, StatusMemory& xi);$/;"	p	class:simlib3::StatusMethod	access:protected	signature:(Memory& di, Memory& si, StatusMemory& xi)
Sum	simlib.h	/^  double Sum() const           { return sx; }$/;"	f	class:simlib3::Stat	access:public	signature:() const
Sum	simlib.h	/^  double Sum() const           { return sxt; }$/;"	f	class:simlib3::TStat	access:public	signature:() const
SumSquare	simlib.h	/^  double SumSquare() const     { return sx2; }$/;"	f	class:simlib3::Stat	access:public	signature:() const
SumSquare	simlib.h	/^  double SumSquare() const     { return sx2t; }$/;"	f	class:simlib3::TStat	access:public	signature:() const
Summarize	numint.cc	/^void IntegrationMethod::Summarize(void)$/;"	f	class:simlib3::IntegrationMethod	signature:(void)
Summarize	simlib.h	/^  static void Summarize(void);  \/\/ set up new state after integration$/;"	p	class:simlib3::IntegrationMethod	access:private	signature:(void)
T	continuous.cc	/^aContiBlock & T = _T;   \/\/ TODO try Input$/;"	m	namespace:simlib3	file:
T0	simlib.h	/^  double T0; \/\/ initial value$/;"	m	class:simlib3::AlgLoop	access:protected
TA	simlib.h	/^  double TA; \/\/ boundary values of interval$/;"	m	class:simlib3::AlgLoop	access:protected
TABLE	generr.c	/^} TABLE;$/;"	t	typeref:struct:__anon3	file:
TB	simlib.h	/^  double TB; \/\/ (also used for convergency check)$/;"	m	class:simlib3::AlgLoop	access:protected
TERMINATION	internal.h	/^    TERMINATION,    \/\/ after Run() call$/;"	e	enum:simlib3::SIMLIB_Phase_t
THREAD_EXIT	process.cc	165;"	d	file:
THREAD_INTERRUPT	process.cc	155;"	d	file:
THREAD_INTERRUPT_f	process.cc	/^static void THREAD_INTERRUPT_f()$/;"	f	namespace:simlib3	signature:()
THREAD_INTERRUPT_f	process.cc	/^static void THREAD_INTERRUPT_f();       \/\/ special function$/;"	p	namespace:simlib3	file:	signature:()
TRUE	generr.c	/^enum Boolean { FALSE, TRUE };$/;"	e	enum:Boolean	file:
TStat	simlib.h	/^  TStat(const char *name, double initval=0.0);$/;"	p	class:simlib3::TStat	access:public	signature:(const char *name, double initval=0.0)
TStat	simlib.h	/^  TStat(double initval=0.0);$/;"	p	class:simlib3::TStat	access:public	signature:(double initval=0.0)
TStat	simlib.h	/^class TStat : public SimObject {$/;"	c	namespace:simlib3	inherits:SimObject
TStat	tstat.cc	/^TStat::TStat(const char *name, double initval) :$/;"	f	class:simlib3::TStat	signature:(const char *name, double initval)
TStat	tstat.cc	/^TStat::TStat(double initval):$/;"	f	class:simlib3::TStat	signature:(double initval)
TStatNotInitialized	errors.h	/^\/* 30 *\/ TStatNotInitialized,$/;"	e	enum:_ErrEnum
T_MEASURE	calendar.cc	/^static unsigned long long T_MEASURE;$/;"	m	namespace:__anon4	file:
Table	generr.c	/^    struct tabitem Table[MAXERR];$/;"	m	struct:__anon3	typeref:struct:__anon3::tabitem	file:	access:public
Tan	fun.cc	/^Input Tan(Input x)              { return new Function1(x, tan); }$/;"	f	namespace:simlib3	signature:(Input x)
Tan	simlib.h	/^Input Tan(Input x);             \/\/ tan(x)$/;"	p	namespace:simlib3	signature:(Input x)
Terminate	entity.cc	/^void Entity::Terminate()$/;"	f	class:simlib3::Entity	signature:()
Terminate	event.cc	/^void Event::Terminate()$/;"	f	class:simlib3::Event	signature:()
Terminate	process.cc	/^void Process::Terminate()$/;"	f	class:simlib3::Process	signature:()
Terminate	simlib.h	/^    virtual void Terminate() = 0;       \/\/!< end Behavior() and remove entity$/;"	p	class:simlib3::Entity	access:public	signature:()
Terminate	simlib.h	/^  virtual void Terminate();             \/\/!< kill process$/;"	p	class:simlib3::Process	access:public	signature:()
Terminate	simlib.h	/^  virtual void Terminate();       \/\/ do not use (deprecated)$/;"	p	class:simlib3::Event	access:private	signature:()
Test	_test_.cc	/^  Test(Input F):$/;"	f	struct:Test	access:public	signature:(Input F)
Test	_test_.cc	/^struct Test {$/;"	s	file:
Test	cond.cc	/^bool Condition::Test() {$/;"	f	class:simlib3::Condition	signature:()
Test	simlib.h	/^  bool Test() { return Condition::Test() && Down(); }$/;"	f	class:simlib3::ConditionDown	access:public	signature:()
Test	simlib.h	/^  bool Test() { return Condition::Test() && Up(); }$/;"	f	class:simlib3::ConditionUp	access:public	signature:()
Test	simlib.h	/^  virtual bool Test();                  \/\/ test function (input >= 0.0)$/;"	p	class:simlib3::Condition	access:protected	signature:()
Test	simlib.h	/^  virtual bool Test()=0;               \/\/!< test of the condition$/;"	p	class:simlib3::aCondition	access:private	signature:()
Test::Test	_test_.cc	/^  Test(Input F):$/;"	f	struct:Test	access:public	signature:(Input F)
Test::limitation	_test_.cc	/^  Lim limitation;$/;"	m	struct:Test	file:	access:public
Test::v	_test_.cc	/^  Integrator v;$/;"	m	struct:Test	file:	access:public
Test::y	_test_.cc	/^  Status y;$/;"	m	struct:Test	file:	access:public
TestAll	cond.cc	/^void aCondition::TestAll()$/;"	f	class:simlib3::aCondition	signature:()
TestAll	simlib.h	/^  static void TestAll();$/;"	p	class:simlib3::aCondition	access:public	signature:()
TestAndSetFlag	internal.h	/^inline bool SimObject::TestAndSetFlag(bool new_value, unsigned n) {$/;"	f	class:simlib3::SimObject	signature:(bool new_value, unsigned n)
TestAndSetFlag	simlib.h	/^  bool TestAndSetFlag(bool new_value, unsigned n);$/;"	p	class:simlib3::SimObject	access:public	signature:(bool new_value, unsigned n)
TestProcess	_test_.cc	/^class TestProcess : public Process {$/;"	c	file:	inherits:Process
TestProcess::Behavior	_test_.cc	/^  void Behavior() {$/;"	f	class:TestProcess	access:public	signature:()
Time	run.cc	/^const double & Time      = SIMLIB_Time;         \/\/ simulation time$/;"	m	namespace:simlib3	file:
Triag	random2.cc	/^double Triag(double mod, double min, double max)$/;"	f	namespace:simlib3	signature:(double mod, double min, double max)
Triag	simlib.h	/^double Triag(double mod, double min, double max);$/;"	p	namespace:simlib3	signature:(double mod, double min, double max)
TurnOff	numint.cc	/^void IntegrationMethod::TurnOff(void)$/;"	f	class:simlib3::IntegrationMethod	signature:(void)
TurnOff	numint.cc	/^void MultiStepMethod::TurnOff(void)$/;"	f	class:simlib3::MultiStepMethod	signature:(void)
TurnOff	numint.cc	/^void StatusMethod::TurnOff(void)$/;"	f	class:simlib3::StatusMethod	signature:(void)
TurnOff	simlib.h	/^  virtual void TurnOff(void);  \/\/ turn off integration method$/;"	p	class:simlib3::IntegrationMethod	access:public	signature:(void)
TurnOff	simlib.h	/^  virtual void TurnOff(void);  \/\/ turn off integration method$/;"	p	class:simlib3::StatusMethod	access:public	signature:(void)
TurnOff	simlib.h	/^  virtual void TurnOff(void);  \/\/ turn off method & its slave$/;"	p	class:simlib3::MultiStepMethod	access:public	signature:(void)
TwiceInitError	errors.h	/^\/* 5 *\/ TwiceInitError,$/;"	e	enum:_ErrEnum
UnRegister	delay.cc	/^      static void UnRegister(Delay *p) {\/\/!< must be called from Delay destructor$/;"	f	class:simlib3::SIMLIB_Delay	access:public	signature:(Delay *p)
UnRegister	zdelay.cc	/^    static void UnRegister(ZDelayTimer *p) { \/\/ called from ZDelayTimer destructor$/;"	f	class:simlib3::SIMLIB_ZDelayTimer	access:public	signature:(ZDelayTimer *p)
UnRegister	zdelay.cc	/^void ZDelayTimer::UnRegister(ZDelay*p)$/;"	f	class:simlib3::ZDelayTimer	signature:(ZDelay*p)
UnRegister	zdelay.h	/^    void UnRegister(ZDelay*); \/\/ remove from container$/;"	p	class:simlib3::ZDelayTimer	access:private	signature:(ZDelay*)
UnRegisterReference	simlib.h	878;"	d
Uniform	random2.cc	/^double Uniform(double l, double h)$/;"	f	namespace:simlib3	signature:(double l, double h)
Uniform	simlib.h	/^double Uniform(double l, double h);$/;"	p	namespace:simlib3	signature:(double l, double h)
UnitVector	simlib2D.cc	/^Input2D UnitVector(Input2D x) { return new _Norm2D(x); }$/;"	f	namespace:simlib3	signature:(Input2D x)
UnitVector	simlib2D.h	/^Input2D UnitVector(Input2D v);$/;"	p	namespace:simlib3	signature:(Input2D v)
UnitVector	simlib3D.cc	/^Input3D UnitVector(Input3D x) { return new _Norm3D(x); }$/;"	f	namespace:simlib3	signature:(Input3D x)
UnitVector	simlib3D.h	/^Input3D UnitVector(Input3D x);$/;"	p	namespace:simlib3	signature:(Input3D x)
UnknownError	errors.h	/^\/* 1 *\/ UnknownError,$/;"	e	enum:_ErrEnum
Up	simlib.h	/^  bool Up()     { return ccl<cc; }      \/\/ change: FALSE->TRUE$/;"	f	class:simlib3::Condition	access:protected	signature:()
Used	simlib.h	/^  unsigned long Used() const { return used; }           \/\/!< used capacity$/;"	f	class:simlib3::Store	access:public	signature:() const
UserError	errors.h	/^\/* 80 *\/ UserError,$/;"	e	enum:_ErrEnum
V	semaphor.cc	/^void Semaphore::V()$/;"	f	class:simlib3::Semaphore	signature:()
V	simlib.h	/^  virtual void V();                             \/\/!< V operation$/;"	p	class:simlib3::Semaphore	access:public	signature:()
Value	algloop.cc	/^double Bisect::Value()$/;"	f	class:simlib3::Bisect	signature:()
Value	algloop.cc	/^double Iterations::Value()$/;"	f	class:simlib3::Iterations	signature:()
Value	algloop.cc	/^double Newton::Value()$/;"	f	class:simlib3::Newton	signature:()
Value	algloop.cc	/^double RegulaFalsi::Value()$/;"	f	class:simlib3::RegulaFalsi	signature:()
Value	continuous.cc	/^  virtual double Value () { return Time; }$/;"	f	class:simlib3::_Time	access:public	signature:()
Value	continuous.cc	/^  virtual double Value()    { return -InputValue(); }$/;"	f	class:simlib3::_UMinus	access:public	signature:()
Value	continuous.cc	/^  virtual double Value() { return Input1Value() * Input2Value(); }$/;"	f	class:simlib3::_Mul	access:public	signature:()
Value	continuous.cc	/^  virtual double Value() { return Input1Value() + Input2Value(); }$/;"	f	class:simlib3::_Add	access:public	signature:()
Value	continuous.cc	/^  virtual double Value() { return Input1Value() - Input2Value(); }$/;"	f	class:simlib3::_Sub	access:public	signature:()
Value	continuous.cc	/^  virtual double Value() { return Input1Value() \/ Input2Value(); }$/;"	f	class:simlib3::_Div	access:public	signature:()
Value	continuous.cc	/^double Expression::Value() { AlgLoopDetector _(this); return InputValue(); }$/;"	f	class:simlib3::Expression	signature:()
Value	delay.cc	/^double Delay::Value()$/;"	f	class:simlib3::Delay	signature:()
Value	delay.h	/^    virtual double Value();     \/\/!< output of delay block$/;"	p	class:simlib3::Delay	access:public	signature:()
Value	fun.cc	/^double Function1::Value() {$/;"	f	class:simlib3::Function1	signature:()
Value	fun.cc	/^double Function2::Value() {$/;"	f	class:simlib3::Function2	signature:()
Value	intg.cc	/^double Integrator::Value()$/;"	f	class:simlib3::Integrator	signature:()
Value	intg.cc	/^double Status::Value()$/;"	f	class:simlib3::Status	signature:()
Value	optimize.h	/^    double Value() const { return value; }$/;"	f	class:simlib3::Param	access:public	signature:() const
Value	simlib.h	/^    virtual double Value() = 0;$/;"	p	class:simlib3::aContiBlock	access:public	signature:()
Value	simlib.h	/^  double Value() const { return bp->Value(); } \/\/!< get target block value$/;"	f	class:simlib3::Input	access:public	signature:() const
Value	simlib.h	/^  double Value();                      \/\/!< the state of integrator$/;"	p	class:simlib3::Integrator	access:public	signature:()
Value	simlib.h	/^  double Value();       \/\/!< Evaluate expression and return the value$/;"	p	struct:simlib3::Expression	access:public	signature:()
Value	simlib.h	/^  virtual bool Value() { return cc; }   \/\/ status$/;"	f	class:simlib3::Condition	access:public	signature:()
Value	simlib.h	/^  virtual bool Value()=0;              \/\/!< state of the condition$/;"	p	class:simlib3::aCondition	access:public	signature:()
Value	simlib.h	/^  virtual double Value ()         { return value; }$/;"	f	class:simlib3::Parameter	access:public	signature:()
Value	simlib.h	/^  virtual double Value ()         { return value; }$/;"	f	class:simlib3::Variable	access:public	signature:()
Value	simlib.h	/^  virtual double Value ()       { return value; }$/;"	f	class:simlib3::Constant	access:public	signature:()
Value	simlib.h	/^  virtual double Value();              \/\/ block status$/;"	p	class:simlib3::Status	access:public	signature:()
Value	simlib.h	/^  virtual double Value();         \/\/ returned value$/;"	p	class:simlib3::Frict	access:public	signature:()
Value	simlib.h	/^  virtual double Value();         \/\/ returned value$/;"	p	class:simlib3::Insv	access:public	signature:()
Value	simlib.h	/^  virtual double Value();         \/\/ returned value$/;"	p	class:simlib3::Lim	access:public	signature:()
Value	simlib.h	/^  virtual double Value();         \/\/ returned value$/;"	p	class:simlib3::Qntzr	access:public	signature:()
Value	simlib.h	/^  virtual double Value();         \/\/ returned value$/;"	p	class:simlib3::Rline	access:public	signature:()
Value	simlib.h	/^  virtual double Value(); \/\/ returned value$/;"	p	class:simlib3::Bisect	access:public	signature:()
Value	simlib.h	/^  virtual double Value(); \/\/ returned value$/;"	p	class:simlib3::Iterations	access:public	signature:()
Value	simlib.h	/^  virtual double Value(); \/\/ returned value$/;"	p	class:simlib3::Newton	access:public	signature:()
Value	simlib.h	/^  virtual double Value(); \/\/ returned value$/;"	p	class:simlib3::RegulaFalsi	access:public	signature:()
Value	simlib.h	/^  virtual double Value();$/;"	p	class:simlib3::Function1	access:public	signature:()
Value	simlib.h	/^  virtual double Value();$/;"	p	class:simlib3::Function2	access:public	signature:()
Value	simlib.h	/^  virtual double Value()=0; \/\/ returned value$/;"	p	class:simlib3::AlgLoop	access:public	signature:()
Value	simlib2D.cc	/^  virtual Value2D Value() {$/;"	f	class:simlib3::_Add2D	access:public	signature:()
Value	simlib2D.cc	/^  virtual Value2D Value() {$/;"	f	class:simlib3::_Div2D	access:public	signature:()
Value	simlib2D.cc	/^  virtual Value2D Value() {$/;"	f	class:simlib3::_Mul2D1D	access:public	signature:()
Value	simlib2D.cc	/^  virtual Value2D Value() {$/;"	f	class:simlib3::_Norm2D	access:public	signature:()
Value	simlib2D.cc	/^  virtual Value2D Value() {$/;"	f	class:simlib3::_Sub2D	access:public	signature:()
Value	simlib2D.cc	/^  virtual Value2D Value() {$/;"	f	class:simlib3::_UMinus2D	access:public	signature:()
Value	simlib2D.cc	/^  virtual double Value() {$/;"	f	class:simlib3::_Abs2D	access:public	signature:()
Value	simlib2D.cc	/^  virtual double Value() {$/;"	f	class:simlib3::_ScalarProduct2D	access:public	signature:()
Value	simlib2D.cc	/^  virtual double Value() {$/;"	f	class:simlib3::_XYpart	access:public	signature:()
Value	simlib2D.cc	/^Value2D Integrator2D::Value()$/;"	f	class:simlib3::Integrator2D	signature:()
Value	simlib2D.cc	/^double Integrator2D::special_input::Value() {  \/\/ interface class$/;"	f	class:simlib3::Integrator2D::special_input	signature:()
Value	simlib2D.h	/^    double Value();             \/\/ expects 2 subsequent evaluations$/;"	p	class:simlib3::Integrator2D::special_input	access:public	signature:()
Value	simlib2D.h	/^  Value2D Value()           { return bp->Value(); }   \/\/ get value$/;"	f	class:simlib3::Input2D	access:public	signature:()
Value	simlib2D.h	/^  Value2D Value() { return InputValue(); }$/;"	f	struct:simlib3::Expression2D	access:public	signature:()
Value	simlib2D.h	/^  virtual Value2D Value()            { return value; }$/;"	f	class:simlib3::Variable2D	access:public	signature:()
Value	simlib2D.h	/^  virtual Value2D Value()  { return value; }      \/\/ without Eval$/;"	f	class:simlib3::Constant2D	access:public	signature:()
Value	simlib2D.h	/^  virtual Value2D Value() = 0;       \/\/ output value$/;"	p	class:simlib3::aContiBlock2D	access:public	signature:()
Value	simlib2D.h	/^  virtual Value2D Value() {$/;"	f	class:simlib3::Adaptor2D	access:public	signature:()
Value	simlib2D.h	/^  virtual Value2D Value();      \/\/ 2D output$/;"	p	class:simlib3::Integrator2D	access:public	signature:()
Value	simlib3D.cc	/^  virtual Value3D Value() {$/;"	f	class:simlib3::_Add3D	access:public	signature:()
Value	simlib3D.cc	/^  virtual Value3D Value() {$/;"	f	class:simlib3::_Div3D	access:public	signature:()
Value	simlib3D.cc	/^  virtual Value3D Value() {$/;"	f	class:simlib3::_Mul3D	access:public	signature:()
Value	simlib3D.cc	/^  virtual Value3D Value() {$/;"	f	class:simlib3::_Mul3D1D	access:public	signature:()
Value	simlib3D.cc	/^  virtual Value3D Value() {$/;"	f	class:simlib3::_Norm3D	access:public	signature:()
Value	simlib3D.cc	/^  virtual Value3D Value() {$/;"	f	class:simlib3::_Sub3D	access:public	signature:()
Value	simlib3D.cc	/^  virtual Value3D Value() {$/;"	f	class:simlib3::_UMinus3D	access:public	signature:()
Value	simlib3D.cc	/^  virtual double Value() {$/;"	f	class:simlib3::_Abs3D	access:public	signature:()
Value	simlib3D.cc	/^  virtual double Value() {$/;"	f	class:simlib3::_ScalarProduct3D	access:public	signature:()
Value	simlib3D.cc	/^  virtual double Value() {$/;"	f	class:simlib3::_XYZpart	access:public	signature:()
Value	simlib3D.cc	/^Value3D Integrator3D::Value()$/;"	f	class:simlib3::Integrator3D	signature:()
Value	simlib3D.cc	/^double Integrator3D::special_input::Value() {  \/\/ interface class$/;"	f	class:simlib3::Integrator3D::special_input	signature:()
Value	simlib3D.h	/^    double Value();             \/\/ expects 3 subsequent evaluations$/;"	p	class:simlib3::Integrator3D::special_input	access:public	signature:()
Value	simlib3D.h	/^  Value3D Value()            { return bp->Value(); }   \/\/ get value$/;"	f	class:simlib3::Input3D	access:public	signature:()
Value	simlib3D.h	/^  Value3D Value() { return InputValue(); }$/;"	f	struct:simlib3::Expression3D	access:public	signature:()
Value	simlib3D.h	/^  virtual Value3D Value ()          { return value; }$/;"	f	class:simlib3::Variable3D	access:public	signature:()
Value	simlib3D.h	/^  virtual Value3D Value () { return value; }      \/\/ without Eval$/;"	f	class:simlib3::Constant3D	access:public	signature:()
Value	simlib3D.h	/^  virtual Value3D Value() = 0;       \/\/ output value$/;"	p	class:simlib3::aContiBlock3D	access:public	signature:()
Value	simlib3D.h	/^  virtual Value3D Value() {$/;"	f	class:simlib3::Adaptor3D	access:public	signature:()
Value	simlib3D.h	/^  virtual Value3D Value();      \/\/ 3D output$/;"	p	class:simlib3::Integrator3D	access:public	signature:()
Value	stdblock.cc	/^double Frict::Value()$/;"	f	class:simlib3::Frict	signature:()
Value	stdblock.cc	/^double Insv::Value()$/;"	f	class:simlib3::Insv	signature:()
Value	stdblock.cc	/^double Lim::Value()$/;"	f	class:simlib3::Lim	signature:()
Value	stdblock.cc	/^double Qntzr::Value()$/;"	f	class:simlib3::Qntzr	signature:()
Value	stdblock.cc	/^double Rline::Value()$/;"	f	class:simlib3::Rline	signature:()
Value	zdelay.cc	/^double ZDelay::Value()$/;"	f	class:simlib3::ZDelay	signature:()
Value	zdelay.h	/^    virtual double Value();     \/\/ output of ZDelay block$/;"	p	class:simlib3::ZDelay	access:public	signature:()
Value2D	simlib2D.h	/^  Value2D(double x, double y) : _x(x), _y(y) {}$/;"	f	class:simlib3::Value2D	access:public	signature:(double x, double y)
Value2D	simlib2D.h	/^class Value2D {$/;"	c	namespace:simlib3
Value3D	simlib3D.h	/^  Value3D(double x, double y, double z) : _x(x), _y(y), _z(z) {}$/;"	f	class:simlib3::Value3D	access:public	signature:(double x, double y, double z)
Value3D	simlib3D.h	/^class Value3D {$/;"	c	namespace:simlib3
ValueOK	simlib.h	/^  bool ValueOK;                        \/\/ valid-flag ###$/;"	m	class:simlib3::Status	access:protected
Variable	simlib.h	/^  Variable(double x=0) : value(x) {}$/;"	f	class:simlib3::Variable	access:public	signature:(double x=0)
Variable	simlib.h	/^class Variable : public aContiBlock {$/;"	c	namespace:simlib3	inherits:aContiBlock
Variable2D	simlib2D.h	/^  explicit Variable2D(Value2D x=Value2D(0,0)) : value(x) {}$/;"	f	class:simlib3::Variable2D	access:public	signature:(Value2D x=Value2D(0,0))
Variable2D	simlib2D.h	/^class Variable2D : public aContiBlock2D {$/;"	c	namespace:simlib3	inherits:aContiBlock2D
Variable3D	simlib3D.h	/^  explicit Variable3D(Value3D x=Value3D(0,0,0)) : value(x) {}$/;"	f	class:simlib3::Variable3D	access:public	signature:(Value3D x=Value3D(0,0,0))
Variable3D	simlib3D.h	/^class Variable3D : public aContiBlock3D {$/;"	c	namespace:simlib3	inherits:aContiBlock3D
VoidFunctionPtr	internal.h	/^typedef void (*VoidFunctionPtr)(); \/\/ ptr to void function$/;"	t	namespace:simlib3
WU_hook	waitunti.cc	/^    static void WU_hook(); \/\/ active: next process in WUlist or 0$/;"	p	class:simlib3::WaitUntilList	file:	access:public	signature:()
WU_hook	waitunti.cc	/^void WaitUntilList::WU_hook() { \/\/ get ptr to next process in WUlist or 0$/;"	f	class:simlib3::WaitUntilList	signature:()
WU_print	waitunti.cc	/^    friend void WU_print();$/;"	p	class:simlib3::WaitUntilList	file:	access:friend	signature:()
WU_print	waitunti.cc	/^    void WU_print() {$/;"	f	namespace:simlib3	signature:()
Wait	barrier.cc	/^bool Barrier::Wait()$/;"	f	class:simlib3::Barrier	signature:()
Wait	process.cc	/^void Process::Wait(double dtime)$/;"	f	class:simlib3::Process	signature:(double dtime)
Wait	simlib.h	/^  virtual bool Wait();                  \/\/!< wait for barrier break (Current)$/;"	p	class:simlib3::Barrier	access:public	signature:()
Wait	simlib.h	/^  virtual void Wait(double dtime);      \/\/!< wait for dtime interval$/;"	p	class:simlib3::Process	access:public	signature:(double dtime)
WaitUntil	simlib.h	462;"	d
WaitUntilList	waitunti.cc	/^    WaitUntilList() { Dprintf(("WaitUntilList::WaitUntilList()")); }$/;"	f	class:simlib3::WaitUntilList	file:	access:private	signature:()
WaitUntilList	waitunti.cc	/^class WaitUntilList {$/;"	c	namespace:simlib3	file:
Weibul	random2.cc	/^double Weibul(double lambda, double alfa)$/;"	f	namespace:simlib3	signature:(double lambda, double alfa)
Weibul	simlib.h	/^double Weibul(double lambda, double alfa);$/;"	p	namespace:simlib3	signature:(double lambda, double alfa)
WeibullError	errors.h	/^\/* 42 *\/ WeibullError,$/;"	e	enum:_ErrEnum
Where	simlib.h	/^  List *Where() { return head; }       \/\/!< where is linked$/;"	f	class:simlib3::Link	access:public	signature:()
WhichPart	simlib2D.cc	/^  enum WhichPart { x,y }; \/\/ part identification$/;"	g	class:simlib3::_XYpart	file:	access:public
WhichPart	simlib3D.cc	/^  enum WhichPart { x,y,z }; \/\/ part identification$/;"	g	class:simlib3::_XYZpart	file:	access:public
Xpart	simlib2D.cc	/^Input Xpart(Input2D a) { return new _XYpart(a, _XYpart::x); }$/;"	f	namespace:simlib3	signature:(Input2D a)
Xpart	simlib2D.h	/^Input Xpart(Input2D a);$/;"	p	namespace:simlib3	signature:(Input2D a)
Xpart	simlib3D.cc	/^Input Xpart(Input3D a) { return new _XYZpart(a, _XYZpart::x); }$/;"	f	namespace:simlib3	signature:(Input3D a)
Xpart	simlib3D.h	/^Input Xpart(Input3D a);$/;"	p	namespace:simlib3	signature:(Input3D a)
Y1	ni_fw.h	/^  Memory Y1, ERR;  \/\/ auxiliary memories$/;"	m	class:simlib3::FW	access:private
Ypart	simlib2D.cc	/^Input Ypart(Input2D a) { return new _XYpart(a, _XYpart::y); }$/;"	f	namespace:simlib3	signature:(Input2D a)
Ypart	simlib2D.h	/^Input Ypart(Input2D a);$/;"	p	namespace:simlib3	signature:(Input2D a)
Ypart	simlib3D.cc	/^Input Ypart(Input3D a) { return new _XYZpart(a, _XYZpart::y); }$/;"	f	namespace:simlib3	signature:(Input3D a)
Ypart	simlib3D.h	/^Input Ypart(Input3D a);$/;"	p	namespace:simlib3	signature:(Input3D a)
Z	ni_abm4.h	/^  Memory Z[abm_ord];  \/\/ auxiliary memories$/;"	m	class:simlib3::ABM4	access:private
ZDelay	zdelay.cc	/^ZDelay::ZDelay( Input i, double ival ) :$/;"	f	class:simlib3::ZDelay	signature:( Input i, double ival )
ZDelay	zdelay.cc	/^ZDelay::ZDelay(Input i, ZDelayTimer *p, double ival) :$/;"	f	class:simlib3::ZDelay	signature:(Input i, ZDelayTimer *p, double ival)
ZDelay	zdelay.h	/^    ZDelay( Input i, ZDelayTimer * clock = default_clock, double initvalue = 0 );$/;"	p	class:simlib3::ZDelay	access:public	signature:( Input i, ZDelayTimer * clock = default_clock, double initvalue = 0 )
ZDelay	zdelay.h	/^    ZDelay( Input i, double initvalue );$/;"	p	class:simlib3::ZDelay	access:public	signature:( Input i, double initvalue )
ZDelay	zdelay.h	/^    ZDelay(const ZDelay&);              \/\/ disable copy ctor$/;"	p	class:simlib3::ZDelay	access:private	signature:(const ZDelay&)
ZDelay	zdelay.h	/^class ZDelay : public aContiBlock1 {$/;"	c	namespace:simlib3	inherits:aContiBlock1
ZDelayContainer	zdelay.cc	/^        ZDelayContainer(): c() {}$/;"	f	class:simlib3::ZDelayTimer::ZDelayContainer	access:public	signature:()
ZDelayContainer	zdelay.cc	/^class ZDelayTimer::ZDelayContainer { \/\/ implementation-defined container$/;"	c	class:simlib3::ZDelayTimer	file:
ZDelayTimer	zdelay.cc	/^ZDelayTimer::ZDelayTimer(double step, bool is_default) :$/;"	f	class:simlib3::ZDelayTimer	signature:(double step, bool is_default)
ZDelayTimer	zdelay.h	/^    ZDelayTimer(const ZDelayTimer&); \/\/ ##$/;"	p	class:simlib3::ZDelayTimer	access:private	signature:(const ZDelayTimer&)
ZDelayTimer	zdelay.h	/^    ZDelayTimer(double dt, bool is_default = false);$/;"	p	class:simlib3::ZDelayTimer	access:public	signature:(double dt, bool is_default = false)
ZDelayTimer	zdelay.h	/^class ZDelayTimer : public Event {$/;"	c	namespace:simlib3	inherits:Event
Zpart	simlib3D.cc	/^Input Zpart(Input3D a) { return new _XYZpart(a, _XYZpart::z); }$/;"	f	namespace:simlib3	signature:(Input3D a)
Zpart	simlib3D.h	/^Input Zpart(Input3D a);$/;"	p	namespace:simlib3	signature:(Input3D a)
_ABORT_TXT	error.cc	33;"	d	file:
_ALLOCATED_FLAG	simlib.h	/^  enum _Flags { _ALLOCATED_FLAG = 1, _EVAL_FLAG = 2 }; \/\/!< internal flags$/;"	e	enum:simlib3::SimObject::_Flags
_Abs2D	simlib2D.cc	/^  _Abs2D(Input2D a): in(a) {}$/;"	f	class:simlib3::_Abs2D	access:public	signature:(Input2D a)
_Abs2D	simlib2D.cc	/^class _Abs2D: public aContiBlock {$/;"	c	namespace:simlib3	file:	inherits:aContiBlock
_Abs3D	simlib3D.cc	/^  _Abs3D(Input3D a): in(a) {}$/;"	f	class:simlib3::_Abs3D	access:public	signature:(Input3D a)
_Abs3D	simlib3D.cc	/^class _Abs3D: public aContiBlock {$/;"	c	namespace:simlib3	file:	inherits:aContiBlock
_Add	continuous.cc	/^  _Add(Input a, Input b): aContiBlock2(a,b) {$/;"	f	class:simlib3::_Add	access:public	signature:(Input a, Input b)
_Add	continuous.cc	/^class _Add : public aContiBlock2 {$/;"	c	namespace:simlib3	file:	inherits:aContiBlock2
_Add2D	simlib2D.cc	/^  _Add2D(Input2D a, Input2D b): aContiBlock2D2(a,b) {$/;"	f	class:simlib3::_Add2D	access:public	signature:(Input2D a, Input2D b)
_Add2D	simlib2D.cc	/^class _Add2D : public aContiBlock2D2 {$/;"	c	namespace:simlib3	file:	inherits:aContiBlock2D2
_Add3D	simlib3D.cc	/^  _Add3D(Input3D a, Input3D b): aContiBlock3D2(a,b) {$/;"	f	class:simlib3::_Add3D	access:public	signature:(Input3D a, Input3D b)
_Add3D	simlib3D.cc	/^class _Add3D : public aContiBlock3D2 {$/;"	c	namespace:simlib3	file:	inherits:aContiBlock3D2
_Div	continuous.cc	/^  _Div(Input a, Input b): aContiBlock2(a,b) {$/;"	f	class:simlib3::_Div	access:public	signature:(Input a, Input b)
_Div	continuous.cc	/^class _Div : public aContiBlock2 {$/;"	c	namespace:simlib3	file:	inherits:aContiBlock2
_Div2D	simlib2D.cc	/^  _Div2D(Input2D a, Input b): aContiBlock2D1(a), _b(b) {$/;"	f	class:simlib3::_Div2D	access:public	signature:(Input2D a, Input b)
_Div2D	simlib2D.cc	/^class _Div2D : public aContiBlock2D1 {$/;"	c	namespace:simlib3	file:	inherits:aContiBlock2D1
_Div3D	simlib3D.cc	/^  _Div3D(Input3D a, Input b): aContiBlock3D1(a), _b(b) {$/;"	f	class:simlib3::_Div3D	access:public	signature:(Input3D a, Input b)
_Div3D	simlib3D.cc	/^class _Div3D : public aContiBlock3D1 {$/;"	c	namespace:simlib3	file:	inherits:aContiBlock3D1
_ERR_TXT	error.cc	31;"	d	file:
_EVAL_FLAG	simlib.h	/^  enum _Flags { _ALLOCATED_FLAG = 1, _EVAL_FLAG = 2 }; \/\/!< internal flags$/;"	e	enum:simlib3::SimObject::_Flags
_ErrEnum	errors.h	/^enum _ErrEnum {$/;"	g
_ErrMsg	errors.cc	/^char *_ErrMsg(enum _ErrEnum N)$/;"	f	namespace:simlib3	signature:(enum _ErrEnum N)
_ErrMsg	errors.h	/^extern char *_ErrMsg(enum _ErrEnum N);$/;"	p	signature:(enum _ErrEnum N)
_Errors	errors.cc	/^static char _Errors[] = {$/;"	m	namespace:simlib3	file:
_Errors	generr.c	/^static char _Errors[] = {$/;"	v	file:
_Eval	continuous.cc	/^  virtual void _Eval() {}$/;"	f	class:simlib3::_Add	file:	access:private	signature:()
_Eval	continuous.cc	/^  virtual void _Eval() {}$/;"	f	class:simlib3::_Div	file:	access:private	signature:()
_Eval	continuous.cc	/^  virtual void _Eval() {}$/;"	f	class:simlib3::_Mul	file:	access:private	signature:()
_Eval	continuous.cc	/^  virtual void _Eval() {}$/;"	f	class:simlib3::_Sub	file:	access:private	signature:()
_Eval	continuous.cc	/^  virtual void _Eval() {}$/;"	f	class:simlib3::_UMinus	file:	access:private	signature:()
_Eval	continuous.cc	/^void aContiBlock::_Eval()$/;"	f	class:simlib3::aContiBlock	signature:()
_Eval	simlib.h	/^    virtual void _Eval();       \/\/!< evaluate block (with loop detection)$/;"	p	class:simlib3::aContiBlock	access:public	signature:()
_Eval	simlib.h	/^  virtual void _Eval();           \/\/ evaluation with loop check$/;"	p	class:simlib3::Frict	access:public	signature:()
_Eval	simlib.h	/^  virtual void _Eval();           \/\/ evaluation with loop check$/;"	p	class:simlib3::Insv	access:public	signature:()
_Eval	simlib.h	/^  virtual void _Eval();           \/\/ evaluation with loop check$/;"	p	class:simlib3::Lim	access:public	signature:()
_Eval	simlib.h	/^  virtual void _Eval();           \/\/ evaluation with loop check$/;"	p	class:simlib3::Qntzr	access:public	signature:()
_Eval	simlib.h	/^  virtual void _Eval();           \/\/ evaluation with loop check$/;"	p	class:simlib3::Rline	access:public	signature:()
_Eval	simlib2D.cc	/^  virtual void _Eval() {}$/;"	f	class:simlib3::_Abs2D	file:	access:private	signature:()
_Eval	simlib2D.cc	/^  virtual void _Eval() {}$/;"	f	class:simlib3::_Add2D	file:	access:private	signature:()
_Eval	simlib2D.cc	/^  virtual void _Eval() {}$/;"	f	class:simlib3::_Div2D	file:	access:private	signature:()
_Eval	simlib2D.cc	/^  virtual void _Eval() {}$/;"	f	class:simlib3::_Mul2D1D	file:	access:private	signature:()
_Eval	simlib2D.cc	/^  virtual void _Eval() {}$/;"	f	class:simlib3::_Norm2D	file:	access:private	signature:()
_Eval	simlib2D.cc	/^  virtual void _Eval() {}$/;"	f	class:simlib3::_ScalarProduct2D	file:	access:private	signature:()
_Eval	simlib2D.cc	/^  virtual void _Eval() {}$/;"	f	class:simlib3::_Sub2D	file:	access:private	signature:()
_Eval	simlib2D.cc	/^  virtual void _Eval() {}$/;"	f	class:simlib3::_UMinus2D	file:	access:private	signature:()
_Eval	simlib2D.cc	/^  virtual void _Eval() {}$/;"	f	class:simlib3::_XYpart	file:	access:private	signature:()
_Eval	simlib2D.cc	/^void aContiBlock2D::_Eval()$/;"	f	class:simlib3::aContiBlock2D	signature:()
_Eval	simlib2D.h	/^  virtual void _Eval();              \/\/ evaluate with loop detection$/;"	p	class:simlib3::aContiBlock2D	access:public	signature:()
_Eval	simlib3D.cc	/^  virtual void _Eval() {}$/;"	f	class:simlib3::_Abs3D	file:	access:private	signature:()
_Eval	simlib3D.cc	/^  virtual void _Eval() {}$/;"	f	class:simlib3::_Add3D	file:	access:private	signature:()
_Eval	simlib3D.cc	/^  virtual void _Eval() {}$/;"	f	class:simlib3::_Div3D	file:	access:private	signature:()
_Eval	simlib3D.cc	/^  virtual void _Eval() {}$/;"	f	class:simlib3::_Mul3D	file:	access:private	signature:()
_Eval	simlib3D.cc	/^  virtual void _Eval() {}$/;"	f	class:simlib3::_Mul3D1D	file:	access:private	signature:()
_Eval	simlib3D.cc	/^  virtual void _Eval() {}$/;"	f	class:simlib3::_Norm3D	file:	access:private	signature:()
_Eval	simlib3D.cc	/^  virtual void _Eval() {}$/;"	f	class:simlib3::_ScalarProduct3D	file:	access:private	signature:()
_Eval	simlib3D.cc	/^  virtual void _Eval() {}$/;"	f	class:simlib3::_Sub3D	file:	access:private	signature:()
_Eval	simlib3D.cc	/^  virtual void _Eval() {}$/;"	f	class:simlib3::_UMinus3D	file:	access:private	signature:()
_Eval	simlib3D.cc	/^  virtual void _Eval() {}$/;"	f	class:simlib3::_XYZpart	file:	access:private	signature:()
_Eval	simlib3D.cc	/^void aContiBlock3D::_Eval()$/;"	f	class:simlib3::aContiBlock3D	signature:()
_Eval	simlib3D.h	/^  virtual void _Eval();              \/\/ evaluate with loop detection$/;"	p	class:simlib3::aContiBlock3D	access:public	signature:()
_Eval	stdblock.cc	/^void Frict::_Eval()$/;"	f	class:simlib3::Frict	signature:()
_Eval	stdblock.cc	/^void Insv::_Eval()$/;"	f	class:simlib3::Insv	signature:()
_Eval	stdblock.cc	/^void Lim::_Eval()$/;"	f	class:simlib3::Lim	signature:()
_Eval	stdblock.cc	/^void Qntzr::_Eval()$/;"	f	class:simlib3::Qntzr	signature:()
_Eval	stdblock.cc	/^void Rline::_Eval()$/;"	f	class:simlib3::Rline	signature:()
_FileWrap	print.cc	/^class _FileWrap {$/;"	c	namespace:simlib3	file:
_Flags	simlib.h	/^  enum _Flags { _ALLOCATED_FLAG = 1, _EVAL_FLAG = 2 }; \/\/!< internal flags$/;"	g	class:simlib3::SimObject	access:public
_GET_STACK_PTR	process.cc	100;"	d	file:
_GET_STACK_PTR	process.cc	106;"	d	file:
_GET_STACK_PTR	process.cc	77;"	d	file:
_GET_STACK_PTR	process.cc	81;"	d	file:
_GET_STACK_PTR	process.cc	83;"	d	file:
_GET_STACK_PTR	process.cc	95;"	d	file:
_GraphInit	graph.cc	/^void _GraphInit()$/;"	f	namespace:simlib3	signature:()
_INTERRUPTED	simlib.h	/^      _PREPARED=1, _RUNNING, _INTERRUPTED, _TERMINATED$/;"	e	enum:simlib3::Process::ProcessStatus_t
_INT_ERR_TXT	error.cc	32;"	d	file:
_Ident	simlib.h	/^    unsigned long _Ident;           \/\/!< unique identification number of entity$/;"	m	class:simlib3::Entity	access:protected
_MarkTime	simlib.h	/^    double _MarkTime;               \/\/ beginning of waiting in queue ###!!!$/;"	m	class:simlib3::Entity	access:protected
_Mul	continuous.cc	/^  _Mul(Input a, Input b): aContiBlock2(a,b) {$/;"	f	class:simlib3::_Mul	access:public	signature:(Input a, Input b)
_Mul	continuous.cc	/^class _Mul : public aContiBlock2 {$/;"	c	namespace:simlib3	file:	inherits:aContiBlock2
_Mul2D1D	simlib2D.cc	/^  _Mul2D1D(Input2D a, Input b): aContiBlock2D1(a), _b(b) {$/;"	f	class:simlib3::_Mul2D1D	access:public	signature:(Input2D a, Input b)
_Mul2D1D	simlib2D.cc	/^class _Mul2D1D : public aContiBlock2D1 {$/;"	c	namespace:simlib3	file:	inherits:aContiBlock2D1
_Mul3D	simlib3D.cc	/^  _Mul3D(Input3D a, Input3D b): aContiBlock3D2(a,b) {$/;"	f	class:simlib3::_Mul3D	access:public	signature:(Input3D a, Input3D b)
_Mul3D	simlib3D.cc	/^class _Mul3D : public aContiBlock3D2 {$/;"	c	namespace:simlib3	file:	inherits:aContiBlock3D2
_Mul3D1D	simlib3D.cc	/^  _Mul3D1D(Input3D a, Input b): aContiBlock3D1(a), _b(b) {$/;"	f	class:simlib3::_Mul3D1D	access:public	signature:(Input3D a, Input b)
_Mul3D1D	simlib3D.cc	/^class _Mul3D1D : public aContiBlock3D1 {$/;"	c	namespace:simlib3	file:	inherits:aContiBlock3D1
_Norm2D	simlib2D.cc	/^  _Norm2D(Input2D a): aContiBlock2D1(a) {}$/;"	f	class:simlib3::_Norm2D	access:public	signature:(Input2D a)
_Norm2D	simlib2D.cc	/^class _Norm2D: public aContiBlock2D1 {$/;"	c	namespace:simlib3	file:	inherits:aContiBlock2D1
_Norm3D	simlib3D.cc	/^  _Norm3D(Input3D a): aContiBlock3D1(a) {}$/;"	f	class:simlib3::_Norm3D	access:public	signature:(Input3D a)
_Norm3D	simlib3D.cc	/^class _Norm3D: public aContiBlock3D1 {$/;"	c	namespace:simlib3	file:	inherits:aContiBlock3D1
_Number	entity.cc	/^unsigned long Entity::_Number = 0L;     \/\/ # of entity creations$/;"	m	class:simlib3::Entity	file:
_Number	simlib.h	/^    static unsigned long _Number;   \/\/!< current number of entities$/;"	m	class:simlib3::Entity	access:protected
_OWNQ	store.cc	31;"	d	file:
_OWNQ1	facility.cc	30;"	d	file:
_PREPARED	simlib.h	/^      _PREPARED=1, _RUNNING, _INTERRUPTED, _TERMINATED$/;"	e	enum:simlib3::Process::ProcessStatus_t
_Print	print.cc	/^int _Print(const char *fmt, ...)$/;"	f	namespace:simlib3	signature:(const char *fmt, ...)
_Print	simlib.h	/^int  _Print(const char *fmt, ...);$/;"	p	namespace:simlib3	signature:(const char *fmt, ...)
_ProcessDispatcherStatusBuffer	process.cc	/^static jmp_buf _ProcessDispatcherStatusBuffer;  \/\/ stack state before dispatch$/;"	m	namespace:simlib3	file:
_Qflag	simlib.h	/^  unsigned char _Qflag;$/;"	m	class:simlib3::Facility	access:private
_Qflag	simlib.h	/^  unsigned char _Qflag;$/;"	m	class:simlib3::Store	access:private
_RUNNING	simlib.h	/^      _PREPARED=1, _RUNNING, _INTERRUPTED, _TERMINATED$/;"	e	enum:simlib3::Process::ProcessStatus_t
_RemainingTime	simlib.h	/^        double _RemainingTime; \/\/ rest of time of interrupted service (Facility) ###$/;"	m	union:simlib3::Entity::__anon2	access:public
_RequiredCapacity	simlib.h	/^        unsigned long _RequiredCapacity; \/\/ required store capacity of Store$/;"	m	union:simlib3::Entity::__anon2	access:public
_Run	event.cc	/^void Event::_Run() throw()$/;"	f	class:simlib3::Event	signature:()
_Run	process.cc	/^void Process::_Run() throw() \/\/ no exceptions$/;"	f	class:simlib3::Process	signature:()
_Run	simlib.h	/^    virtual void _Run() throw() = 0;    \/\/!< run the Behavior() function$/;"	p	class:simlib3::Entity	access:private	signature:()
_Run	simlib.h	/^  virtual void _Run() throw();          \/\/ internal point of activation$/;"	p	class:simlib3::Process	access:private	signature:()
_Run	simlib.h	/^  virtual void _Run() throw();$/;"	p	class:simlib3::Event	access:private	signature:()
_SET_STACK_PTR	process.cc	101;"	d	file:
_SET_STACK_PTR	process.cc	107;"	d	file:
_SET_STACK_PTR	process.cc	78;"	d	file:
_SET_STACK_PTR	process.cc	85;"	d	file:
_SET_STACK_PTR	process.cc	96;"	d	file:
_SPrio	simlib.h	/^    ServicePriority_t _SPrio;           \/\/!< priority of service in Facility$/;"	m	class:simlib3::Entity	access:protected
_ScalarProduct2D	simlib2D.cc	/^  _ScalarProduct2D(Input2D a, Input2D b): input1(a), input2(b) {}$/;"	f	class:simlib3::_ScalarProduct2D	access:public	signature:(Input2D a, Input2D b)
_ScalarProduct2D	simlib2D.cc	/^class _ScalarProduct2D: public aContiBlock {$/;"	c	namespace:simlib3	file:	inherits:aContiBlock
_ScalarProduct3D	simlib3D.cc	/^  _ScalarProduct3D(Input3D a, Input3D b): input1(a), input2(b) {}$/;"	f	class:simlib3::_ScalarProduct3D	access:public	signature:(Input3D a, Input3D b)
_ScalarProduct3D	simlib3D.cc	/^class _ScalarProduct3D: public aContiBlock {$/;"	c	namespace:simlib3	file:	inherits:aContiBlock
_SetTime	internal.h	212;"	d
_StackBase	process.cc	/^static char *volatile _StackBase = 0;    \/\/ start of stack data area$/;"	m	namespace:simlib3	file:
_StackBase2	process.cc	/^static char *volatile _StackBase2 = 0;   \/\/ CHECKING start of stack data area$/;"	m	namespace:simlib3	file:
_StackSize	process.cc	/^static volatile size_t _StackSize = 0;   \/\/ temporary - global stack size$/;"	m	namespace:simlib3	file:
_Sub	continuous.cc	/^  _Sub(Input a, Input b): aContiBlock2(a,b) {$/;"	f	class:simlib3::_Sub	access:public	signature:(Input a, Input b)
_Sub	continuous.cc	/^class _Sub : public aContiBlock2 {$/;"	c	namespace:simlib3	file:	inherits:aContiBlock2
_Sub2D	simlib2D.cc	/^  _Sub2D(Input2D a, Input2D b): aContiBlock2D2(a,b) {$/;"	f	class:simlib3::_Sub2D	access:public	signature:(Input2D a, Input2D b)
_Sub2D	simlib2D.cc	/^class _Sub2D : public aContiBlock2D2 {$/;"	c	namespace:simlib3	file:	inherits:aContiBlock2D2
_Sub3D	simlib3D.cc	/^  _Sub3D(Input3D a, Input3D b): aContiBlock3D2(a,b) {$/;"	f	class:simlib3::_Sub3D	access:public	signature:(Input3D a, Input3D b)
_Sub3D	simlib3D.cc	/^class _Sub3D : public aContiBlock3D2 {$/;"	c	namespace:simlib3	file:	inherits:aContiBlock3D2
_T	continuous.cc	/^static class _Time _T;$/;"	m	namespace:simlib3	typeref:class:simlib3::_Time	file:
_TERMINATED	simlib.h	/^      _PREPARED=1, _RUNNING, _INTERRUPTED, _TERMINATED$/;"	e	enum:simlib3::Process::ProcessStatus_t
_Time	continuous.cc	/^  _Time() {}$/;"	f	class:simlib3::_Time	access:public	signature:()
_Time	continuous.cc	/^class _Time: public aContiBlock {$/;"	c	namespace:simlib3	file:	inherits:aContiBlock
_UMinus	continuous.cc	/^  _UMinus(Input a): aContiBlock1(a) {$/;"	f	class:simlib3::_UMinus	access:public	signature:(Input a)
_UMinus	continuous.cc	/^class _UMinus: public aContiBlock1 {$/;"	c	namespace:simlib3	file:	inherits:aContiBlock1
_UMinus2D	simlib2D.cc	/^  _UMinus2D(Input2D a): aContiBlock2D1(a) {$/;"	f	class:simlib3::_UMinus2D	access:public	signature:(Input2D a)
_UMinus2D	simlib2D.cc	/^class _UMinus2D: public aContiBlock2D1 {$/;"	c	namespace:simlib3	file:	inherits:aContiBlock2D1
_UMinus3D	simlib3D.cc	/^  _UMinus3D(Input3D a): aContiBlock3D1(a) {$/;"	f	class:simlib3::_UMinus3D	access:public	signature:(Input3D a)
_UMinus3D	simlib3D.cc	/^class _UMinus3D: public aContiBlock3D1 {$/;"	c	namespace:simlib3	file:	inherits:aContiBlock3D1
_WARNING_TXT	error.cc	34;"	d	file:
_WaitUntil	simlib.h	/^  bool  _WaitUntil(bool test);          \/\/!< wait for condition (slow!)$/;"	p	class:simlib3::Process	access:public	signature:(bool test)
_WaitUntil	waitunti.cc	/^bool Process::_WaitUntil(bool test)$/;"	f	class:simlib3::Process	signature:(bool test)
_WaitUntilRemove	simlib.h	/^  void _WaitUntilRemove();$/;"	p	class:simlib3::Process	access:private	signature:()
_WaitUntilRemove	waitunti.cc	/^void Process::_WaitUntilRemove() {$/;"	f	class:simlib3::Process	signature:()
_XYZpart	simlib3D.cc	/^  _XYZpart(Input3D a, WhichPart w): input(a), which(w) {}$/;"	f	class:simlib3::_XYZpart	access:public	signature:(Input3D a, WhichPart w)
_XYZpart	simlib3D.cc	/^class _XYZpart: public aContiBlock {$/;"	c	namespace:simlib3	file:	inherits:aContiBlock
_XYpart	simlib2D.cc	/^  _XYpart(Input2D a, WhichPart w): input(a), which(w) {}$/;"	f	class:simlib3::_XYpart	access:public	signature:(Input2D a, WhichPart w)
_XYpart	simlib2D.cc	/^class _XYpart: public aContiBlock {$/;"	c	namespace:simlib3	file:	inherits:aContiBlock
__SIMLIB2D_H	simlib2D.h	17;"	d
__SIMLIB3D_H	simlib3D.h	17;"	d
__SIMLIB_OPTIMIZE_H	optimize.h	13;"	d
__SIMLIB__	simlib.h	8;"	d
__SIMLIB__INTERNAL_H__	internal.h	35;"	d
__anon3::NumErr	generr.c	/^    unsigned NumErr;$/;"	m	struct:__anon3	file:	access:public
__anon3::Table	generr.c	/^    struct tabitem Table[MAXERR];$/;"	m	struct:__anon3	typeref:struct:__anon3::tabitem	file:	access:public
__anon4::OP_ESTIMATE	calendar.cc	/^    OP_ESTIMATE=2,$/;"	e	enum:__anon4::__anon5	file:
__anon4::OP_MEASURE	calendar.cc	/^int OP_MEASURE = 0;$/;"	m	namespace:__anon4	file:
__anon4::OP_RESIZE	calendar.cc	/^    OP_RESIZE=1,$/;"	e	enum:__anon4::__anon5	file:
__anon4::OP_SWITCH2CQ	calendar.cc	/^    OP_SWITCH2CQ=4,$/;"	e	enum:__anon4::__anon5	file:
__anon4::OP_SWITCH2LIST	calendar.cc	/^    OP_SWITCH2LIST=8,$/;"	e	enum:__anon4::__anon5	file:
__anon4::START_T	calendar.cc	/^inline void START_T() {$/;"	f	namespace:__anon4	signature:()
__anon4::STOP_T	calendar.cc	/^inline double STOP_T() {$/;"	f	namespace:__anon4	signature:()
__anon4::T_MEASURE	calendar.cc	/^static unsigned long long T_MEASURE;$/;"	m	namespace:__anon4	file:
_b	simlib2D.cc	/^  Input _b;$/;"	m	class:simlib3::_Div2D	file:	access:private
_b	simlib2D.cc	/^  Input _b;$/;"	m	class:simlib3::_Mul2D1D	file:	access:private
_b	simlib3D.cc	/^  Input _b;$/;"	m	class:simlib3::_Div3D	file:	access:private
_b	simlib3D.cc	/^  Input _b;$/;"	m	class:simlib3::_Mul3D1D	file:	access:private
_context	simlib.h	/^  void * _context;                      \/\/!< process context pointer$/;"	m	class:simlib3::Process	access:private
_evn	simlib.h	/^    EventNotice *_evn;                  \/\/!< points to calendar item, iff scheduled$/;"	m	class:simlib3::Entity	access:private
_flags	simlib.h	/^  unsigned     _flags;$/;"	m	class:simlib3::SimObject	access:protected
_gam	random2.cc	/^static double _gam(double AK)$/;"	f	namespace:simlib3	signature:(double AK)
_instance	calendar.cc	/^    static Calendar * _instance;        \/\/!< pointer to single instance$/;"	m	class:simlib3::Calendar	file:	access:private
_instance	calendar.cc	/^Calendar * Calendar::_instance = 0;$/;"	m	class:simlib3::Calendar	file:
_name	simlib.h	/^  const char * _name;$/;"	m	class:simlib3::SimObject	access:protected
_size	calendar.cc	/^    unsigned _size;     \/\/!< number of scheduled items$/;"	m	class:simlib3::Calendar	file:	access:protected
_status	simlib.h	/^  } _status;$/;"	m	class:simlib3::Process	typeref:enum:simlib3::Process::ProcessStatus_t	access:private
_wait_until	simlib.h	/^  bool _wait_until;                     \/\/ waiting for condition$/;"	m	class:simlib3::Process	access:private
_x	simlib2D.h	/^  Integrator _x,_y;          \/\/ 1D standard integrators$/;"	m	class:simlib3::Integrator2D	access:private
_x	simlib2D.h	/^  double _x, _y;$/;"	m	class:simlib3::Value2D	access:private
_x	simlib3D.h	/^  Integrator _x,_y,_z;          \/\/ 1D standard integrators$/;"	m	class:simlib3::Integrator3D	access:private
_x	simlib3D.h	/^  double _x, _y, _z;$/;"	m	class:simlib3::Value3D	access:private
_y	simlib2D.h	/^  Integrator _x,_y;          \/\/ 1D standard integrators$/;"	m	class:simlib3::Integrator2D	access:private
_y	simlib2D.h	/^  double _x, _y;$/;"	m	class:simlib3::Value2D	access:private
_y	simlib3D.h	/^  Integrator _x,_y,_z;          \/\/ 1D standard integrators$/;"	m	class:simlib3::Integrator3D	access:private
_y	simlib3D.h	/^  double _x, _y, _z;$/;"	m	class:simlib3::Value3D	access:private
_z	simlib3D.h	/^  Integrator _x,_y,_z;          \/\/ 1D standard integrators$/;"	m	class:simlib3::Integrator3D	access:private
_z	simlib3D.h	/^  double _x, _y, _z;$/;"	m	class:simlib3::Value3D	access:private
a	simlib2D.h	/^    Value2D a;                  \/\/ temporary value$/;"	m	class:simlib3::Integrator2D::special_input	access:private
a	simlib3D.h	/^    Value3D a;                  \/\/ temporary value$/;"	m	class:simlib3::Integrator3D::special_input	access:private
aBlock	simlib.h	/^class aBlock : public SimObject {                \/\/ base class$/;"	c	namespace:simlib3	inherits:SimObject
aCondition	cond.cc	/^aCondition::aCondition() :$/;"	f	class:simlib3::aCondition	signature:()
aCondition	simlib.h	/^  aCondition();$/;"	p	class:simlib3::aCondition	access:public	signature:()
aCondition	simlib.h	/^  aCondition(aCondition&);             \/\/ disable operation$/;"	p	class:simlib3::aCondition	access:private	signature:(aCondition&)
aCondition	simlib.h	/^class aCondition : public aBlock {$/;"	c	namespace:simlib3	inherits:aBlock
aContiBlock	simlib.h	/^    aContiBlock(): isEvaluated(false) {}$/;"	f	class:simlib3::aContiBlock	access:public	signature:()
aContiBlock	simlib.h	/^    aContiBlock(const aContiBlock&);            \/\/ disable copy ctr$/;"	p	class:simlib3::aContiBlock	access:private	signature:(const aContiBlock&)
aContiBlock	simlib.h	/^class aContiBlock : public aBlock {$/;"	c	namespace:simlib3	inherits:aBlock
aContiBlock1	continuous.cc	/^aContiBlock1::aContiBlock1(Input i) : input(i)$/;"	f	class:simlib3::aContiBlock1	signature:(Input i)
aContiBlock1	simlib.h	/^  aContiBlock1(Input i);$/;"	p	class:simlib3::aContiBlock1	access:public	signature:(Input i)
aContiBlock1	simlib.h	/^class aContiBlock1 : public aContiBlock {$/;"	c	namespace:simlib3	inherits:aContiBlock
aContiBlock2	continuous.cc	/^aContiBlock2::aContiBlock2(Input i1, Input i2) : input1(i1), input2(i2)$/;"	f	class:simlib3::aContiBlock2	signature:(Input i1, Input i2)
aContiBlock2	simlib.h	/^  aContiBlock2(Input i1, Input i2);$/;"	p	class:simlib3::aContiBlock2	access:public	signature:(Input i1, Input i2)
aContiBlock2	simlib.h	/^class aContiBlock2 : public aContiBlock {$/;"	c	namespace:simlib3	inherits:aContiBlock
aContiBlock2D	simlib2D.cc	/^aContiBlock2D::aContiBlock2D():$/;"	f	class:simlib3::aContiBlock2D	signature:()
aContiBlock2D	simlib2D.h	/^  aContiBlock2D();$/;"	p	class:simlib3::aContiBlock2D	access:public	signature:()
aContiBlock2D	simlib2D.h	/^  aContiBlock2D(const aContiBlock2D&); \/\/ disable copy ctr$/;"	p	class:simlib3::aContiBlock2D	access:private	signature:(const aContiBlock2D&)
aContiBlock2D	simlib2D.h	/^class aContiBlock2D : public aBlock {  \/\/ abstract continuous block$/;"	c	namespace:simlib3	inherits:aBlock
aContiBlock2D1	simlib2D.cc	/^aContiBlock2D1::aContiBlock2D1(Input2D i) : input(i)$/;"	f	class:simlib3::aContiBlock2D1	signature:(Input2D i)
aContiBlock2D1	simlib2D.h	/^  explicit aContiBlock2D1(Input2D i);$/;"	p	class:simlib3::aContiBlock2D1	access:public	signature:(Input2D i)
aContiBlock2D1	simlib2D.h	/^class aContiBlock2D1 : public aContiBlock2D {$/;"	c	namespace:simlib3	inherits:aContiBlock2D
aContiBlock2D2	simlib2D.cc	/^aContiBlock2D2::aContiBlock2D2(Input2D i1, Input2D i2)$/;"	f	class:simlib3::aContiBlock2D2	signature:(Input2D i1, Input2D i2)
aContiBlock2D2	simlib2D.h	/^  aContiBlock2D2(Input2D i1, Input2D i2);$/;"	p	class:simlib3::aContiBlock2D2	access:public	signature:(Input2D i1, Input2D i2)
aContiBlock2D2	simlib2D.h	/^class aContiBlock2D2 : public aContiBlock2D {$/;"	c	namespace:simlib3	inherits:aContiBlock2D
aContiBlock2D3	simlib2D.cc	/^aContiBlock2D3::aContiBlock2D3(Input2D i1, Input2D i2, Input2D i3)$/;"	f	class:simlib3::aContiBlock2D3	signature:(Input2D i1, Input2D i2, Input2D i3)
aContiBlock2D3	simlib2D.h	/^  aContiBlock2D3(Input2D i1, Input2D i2, Input2D i3);$/;"	p	class:simlib3::aContiBlock2D3	access:public	signature:(Input2D i1, Input2D i2, Input2D i3)
aContiBlock2D3	simlib2D.h	/^class aContiBlock2D3 : public aContiBlock2D2 {$/;"	c	namespace:simlib3	inherits:aContiBlock2D2
aContiBlock3	continuous.cc	/^aContiBlock3::aContiBlock3(Input i1, Input i2, Input i3)$/;"	f	class:simlib3::aContiBlock3	signature:(Input i1, Input i2, Input i3)
aContiBlock3	simlib.h	/^  aContiBlock3(Input i1, Input i2, Input i3);$/;"	p	class:simlib3::aContiBlock3	access:public	signature:(Input i1, Input i2, Input i3)
aContiBlock3	simlib.h	/^class aContiBlock3 : public aContiBlock {$/;"	c	namespace:simlib3	inherits:aContiBlock
aContiBlock3D	simlib3D.cc	/^aContiBlock3D::aContiBlock3D():$/;"	f	class:simlib3::aContiBlock3D	signature:()
aContiBlock3D	simlib3D.h	/^  aContiBlock3D();$/;"	p	class:simlib3::aContiBlock3D	access:public	signature:()
aContiBlock3D	simlib3D.h	/^  aContiBlock3D(const aContiBlock3D&); \/\/ disable copy ctr$/;"	p	class:simlib3::aContiBlock3D	access:private	signature:(const aContiBlock3D&)
aContiBlock3D	simlib3D.h	/^class aContiBlock3D : public aBlock {  \/\/ abstract continuous block$/;"	c	namespace:simlib3	inherits:aBlock
aContiBlock3D1	simlib3D.cc	/^aContiBlock3D1::aContiBlock3D1(Input3D i) : input(i)$/;"	f	class:simlib3::aContiBlock3D1	signature:(Input3D i)
aContiBlock3D1	simlib3D.h	/^  explicit aContiBlock3D1(Input3D i);$/;"	p	class:simlib3::aContiBlock3D1	access:public	signature:(Input3D i)
aContiBlock3D1	simlib3D.h	/^class aContiBlock3D1 : public aContiBlock3D {$/;"	c	namespace:simlib3	inherits:aContiBlock3D
aContiBlock3D2	simlib3D.cc	/^aContiBlock3D2::aContiBlock3D2(Input3D i1, Input3D i2)$/;"	f	class:simlib3::aContiBlock3D2	signature:(Input3D i1, Input3D i2)
aContiBlock3D2	simlib3D.h	/^  aContiBlock3D2(Input3D i1, Input3D i2);$/;"	p	class:simlib3::aContiBlock3D2	access:public	signature:(Input3D i1, Input3D i2)
aContiBlock3D2	simlib3D.h	/^class aContiBlock3D2 : public aContiBlock3D {$/;"	c	namespace:simlib3	inherits:aContiBlock3D
aContiBlock3D3	simlib3D.cc	/^aContiBlock3D3::aContiBlock3D3(Input3D i1, Input3D i2, Input3D i3)$/;"	f	class:simlib3::aContiBlock3D3	signature:(Input3D i1, Input3D i2, Input3D i3)
aContiBlock3D3	simlib3D.h	/^  aContiBlock3D3(Input3D i1, Input3D i2, Input3D i3);$/;"	p	class:simlib3::aContiBlock3D3	access:public	signature:(Input3D i1, Input3D i2, Input3D i3)
aContiBlock3D3	simlib3D.h	/^class aContiBlock3D3 : public aContiBlock3D2 {$/;"	c	namespace:simlib3	inherits:aContiBlock3D2
aStat	simlib.h	/^  aStat();$/;"	p	class:simlib3::aStat	access:public	signature:()
aStat	simlib.h	/^  aStat(const char *name);$/;"	p	class:simlib3::aStat	access:public	signature:(const char *name)
aStat	simlib.h	/^class aStat : public SimObject {$/;"	c	namespace:simlib3	inherits:SimObject
abm_ord	ni_abm4.h	/^const int abm_ord=4;$/;"	m	namespace:simlib3
abs	simlib2D.cc	/^double abs(const Value2D &a)$/;"	f	namespace:simlib3	signature:(const Value2D &a)
abs	simlib2D.h	/^  friend double abs(const Value2D &a);$/;"	p	class:simlib3::Value2D	access:friend	signature:(const Value2D &a)
abs	simlib3D.cc	/^double abs(const Value3D &a)$/;"	f	namespace:simlib3	signature:(const Value3D &a)
abs	simlib3D.h	/^  friend double abs(const Value3D &a);$/;"	p	class:simlib3::Value3D	access:friend	signature:(const Value3D &a)
accept_bad	opt-simann.cc	/^bool accept_bad(double eps)$/;"	f	namespace:simlib3	signature:(double eps)
alloc	calendar.cc	/^    EventNotice *alloc(Entity *p, double t) {$/;"	f	class:simlib3::EventNoticeAllocator	access:public	signature:(Entity *p, double t)
allocator	calendar.cc	/^} allocator;  \/\/ global allocator TODO: improve -> singleton$/;"	m	namespace:simlib3	typeref:class:simlib3::EventNoticeAllocator	file:
arr	simlib.h	/^      double *arr;  \/\/ array$/;"	m	class:simlib3::IntegrationMethod::Memory	access:private
atexit_array	atexit.cc	/^static SIMLIB_atexit_function_t atexit_array[MAX_ATEXIT] = { 0, };$/;"	m	namespace:simlib3	file:
back	simlib.h	/^    Entity *back()     { return (Entity*)List::back(); }$/;"	f	class:simlib3::Queue	access:public	signature:()
back	simlib.h	/^    Link *back()      { return empty() ? 0 : Link::pred; }$/;"	f	class:simlib3::List	access:public	signature:()
begin	calendar.cc	/^    iterator begin()    { return l.succ; }$/;"	f	class:simlib3::CalendarListImplementation	access:public	signature:()
begin	simlib.h	/^    iterator begin()   { return List::begin(); }$/;"	f	class:simlib3::Queue	access:public	signature:()
begin	simlib.h	/^    iterator begin()  { return Link::succ; }$/;"	f	class:simlib3::List	access:public	signature:()
begin	waitunti.cc	/^    static iterator begin() { return instance->l.begin(); }$/;"	f	class:simlib3::WaitUntilList	access:public	signature:()
begin	zdelay.cc	/^        iterator begin()        { return c.begin(); }$/;"	f	class:simlib3::ZDelayTimer::ZDelayContainer	access:public	signature:()
block	internal.h	/^    aContiBlock *block;$/;"	m	class:simlib3::AlgLoopDetector	access:private
bp	simlib.h	/^  aContiBlock *bp;$/;"	m	class:simlib3::Input	access:private
bp	simlib2D.h	/^  aContiBlock2D *bp;$/;"	m	class:simlib3::Input2D	access:private
bp	simlib3D.h	/^  aContiBlock3D *bp;$/;"	m	class:simlib3::Input3D	access:private
bucket_width	calendar.cc	/^    double bucket_width;    \/\/ parameter: width of each bucket$/;"	m	class:simlib3::CalendarQueue	file:	access:private
buckets	calendar.cc	/^    BucketList *buckets;    \/\/ bucket array$/;"	m	class:simlib3::CalendarQueue	file:	access:private
buckettop	calendar.cc	/^    double buckettop;       \/\/ top time of current bucket$/;"	m	class:simlib3::CalendarQueue	file:	access:private
buf	delay.cc	/^    std::deque<Pair> buf;       \/\/!< storage for samples$/;"	m	class:simlib3::SIMLIB_DelayBuffer	file:	access:private
buffer	delay.h	/^    Buffer *buffer;             \/\/!< memory for past values$/;"	m	class:simlib3::Delay	access:protected
c	zdelay.cc	/^        container_t c;$/;"	m	class:simlib3::ZDelayTimer::ZDelayContainer	file:	access:private
c	zdelay.h	/^    ZDelayContainer *c;$/;"	m	class:simlib3::ZDelayTimer	access:private
cal_cost_flag	calendar.cc	/^int      cal_cost_flag;$/;"	m	namespace:simlib3	file:
cal_cost_op	calendar.cc	/^const char * cal_cost_op;$/;"	m	namespace:simlib3	file:
cal_cost_size	calendar.cc	/^unsigned cal_cost_size;$/;"	m	namespace:simlib3	file:
cal_cost_time	calendar.cc	/^double   cal_cost_time;$/;"	m	namespace:simlib3	file:
capacity	simlib.h	/^  unsigned long capacity;        \/\/ capacity of store$/;"	m	class:simlib3::Store	access:private
cc	simlib.h	/^  unsigned char cc;                    \/\/ state$/;"	m	class:simlib3::Condition	access:private
ccl	simlib.h	/^  unsigned char ccl;                   \/\/ old state$/;"	m	class:simlib3::Condition	access:private
clear	calendar.cc	/^    virtual void clear(bool destroy=false); \/\/ remove\/destroy all items$/;"	p	class:simlib3::CalendarList	file:	access:public	signature:(bool destroy=false)
clear	calendar.cc	/^    virtual void clear(bool destroy=false); \/\/ remove\/destroy all items$/;"	p	class:simlib3::CalendarQueue	file:	access:public	signature:(bool destroy=false)
clear	calendar.cc	/^    virtual void clear(bool destroy_entities=false) = 0;$/;"	p	class:simlib3::Calendar	file:	access:public	signature:(bool destroy_entities=false)
clear	calendar.cc	/^    void clear() {$/;"	f	class:simlib3::EventNoticeAllocator	access:public	signature:()
clear	calendar.cc	/^    void clear(bool destroy) {$/;"	f	class:simlib3::CalendarListImplementation	access:public	signature:(bool destroy)
clear	calendar.cc	/^void CalendarList::clear(bool destroy)$/;"	f	class:simlib3::CalendarList	signature:(bool destroy)
clear	calendar.cc	/^void CalendarQueue::clear(bool destroy)$/;"	f	class:simlib3::CalendarQueue	signature:(bool destroy)
clear	delay.cc	/^    virtual void clear() = 0;                   \/\/!< initialize buffer$/;"	p	struct:simlib3::Delay::Buffer	file:	access:public	signature:()
clear	delay.cc	/^    virtual void clear() {$/;"	f	class:simlib3::SIMLIB_DelayBuffer	access:public	signature:()
clear	delay.h	/^        virtual void clear() = 0; \/\/!< initialize buffer$/;"	p	struct:simlib3::Delay::Buffer	access:public	signature:()
clear	list.cc	/^void List::clear()$/;"	f	class:simlib3::List	signature:()
clear	queue.cc	/^void Queue::clear()$/;"	f	class:simlib3::Queue	signature:()
clear	simlib.h	/^    void clear();                       \/\/!< initialize$/;"	p	class:simlib3::Queue	access:public	signature:()
clear	simlib.h	/^    void clear();$/;"	p	class:simlib3::List	access:public	signature:()
clear	waitunti.cc	/^    static void clear();    \/\/ empty$/;"	p	class:simlib3::WaitUntilList	file:	access:public	signature:()
clear	waitunti.cc	/^void WaitUntilList::clear()$/;"	f	class:simlib3::WaitUntilList	signature:()
clear	zdelay.cc	/^        void clear()            { c.clear(); }$/;"	f	class:simlib3::ZDelayTimer::ZDelayContainer	access:public	signature:()
clock	zdelay.h	/^    ZDelayTimer *clock;                 \/\/ timer-event for this block$/;"	m	class:simlib3::ZDelay	access:private
container	zdelay.cc	/^    static container_t *container;      \/\/ list of delay objects -- singleton$/;"	m	class:simlib3::SIMLIB_ZDelayTimer	file:	access:private
container	zdelay.cc	/^SIMLIB_ZDelayTimer::container_t * SIMLIB_ZDelayTimer::container = 0;$/;"	m	class:simlib3::SIMLIB_ZDelayTimer	file:
container_t	waitunti.cc	/^    typedef std::list<Process *> container_t;$/;"	t	class:simlib3::WaitUntilList	file:	access:private
container_t	zdelay.cc	/^        typedef std::set<ZDelay*> container_t;$/;"	t	class:simlib3::ZDelayTimer::ZDelayContainer	file:	access:private
container_t	zdelay.cc	/^    typedef std::list<ZDelayTimer *> container_t; \/\/ type of container we use$/;"	t	class:simlib3::SIMLIB_ZDelayTimer	file:	access:private
count	simlib.h	/^  unsigned count;            \/\/ number of intervals$/;"	m	class:simlib3::Histogram	access:protected
count	simlib2D.h	/^    int count;                  \/\/ # of evaluations$/;"	m	class:simlib3::Integrator2D::special_input	access:private
count	simlib3D.h	/^    int count;                  \/\/ # of evaluations$/;"	m	class:simlib3::Integrator3D::special_input	access:private
counter	atexit.cc	/^static int counter = 0; \/\/ internal module counter$/;"	m	namespace:simlib3	file:
create	calendar.cc	/^    static CalendarList * create() {  \/\/ create instance$/;"	f	class:simlib3::CalendarList	access:public	signature:()
create	calendar.cc	/^    static CalendarQueue * create() {  \/\/ create instance$/;"	f	class:simlib3::CalendarQueue	access:public	signature:()
create	waitunti.cc	/^    static void create() {  \/\/ create single instance$/;"	f	class:simlib3::WaitUntilList	access:public	signature:()
create_reverse_link	calendar.cc	/^    void create_reverse_link() {$/;"	f	struct:simlib3::EventNotice	access:public	signature:()
current	waitunti.cc	/^    static iterator current;$/;"	m	class:simlib3::WaitUntilList	file:	access:private
current	waitunti.cc	/^WaitUntilList::iterator WaitUntilList::current; \/\/ static$/;"	m	class:simlib3::WaitUntilList	file:
dbgprnt	algloop.cc	23;"	d	file:
dbgprnt	algloop.cc	25;"	d	file:
dd	simlib.h	/^  double dd;                           \/\/ input value: y'=f(t,y)$/;"	m	class:simlib3::Integrator	access:private
ddl	simlib.h	/^  double ddl;                          \/\/ the same from previous step$/;"	m	class:simlib3::Integrator	access:private
debug	opt-hooke.cc	16;"	d	file:
debug	opt-simann.cc	17;"	d	file:
debug_print	calendar.cc	/^    virtual void debug_print() = 0;     \/\/ print the calendar contents$/;"	p	class:simlib3::Calendar	file:	access:public	signature:()
debug_print	calendar.cc	/^    virtual void debug_print(); \/\/ print of calendar contents - FOR DEBUGGING ONLY$/;"	p	class:simlib3::CalendarList	file:	access:public	signature:()
debug_print	calendar.cc	/^    virtual void debug_print(); \/\/ print of calendar contents - FOR DEBUGGING ONLY$/;"	p	class:simlib3::CalendarQueue	file:	access:public	signature:()
debug_print	calendar.cc	/^    void debug_print();$/;"	p	class:simlib3::CalendarListImplementation	file:	access:public	signature:()
debug_print	calendar.cc	/^int SQS::debug_print() {                 \/\/ for debugging only$/;"	f	class:simlib3::SQS	signature:()
debug_print	calendar.cc	/^void CalendarList::debug_print() \/\/ print of calendar contents$/;"	f	class:simlib3::CalendarList	signature:()
debug_print	calendar.cc	/^void CalendarListImplementation::debug_print() \/\/ print of list contents$/;"	f	class:simlib3::CalendarListImplementation	signature:()
debug_print	calendar.cc	/^void CalendarQueue::debug_print() \/\/ print of calendar queue contents$/;"	f	class:simlib3::CalendarQueue	signature:()
debug_print	internal.h	/^    int debug_print();$/;"	p	namespace:simlib3::SQS	signature:()
default_clock	zdelay.cc	/^ZDelayTimer * ZDelay::default_clock = 0;$/;"	m	class:simlib3::ZDelay	file:
default_clock	zdelay.h	/^    static ZDelayTimer * default_clock;$/;"	m	class:simlib3::ZDelay	access:protected
delete_instance	calendar.cc	/^    static void delete_instance();      \/\/!< destroy single instance$/;"	p	class:simlib3::Calendar	file:	access:protected	signature:()
delete_instance	calendar.cc	/^void Calendar::delete_instance() {$/;"	f	class:simlib3::Calendar	signature:()
delete_reverse_link	calendar.cc	/^    void delete_reverse_link() {$/;"	f	struct:simlib3::EventNotice	access:public	signature:()
destroy	waitunti.cc	/^    static void destroy() {  \/\/ destroy single instance$/;"	f	class:simlib3::WaitUntilList	access:public	signature:()
di	ni_euler.h	/^  Memory si, di, A;  \/\/ auxiliary memories$/;"	m	class:simlib3::EULER	access:private
di	ni_rke.h	/^  Memory si, di;$/;"	m	class:simlib3::RKE	access:private
dptr	simlib.h	/^  unsigned *dptr;            \/\/ value array$/;"	m	class:simlib3::Histogram	access:protected
dt	delay.h	/^    double dt;                  \/\/!< Parameter: delay time (should be > MaxStep)$/;"	m	class:simlib3::Delay	access:protected
dt	zdelay.h	/^    double dt;          \/\/ clock period$/;"	m	class:simlib3::ZDelayTimer	access:private
empty	calendar.cc	/^    bool empty()        { return begin() == end(); }$/;"	f	class:simlib3::CalendarListImplementation	access:public	signature:()
empty	simlib.h	/^    bool empty()      { return Link::succ == this; }$/;"	f	class:simlib3::List	access:public	signature:()
empty	waitunti.cc	/^    static bool empty() { return instance->l.empty(); }$/;"	f	class:simlib3::WaitUntilList	access:public	signature:()
end	calendar.cc	/^    iterator end()      { return &l; }$/;"	f	class:simlib3::CalendarListImplementation	access:public	signature:()
end	simlib.h	/^    iterator end()     { return List::end(); }$/;"	f	class:simlib3::Queue	access:public	signature:()
end	simlib.h	/^    iterator end()    { return this; }$/;"	f	class:simlib3::List	access:public	signature:()
end	waitunti.cc	/^    static iterator end() { return instance->l.end(); }$/;"	f	class:simlib3::WaitUntilList	access:public	signature:()
end	zdelay.cc	/^        iterator end()          { return c.end(); }$/;"	f	class:simlib3::ZDelayTimer::ZDelayContainer	access:public	signature:()
entity	calendar.cc	/^    Entity * entity;$/;"	m	struct:simlib3::EventNotice	file:	access:public
enumname	generr.c	/^char enumname[MAXIDLEN + 1];$/;"	v
eps_root	simlib.h	/^  double eps_root; \/\/ root for force precision test$/;"	m	class:simlib3::Newton	access:private
eps_root	simlib.h	/^  double eps_root; \/\/ root for force precision test$/;"	m	class:simlib3::RegulaFalsi	access:private
erase	zdelay.cc	/^        void erase(ZDelay * p)  { c.erase(p); }$/;"	f	class:simlib3::ZDelayTimer::ZDelayContainer	access:public	signature:(ZDelay * p)
error	generr.c	/^void error(enum ErrEnum N)$/;"	f	signature:(enum ErrEnum N)
estimate_bucket_width	calendar.cc	/^    double estimate_bucket_width();$/;"	p	class:simlib3::CalendarQueue	file:	access:private	signature:()
estimate_bucket_width	calendar.cc	/^double CalendarQueue::estimate_bucket_width() {$/;"	f	class:simlib3::CalendarQueue	signature:()
extract_first	calendar.cc	/^    EventNotice *extract_first() {$/;"	f	class:simlib3::CalendarListImplementation	access:public	signature:()
f	simlib.h	/^  double (*f)(double); \/\/ pointer to function$/;"	m	class:simlib3::Function1	access:private
f	simlib.h	/^  double (*f)(double,double); \/\/ pointer to function$/;"	m	class:simlib3::Function2	access:private
first	calendar.cc	/^    EventNotice *first() { return *begin(); }$/;"	f	class:simlib3::CalendarListImplementation	access:public	signature:()
first_time	calendar.cc	/^    double first_time() { return (*begin())->time; }$/;"	f	class:simlib3::CalendarListImplementation	access:public	signature:()
flag	waitunti.cc	/^static bool flag = false; \/\/ valid iterator in WUList$/;"	m	namespace:simlib3	file:
fname	generr.c	/^char fname[512];                \/* module file name *\/$/;"	v
free	calendar.cc	/^    void free(EventNotice *en) {$/;"	f	class:simlib3::EventNoticeAllocator	access:public	signature:(EventNotice *en)
freed	calendar.cc	/^    unsigned freed;$/;"	m	class:simlib3::EventNoticeAllocator	file:	access:private
front	simlib.h	/^    Entity *front()    { return (Entity*)List::front(); }$/;"	f	class:simlib3::Queue	access:public	signature:()
front	simlib.h	/^    Link *front()     { return empty() ? 0 : Link::succ; }$/;"	f	class:simlib3::List	access:public	signature:()
funcname	generr.c	/^char funcname[MAXIDLEN + 1];$/;"	v
function	simlib.h	/^    void (*function)(); \/\/!< function to call periodically$/;"	m	class:simlib3::Sampler	access:protected
get	delay.cc	/^    virtual double get(double time) = 0;        \/\/!< read interpolated value$/;"	p	struct:simlib3::Delay::Buffer	file:	access:public	signature:(double time)
get	delay.cc	/^    virtual double get(double time) \/\/ get delayed value (with interpolation)$/;"	f	class:simlib3::SIMLIB_DelayBuffer	access:public	signature:(double time)
get	delay.h	/^        virtual double get(double time) = 0; \/\/!< get interpolated value$/;"	p	struct:simlib3::Delay::Buffer	access:public	signature:(double time)
get	print.cc	/^    static FILE *get() {$/;"	f	class:simlib3::_FileWrap	file:	access:private	signature:()
globalprocess	_test_.cc	/^TestProcess globalprocess;$/;"	v
head	simlib.h	/^  List *head;                          \/\/!< pointer to List (if any)$/;"	m	class:simlib3::Link	access:private
headfname	generr.c	/^char headfname[80];             \/* header file name *\/$/;"	v
help	generr.c	/^char help[] =$/;"	v
hi_bucket_mark	calendar.cc	/^    unsigned hi_bucket_mark;        \/\/ high bucket threshold for resize$/;"	m	class:simlib3::CalendarQueue	file:	access:private
high	simlib.h	/^  double low, high;               \/\/ limits$/;"	m	class:simlib3::Frict	access:protected
high	simlib.h	/^  double low, high;               \/\/ limits$/;"	m	class:simlib3::Insv	access:protected
high	simlib.h	/^  double low, high;               \/\/ limits$/;"	m	class:simlib3::Lim	access:protected
hooke_step	opt-hooke.cc	/^static double hooke_step(double *delta, opt_function_t f, ParameterVector & p,$/;"	f	namespace:simlib3	signature:(double *delta, opt_function_t f, ParameterVector & p, double min0)
in	simlib.h	/^  Entity *in;                \/\/!< entity currently in service$/;"	m	class:simlib3::Facility	access:public
in	simlib.h	/^  Input in;                            \/\/ block input$/;"	m	class:simlib3::Condition	access:private
in	simlib2D.cc	/^  Input2D in;$/;"	m	class:simlib3::_Abs2D	file:	access:private
in	simlib2D.h	/^    Input2D in;                 \/\/ 2D input$/;"	m	class:simlib3::Integrator2D::special_input	access:private
in	simlib2D.h	/^  } in;$/;"	m	class:simlib3::Integrator2D	typeref:class:simlib3::Integrator2D::special_input	access:private
in	simlib3D.cc	/^  Input3D in;$/;"	m	class:simlib3::_Abs3D	file:	access:private
in	simlib3D.h	/^    Input3D in;                 \/\/ 3D input$/;"	m	class:simlib3::Integrator3D::special_input	access:private
in	simlib3D.h	/^  } in;$/;"	m	class:simlib3::Integrator3D	typeref:class:simlib3::Integrator3D::special_input	access:private
inf	generr.c	/^FILE *inf;$/;"	v
initval	delay.h	/^    double initval;             \/\/!< initial value (used at start)$/;"	m	class:simlib3::Delay	access:protected
initval	simlib.h	/^  double initval;                      \/\/!< initial value$/;"	m	class:simlib3::Status	access:protected
initval	simlib.h	/^  double initval;                      \/\/!< initial value: y(t0)$/;"	m	class:simlib3::Integrator	access:protected
initval	zdelay.h	/^    double initval;     \/\/ initial output value$/;"	m	class:simlib3::ZDelay	access:protected
input	simlib.h	/^  Input input;                         \/\/!< input expression: f(t,y)$/;"	m	class:simlib3::Integrator	access:protected
input	simlib.h	/^  Input input;$/;"	m	class:simlib3::aContiBlock1	access:private
input	simlib2D.cc	/^  Input2D input;$/;"	m	class:simlib3::_XYpart	file:	access:private
input	simlib2D.h	/^  Input2D input;$/;"	m	class:simlib3::aContiBlock2D1	access:private
input	simlib3D.cc	/^  Input3D input;$/;"	m	class:simlib3::_XYZpart	file:	access:private
input	simlib3D.h	/^  Input3D input;$/;"	m	class:simlib3::aContiBlock3D1	access:private
input1	simlib.h	/^  Input input1;$/;"	m	class:simlib3::aContiBlock2	access:private
input1	simlib.h	/^  Input input1;$/;"	m	class:simlib3::aContiBlock3	access:private
input1	simlib2D.cc	/^  Input2D input1;$/;"	m	class:simlib3::_ScalarProduct2D	file:	access:private
input1	simlib2D.h	/^  Input2D input1;$/;"	m	class:simlib3::aContiBlock2D2	access:private
input1	simlib3D.cc	/^  Input3D input1;$/;"	m	class:simlib3::_ScalarProduct3D	file:	access:private
input1	simlib3D.h	/^  Input3D input1;$/;"	m	class:simlib3::aContiBlock3D2	access:private
input2	simlib.h	/^  Input input2;$/;"	m	class:simlib3::aContiBlock2	access:private
input2	simlib.h	/^  Input input2;$/;"	m	class:simlib3::aContiBlock3	access:private
input2	simlib2D.cc	/^  Input2D input2;$/;"	m	class:simlib3::_ScalarProduct2D	file:	access:private
input2	simlib2D.h	/^  Input2D input2;$/;"	m	class:simlib3::aContiBlock2D2	access:private
input2	simlib3D.cc	/^  Input3D input2;$/;"	m	class:simlib3::_ScalarProduct3D	file:	access:private
input2	simlib3D.h	/^  Input3D input2;$/;"	m	class:simlib3::aContiBlock3D2	access:private
input3	simlib.h	/^  Input input3;$/;"	m	class:simlib3::aContiBlock3	access:private
input3	simlib2D.h	/^  Input2D input3;$/;"	m	class:simlib3::aContiBlock2D3	access:private
input3	simlib3D.h	/^  Input3D input3;$/;"	m	class:simlib3::aContiBlock3D3	access:private
input_value	zdelay.h	/^    double input_value;                 \/\/ temporary$/;"	m	class:simlib3::ZDelay	access:private
insert	calendar.cc	/^    void insert(Entity *e, double t) {$/;"	f	class:simlib3::CalendarListImplementation	access:public	signature:(Entity *e, double t)
insert	calendar.cc	/^    void insert(EventNoticeLinkBase * p) {$/;"	f	struct:simlib3::EventNoticeLinkBase	access:public	signature:(EventNoticeLinkBase * p)
insert	zdelay.cc	/^        void insert(ZDelay * p) { c.insert(p); }$/;"	f	class:simlib3::ZDelayTimer::ZDelayContainer	access:public	signature:(ZDelay * p)
insert_extracted	calendar.cc	/^    void insert_extracted(EventNotice *evn) {$/;"	f	class:simlib3::CalendarListImplementation	access:public	signature:(EventNotice *evn)
instance	calendar.cc	/^    static Calendar * instance();       \/\/!< create\/get single instance (singleton)$/;"	p	class:simlib3::Calendar	file:	access:public	signature:()
instance	calendar.cc	/^inline Calendar * Calendar::instance() {$/;"	f	class:simlib3::Calendar	signature:()
instance	waitunti.cc	/^    static WaitUntilList *instance;   \/\/ unique list$/;"	m	class:simlib3::WaitUntilList	file:	access:private
instance	waitunti.cc	/^WaitUntilList *WaitUntilList::instance = 0; \/\/ static$/;"	m	class:simlib3::WaitUntilList	file:
instance_exists	calendar.cc	/^    static bool instance_exists() {$/;"	f	class:simlib3::Calendar	access:public	signature:()
isAllocated	simlib.h	/^  bool isAllocated() const { return (_flags >> _ALLOCATED_FLAG)&1; }$/;"	f	class:simlib3::SimObject	access:public	signature:() const
isAny	cond.cc	/^bool aCondition::isAny()  { return First!=0; }$/;"	f	class:simlib3::aCondition	signature:()
isAny	simlib.h	/^  static bool isAny();$/;"	p	class:simlib3::aCondition	access:public	signature:()
isAny	simlib.h	/^  static bool isAny(void) {$/;"	f	class:simlib3::IntegratorContainer	access:public	signature:(void)
isAny	simlib.h	/^  static bool isAny(void) {$/;"	f	class:simlib3::StatusContainer	access:public	signature:(void)
isCurrent	simlib.h	/^  bool isCurrent() const    { return (_status==_RUNNING);     } \/\/ Behavior() runs$/;"	f	class:simlib3::Process	access:private	signature:() const
isEvaluated	simlib.h	/^    bool isEvaluated;                   \/\/TODO:remove this flag for algebraic loop detection$/;"	m	class:simlib3::aContiBlock	access:protected
isEvaluated	simlib2D.h	/^  bool isEvaluated;                  \/\/ flag for loop checking ###---$/;"	m	class:simlib3::aContiBlock2D	access:protected
isEvaluated	simlib3D.h	/^  bool isEvaluated;                  \/\/ flag for loop checking ###---$/;"	m	class:simlib3::aContiBlock3D	access:protected
isInQueue	simlib.h	/^  virtual bool isInQueue() { return Where()!=NULL; } \/\/!< present in queue$/;"	f	class:simlib3::Link	access:public	signature:()
isInterrupted	simlib.h	/^  bool isInterrupted() const{ return (_status==_INTERRUPTED); } \/\/ can continue$/;"	f	class:simlib3::Process	access:private	signature:() const
isPrepared	simlib.h	/^  bool isPrepared() const   { return (_status==_PREPARED);    } \/\/ before start$/;"	f	class:simlib3::Process	access:private	signature:() const
isTerminated	simlib.h	/^  bool isTerminated() const { return (_status==_TERMINATED);  } \/\/ zombie$/;"	f	class:simlib3::Process	access:private	signature:() const
it_list	simlib.h	/^      std::list<Memory*>::iterator it_list;  \/\/ position in list$/;"	m	class:simlib3::IntegrationMethod::Memory	access:private
it_list	simlib.h	/^  IntegratorContainer::iterator it_list; \/\/!< position in list of integrators$/;"	m	class:simlib3::Integrator	access:protected
it_list	simlib.h	/^  StatusContainer::iterator it_list;   \/\/!< position in list of status variables$/;"	m	class:simlib3::Status	access:protected
iterator	calendar.cc	/^      iterator(EventNoticeLinkBase *pos) : p(pos) {}$/;"	f	class:simlib3::CalendarListImplementation::iterator	access:public	signature:(EventNoticeLinkBase *pos)
iterator	calendar.cc	/^    class iterator { \/\/!< bidirectional iterator$/;"	c	class:simlib3::CalendarListImplementation	file:	access:public
iterator	simlib.h	/^            iterator(Link *pos) : p(pos) {}$/;"	f	class:simlib3::List::iterator	access:public	signature:(Link *pos)
iterator	simlib.h	/^            iterator(const iterator&x): p(x.p) {}$/;"	f	class:simlib3::List::iterator	access:public	signature:(const iterator&x)
iterator	simlib.h	/^    class iterator {$/;"	c	class:simlib3::List	access:protected
iterator	simlib.h	/^    typedef List::iterator iterator;$/;"	t	class:simlib3::Queue	access:public
iterator	simlib.h	/^  typedef std::list<Integrator*>::iterator iterator;$/;"	t	class:simlib3::IntegratorContainer	access:public
iterator	simlib.h	/^  typedef std::list<Status*>::iterator iterator;$/;"	t	class:simlib3::StatusContainer	access:public
iterator	waitunti.cc	/^    typedef container_t::iterator iterator;$/;"	t	class:simlib3::WaitUntilList	file:	access:public
iterator	zdelay.cc	/^        typedef container_t::iterator iterator;$/;"	t	class:simlib3::ZDelayTimer::ZDelayContainer	file:	access:public
l	calendar.cc	/^    CalendarListImplementation l;$/;"	m	class:simlib3::CalendarList	file:	access:private
l	calendar.cc	/^    EventNoticeLinkBase *l; \/\/ single-linked list of freed items$/;"	m	class:simlib3::EventNoticeAllocator	file:	access:private
l	calendar.cc	/^    EventNoticeLinkBase l;  \/\/!< head of circular list$/;"	m	class:simlib3::CalendarListImplementation	file:	access:private
l	waitunti.cc	/^    container_t l;$/;"	m	class:simlib3::WaitUntilList	file:	access:private
last	simlib.h	/^    double last;        \/\/!< last sample time -- prevents sample duplication$/;"	m	class:simlib3::Sampler	access:protected
last_dequeue_time	calendar.cc	/^    double last_dequeue_time; \/\/ for deleta computation$/;"	m	class:simlib3::CalendarQueue	file:	access:private
last_insert	delay.cc	/^    Pair last_insert;           \/\/!< last inserted value (for optimization)$/;"	m	class:simlib3::SIMLIB_DelayBuffer	file:	access:private
last_time	delay.h	/^    double last_time;           \/\/!< last output time (for optimization)$/;"	m	class:simlib3::Delay	access:protected
last_value	delay.h	/^    double last_value;          \/\/!< last output value$/;"	m	class:simlib3::Delay	access:protected
limit	optimize.h	/^    void limit(double &x)$/;"	f	class:simlib3::Param	access:private	signature:(double &x)
limitation	_test_.cc	/^  Lim limitation;$/;"	m	struct:Test	file:	access:public
line	generr.c	/^char line[MAXLINELEN + 2];$/;"	v
lineno	generr.c	/^int lineno = 0;$/;"	v
list	calendar.cc	/^    BucketList list;        \/\/ list for small number of items$/;"	m	class:simlib3::CalendarQueue	file:	access:private
list_impl	calendar.cc	/^    bool list_impl() { return buckets==NULL; }$/;"	f	class:simlib3::CalendarQueue	file:	access:private	signature:()
listptr	delay.cc	/^    static std::list<Delay *> *listptr; \/\/!< list of delay objects -- singleton$/;"	m	class:simlib3::SIMLIB_Delay	file:	access:private
listptr	delay.cc	/^std::list<Delay *> *SIMLIB_Delay::listptr = 0;$/;"	m	class:simlib3::SIMLIB_Delay	file:
lock	internal.h	/^    void lock() {$/;"	f	class:simlib3::AlgLoopDetector	access:private	signature:()
low	simlib.h	/^  double   low;              \/\/ low bound$/;"	m	class:simlib3::Histogram	access:protected
low	simlib.h	/^  double low, high;               \/\/ limits$/;"	m	class:simlib3::Frict	access:protected
low	simlib.h	/^  double low, high;               \/\/ limits$/;"	m	class:simlib3::Insv	access:protected
low	simlib.h	/^  double low, high;               \/\/ limits$/;"	m	class:simlib3::Lim	access:protected
low_bucket_mark	calendar.cc	/^    unsigned low_bucket_mark;       \/\/ low bucket threshold for resize$/;"	m	class:simlib3::CalendarQueue	file:	access:private
main	_test_.cc	/^int main() {                      \/\/ popis experimentu ...$/;"	f	signature:()
main	generr.c	/^int main(int argc, char *argv[])$/;"	f	signature:(int argc, char *argv[])
max	internal.h	/^inline double max(double a, double b) { return ((a)>(b)?(a):(b)); }$/;"	f	namespace:simlib3	signature:(double a, double b)
max	optimize.h	/^    double max;$/;"	m	class:simlib3::Param	access:private
max	simlib.h	/^  double max;                   \/\/ max value x$/;"	m	class:simlib3::TStat	access:protected
max	simlib.h	/^  double max;                   \/\/ max value$/;"	m	class:simlib3::Stat	access:protected
max	simlib.h	/^  double max;                   \/\/ maximal recorded value$/;"	m	class:simlib3::aStat	access:protected
maxn	simlib.h	/^  unsigned maxn;        \/\/!< barrier height\/size$/;"	m	class:simlib3::Barrier	access:protected
mem_size	simlib.h	/^      size_t mem_size;  \/\/ allocated memory size$/;"	m	class:simlib3::IntegrationMethod::Memory	access:private
method_name	simlib.h	/^  const char* method_name;  \/\/ C-string --- the name of the method$/;"	m	class:simlib3::IntegrationMethod	access:private
min	internal.h	/^inline double min(double a, double b) { return ((a)>(b)?(b):(a)); }$/;"	f	namespace:simlib3	signature:(double a, double b)
min	optimize.h	/^    double min;$/;"	m	class:simlib3::Param	access:private
min	simlib.h	/^  double min;                   \/\/ min value x$/;"	m	class:simlib3::TStat	access:protected
min	simlib.h	/^  double min;                   \/\/ min value$/;"	m	class:simlib3::Stat	access:protected
min	simlib.h	/^  double min;                   \/\/ minimal recorded value$/;"	m	class:simlib3::aStat	access:protected
mintime	calendar.cc	/^    double mintime;     \/\/!< activation time of first event$/;"	m	class:simlib3::Calendar	file:	access:private
modfname	generr.c	/^char modfname[80];              \/* module file name *\/$/;"	v
move_to_next_point	opt-simann.cc	/^void move_to_next_point(ParameterVector & p, double eps)$/;"	f	namespace:simlib3	signature:(ParameterVector & p, double eps)
myint32	random1.cc	/^typedef int myint32;      \/\/ long has >32 bits$/;"	t	namespace:simlib3	file:
myint32	random1.cc	/^typedef long myint32;     \/\/ long has 32 bits$/;"	t	namespace:simlib3	file:
n	optimize.h	/^    int n;$/;"	m	class:simlib3::ParameterVector	access:private
n	simlib.h	/^    unsigned n;                          \/\/ number of objects in list$/;"	m	class:simlib3::List	access:private
n	simlib.h	/^  int n;                          \/\/ table item number$/;"	m	class:simlib3::Rline	access:protected
n	simlib.h	/^  int n;$/;"	m	class:simlib3::Semaphore	access:protected
n	simlib.h	/^  unsigned long n;              \/\/ number of records$/;"	m	class:simlib3::TStat	access:protected
n	simlib.h	/^  unsigned long n;              \/\/ number of values recorded$/;"	m	class:simlib3::Stat	access:protected
n	simlib.h	/^  unsigned long n;              \/\/ number of values recorded$/;"	m	class:simlib3::aStat	access:protected
n	simlib.h	/^  unsigned n;           \/\/!< current number of waiting entities$/;"	m	class:simlib3::Barrier	access:protected
name	optimize.h	/^    const char *name;           \/\/ name of parameter  c-string$/;"	m	class:simlib3::Param	access:private
nbuckets	calendar.cc	/^    unsigned nbuckets;      \/\/ current number of buckets$/;"	m	class:simlib3::CalendarQueue	file:	access:private
ndelta	calendar.cc	/^    unsigned ndelta;        \/\/ count$/;"	m	class:simlib3::CalendarQueue	file:	access:private
new_value	zdelay.h	/^    double new_value;   \/\/ stored input value$/;"	m	class:simlib3::ZDelay	access:protected
next	simlib.h	/^    static Link *next(Link*p)           { return p->succ; }$/;"	f	class:simlib3::List	access:private	signature:(Link*p)
nextbucket	calendar.cc	/^    unsigned nextbucket;    \/\/ next bucket to check for first item$/;"	m	class:simlib3::CalendarQueue	file:	access:private
numop	calendar.cc	/^    unsigned numop;         \/\/ number of operations performed from last tuning$/;"	m	class:simlib3::CalendarQueue	file:	access:private
old_value	zdelay.h	/^    double old_value;   \/\/ output value (delayed signal)$/;"	m	class:simlib3::ZDelay	access:protected
on	simlib.h	/^    bool on;            \/\/!< switch on\/off$/;"	m	class:simlib3::Sampler	access:protected
operator !=	calendar.cc	/^      bool operator != (iterator q) { return p!=q.p; }$/;"	f	class:simlib3::CalendarListImplementation::iterator	access:public	signature:(iterator q)
operator !=	simlib.h	/^            bool operator != (iterator q) const { return p!=q.p; }$/;"	f	class:simlib3::List::iterator	access:public	signature:(iterator q) const
operator ()	histo.cc	/^void Histogram::operator () (double x)$/;"	f	class:simlib3::Histogram	signature:(double x)
operator ()	simlib.h	/^  virtual void operator () (double x) = 0;  \/\/!< record value$/;"	p	class:simlib3::aStat	access:public	signature:(double x)
operator ()	simlib.h	/^  virtual void operator () (double x);           \/\/!< record the value$/;"	p	class:simlib3::TStat	access:public	signature:(double x)
operator ()	simlib.h	/^  void operator () (double x);         \/\/ record value x$/;"	p	class:simlib3::Histogram	access:public	signature:(double x)
operator ()	simlib.h	/^  void operator () (double x);  \/\/!< record the value$/;"	p	class:simlib3::Stat	access:public	signature:(double x)
operator ()	stat.cc	/^void Stat::operator () (double x)$/;"	f	class:simlib3::Stat	signature:(double x)
operator ()	tstat.cc	/^void TStat::operator () (double x)$/;"	f	class:simlib3::TStat	signature:(double x)
operator *	calendar.cc	/^      EventNotice * operator*() {$/;"	f	class:simlib3::CalendarListImplementation::iterator	access:public	signature:()
operator *	continuous.cc	/^Input operator * (Input a, Input b) { return new _Mul(a,b); }$/;"	f	namespace:simlib3	signature:(Input a, Input b)
operator *	simlib.h	/^            Link * operator*() const { return p; }$/;"	f	class:simlib3::List::iterator	access:public	signature:() const
operator *	simlib.h	/^Input operator * (Input a, Input b);$/;"	p	namespace:simlib3	signature:(Input a, Input b)
operator *	simlib2D.cc	/^Input2D operator * (Input a, Input2D b)   { return new _Mul2D1D(b,a); }$/;"	f	namespace:simlib3	signature:(Input a, Input2D b)
operator *	simlib2D.cc	/^Input2D operator * (Input2D a, Input b)   { return new _Mul2D1D(a,b); }$/;"	f	namespace:simlib3	signature:(Input2D a, Input b)
operator *	simlib2D.cc	/^Value2D operator *(const Value2D& a, const double b)$/;"	f	namespace:simlib3	signature:(const Value2D& a, const double b)
operator *	simlib2D.cc	/^Value2D operator *(const double a, const Value2D& b)$/;"	f	namespace:simlib3	signature:(const double a, const Value2D& b)
operator *	simlib2D.h	/^  friend Value2D operator *(const Value2D& a, const double b);$/;"	p	class:simlib3::Value2D	access:friend	signature:(const Value2D& a, const double b)
operator *	simlib2D.h	/^  friend Value2D operator *(const double a, const Value2D& b);$/;"	p	class:simlib3::Value2D	access:friend	signature:(const double a, const Value2D& b)
operator *	simlib2D.h	/^Input2D operator * (Input a, Input2D b);        \/\/ scalar * vector$/;"	p	namespace:simlib3	signature:(Input a, Input2D b)
operator *	simlib2D.h	/^Input2D operator * (Input2D a, Input b);        \/\/ vector * scalar$/;"	p	namespace:simlib3	signature:(Input2D a, Input b)
operator *	simlib3D.cc	/^Input3D operator * (Input a, Input3D b)   { return new _Mul3D1D(b,a); }$/;"	f	namespace:simlib3	signature:(Input a, Input3D b)
operator *	simlib3D.cc	/^Input3D operator * (Input3D a, Input b)   { return new _Mul3D1D(a,b); }$/;"	f	namespace:simlib3	signature:(Input3D a, Input b)
operator *	simlib3D.cc	/^Input3D operator * (Input3D a, Input3D b) { return new _Mul3D(a,b); }$/;"	f	namespace:simlib3	signature:(Input3D a, Input3D b)
operator *	simlib3D.cc	/^Value3D operator *(const Value3D& a, const Value3D &b)$/;"	f	namespace:simlib3	signature:(const Value3D& a, const Value3D &b)
operator *	simlib3D.cc	/^Value3D operator *(const Value3D& a, const double b)$/;"	f	namespace:simlib3	signature:(const Value3D& a, const double b)
operator *	simlib3D.cc	/^Value3D operator *(const double a, const Value3D& b)$/;"	f	namespace:simlib3	signature:(const double a, const Value3D& b)
operator *	simlib3D.h	/^  friend Value3D operator *(const Value3D& a, const Value3D &b);$/;"	p	class:simlib3::Value3D	access:friend	signature:(const Value3D& a, const Value3D &b)
operator *	simlib3D.h	/^  friend Value3D operator *(const Value3D& a, const double b);$/;"	p	class:simlib3::Value3D	access:friend	signature:(const Value3D& a, const double b)
operator *	simlib3D.h	/^  friend Value3D operator *(const double a, const Value3D& b);$/;"	p	class:simlib3::Value3D	access:friend	signature:(const double a, const Value3D& b)
operator *	simlib3D.h	/^Input3D operator * (Input a, Input3D b);        \/\/ scalar * vector$/;"	p	namespace:simlib3	signature:(Input a, Input3D b)
operator *	simlib3D.h	/^Input3D operator * (Input3D a, Input b);        \/\/ vector * scalar$/;"	p	namespace:simlib3	signature:(Input3D a, Input b)
operator *	simlib3D.h	/^Input3D operator * (Input3D a, Input3D b);      \/\/ vector multiplication$/;"	p	namespace:simlib3	signature:(Input3D a, Input3D b)
operator +	continuous.cc	/^Input operator + (Input a, Input b) { return new _Add(a,b); }$/;"	f	namespace:simlib3	signature:(Input a, Input b)
operator +	simlib.h	/^Input operator + (Input a, Input b);$/;"	p	namespace:simlib3	signature:(Input a, Input b)
operator +	simlib2D.cc	/^Input2D operator + (Input2D a, Input2D b) { return new _Add2D(a,b); }$/;"	f	namespace:simlib3	signature:(Input2D a, Input2D b)
operator +	simlib2D.cc	/^Value2D operator +(const Value2D& a, const Value2D &b)$/;"	f	namespace:simlib3	signature:(const Value2D& a, const Value2D &b)
operator +	simlib2D.h	/^  Value2D operator + (Value2D b) { return Value2D(_x+b._x, _y+b._y); }$/;"	f	class:simlib3::Value2D	access:public	signature:(Value2D b)
operator +	simlib2D.h	/^  friend Value2D operator +(const Value2D& a, const Value2D &b);$/;"	p	class:simlib3::Value2D	access:friend	signature:(const Value2D& a, const Value2D &b)
operator +	simlib2D.h	/^Input2D operator + (Input2D a, Input2D b);      \/\/ add vectors$/;"	p	namespace:simlib3	signature:(Input2D a, Input2D b)
operator +	simlib3D.cc	/^Input3D operator + (Input3D a, Input3D b) { return new _Add3D(a,b); }$/;"	f	namespace:simlib3	signature:(Input3D a, Input3D b)
operator +	simlib3D.cc	/^Value3D operator +(const Value3D& a, const Value3D &b)$/;"	f	namespace:simlib3	signature:(const Value3D& a, const Value3D &b)
operator +	simlib3D.h	/^  Value3D operator + (Value3D b) { return Value3D(_x+b._x, _y+b._y, _z+b._z); }$/;"	f	class:simlib3::Value3D	access:public	signature:(Value3D b)
operator +	simlib3D.h	/^  friend Value3D operator +(const Value3D& a, const Value3D &b);$/;"	p	class:simlib3::Value3D	access:friend	signature:(const Value3D& a, const Value3D &b)
operator +	simlib3D.h	/^Input3D operator + (Input3D a, Input3D b);      \/\/ add vectors$/;"	p	namespace:simlib3	signature:(Input3D a, Input3D b)
operator ++	calendar.cc	/^      iterator &operator++() { p = p->succ; return *this; }$/;"	f	class:simlib3::CalendarListImplementation::iterator	access:public	signature:()
operator ++	simlib.h	/^            iterator &operator++() { p = List::next(p); return *this; }$/;"	f	class:simlib3::List::iterator	access:public	signature:()
operator ++	simlib.h	/^            iterator operator++(int) {$/;"	f	class:simlib3::List::iterator	access:public	signature:(int)
operator -	continuous.cc	/^Input operator - (Input a) { return new _UMinus(a); }$/;"	f	namespace:simlib3	signature:(Input a)
operator -	continuous.cc	/^Input operator - (Input a, Input b) { return new _Sub(a,b); }$/;"	f	namespace:simlib3	signature:(Input a, Input b)
operator -	simlib.h	/^Input operator - (Input a);$/;"	p	namespace:simlib3	signature:(Input a)
operator -	simlib.h	/^Input operator - (Input a, Input b);$/;"	p	namespace:simlib3	signature:(Input a, Input b)
operator -	simlib2D.cc	/^Input2D operator - (Input2D a) { return new _UMinus2D(a); }$/;"	f	namespace:simlib3	signature:(Input2D a)
operator -	simlib2D.cc	/^Input2D operator - (Input2D a, Input2D b) { return new _Sub2D(a,b); }$/;"	f	namespace:simlib3	signature:(Input2D a, Input2D b)
operator -	simlib2D.cc	/^Value2D operator -(const Value2D& a)$/;"	f	namespace:simlib3	signature:(const Value2D& a)
operator -	simlib2D.cc	/^Value2D operator -(const Value2D& a, const Value2D &b)$/;"	f	namespace:simlib3	signature:(const Value2D& a, const Value2D &b)
operator -	simlib2D.h	/^  Value2D operator - (Value2D b) { return Value2D(_x-b._x, _y-b._y); }$/;"	f	class:simlib3::Value2D	access:public	signature:(Value2D b)
operator -	simlib2D.h	/^  friend Value2D operator -(const Value2D& a);$/;"	p	class:simlib3::Value2D	access:friend	signature:(const Value2D& a)
operator -	simlib2D.h	/^  friend Value2D operator -(const Value2D& a, const Value2D &b);$/;"	p	class:simlib3::Value2D	access:friend	signature:(const Value2D& a, const Value2D &b)
operator -	simlib2D.h	/^Input2D operator - (Input2D a);                 \/\/ unary -$/;"	p	namespace:simlib3	signature:(Input2D a)
operator -	simlib2D.h	/^Input2D operator - (Input2D a, Input2D b);      \/\/ subtract vectors$/;"	p	namespace:simlib3	signature:(Input2D a, Input2D b)
operator -	simlib3D.cc	/^Input3D operator - (Input3D a) { return new _UMinus3D(a); }$/;"	f	namespace:simlib3	signature:(Input3D a)
operator -	simlib3D.cc	/^Input3D operator - (Input3D a, Input3D b) { return new _Sub3D(a,b); }$/;"	f	namespace:simlib3	signature:(Input3D a, Input3D b)
operator -	simlib3D.cc	/^Value3D operator -(const Value3D& a)$/;"	f	namespace:simlib3	signature:(const Value3D& a)
operator -	simlib3D.cc	/^Value3D operator -(const Value3D& a, const Value3D &b)$/;"	f	namespace:simlib3	signature:(const Value3D& a, const Value3D &b)
operator -	simlib3D.h	/^  Value3D operator - (Value3D b) { return Value3D(_x-b._x, _y-b._y, _z-b._z); }$/;"	f	class:simlib3::Value3D	access:public	signature:(Value3D b)
operator -	simlib3D.h	/^  friend Value3D operator -(const Value3D& a);$/;"	p	class:simlib3::Value3D	access:friend	signature:(const Value3D& a)
operator -	simlib3D.h	/^  friend Value3D operator -(const Value3D& a, const Value3D &b);$/;"	p	class:simlib3::Value3D	access:friend	signature:(const Value3D& a, const Value3D &b)
operator -	simlib3D.h	/^Input3D operator - (Input3D a);                 \/\/ unary -$/;"	p	namespace:simlib3	signature:(Input3D a)
operator -	simlib3D.h	/^Input3D operator - (Input3D a, Input3D b);      \/\/ subtract vectors$/;"	p	namespace:simlib3	signature:(Input3D a, Input3D b)
operator --	calendar.cc	/^      iterator &operator--() { p = p->pred; return *this; }$/;"	f	class:simlib3::CalendarListImplementation::iterator	access:public	signature:()
operator --	simlib.h	/^            iterator &operator--() { p = List::previous(p); return *this; }$/;"	f	class:simlib3::List::iterator	access:public	signature:()
operator --	simlib.h	/^            iterator operator--(int) {$/;"	f	class:simlib3::List::iterator	access:public	signature:(int)
operator /	continuous.cc	/^Input operator \/ (Input a, Input b) { return new _Div(a,b); }$/;"	f	namespace:simlib3	signature:(Input a, Input b)
operator /	simlib.h	/^Input operator \/ (Input a, Input b);$/;"	p	namespace:simlib3	signature:(Input a, Input b)
operator /	simlib2D.cc	/^Input2D operator \/ (Input2D a, Input b)   { return new _Div2D(a,b); }$/;"	f	namespace:simlib3	signature:(Input2D a, Input b)
operator /	simlib2D.cc	/^Value2D operator \/(const Value2D& a, const double b)$/;"	f	namespace:simlib3	signature:(const Value2D& a, const double b)
operator /	simlib2D.h	/^  friend Value2D operator \/(const Value2D& a, const double b);$/;"	p	class:simlib3::Value2D	access:friend	signature:(const Value2D& a, const double b)
operator /	simlib2D.h	/^Input2D operator \/ (Input2D a, Input b);        \/\/ vector \/ scalar$/;"	p	namespace:simlib3	signature:(Input2D a, Input b)
operator /	simlib3D.cc	/^Input3D operator \/ (Input3D a, Input b)   { return new _Div3D(a,b); }$/;"	f	namespace:simlib3	signature:(Input3D a, Input b)
operator /	simlib3D.cc	/^Value3D operator \/(const Value3D& a, const double b)$/;"	f	namespace:simlib3	signature:(const Value3D& a, const double b)
operator /	simlib3D.h	/^  friend Value3D operator \/(const Value3D& a, const double b);$/;"	p	class:simlib3::Value3D	access:friend	signature:(const Value3D& a, const double b)
operator /	simlib3D.h	/^Input3D operator \/ (Input3D a, Input b);        \/\/ vector \/ scalar$/;"	p	namespace:simlib3	signature:(Input3D a, Input b)
operator =	calendar.cc	/^    EventNotice &operator=(const EventNotice&);$/;"	p	struct:simlib3::EventNotice	file:	access:private	signature:(const EventNotice&)
operator =	delay.h	/^    void operator= (const Delay&);       \/\/ disable assignment$/;"	p	class:simlib3::Delay	access:private	signature:(const Delay&)
operator =	internal.h	/^  SIMLIB_module &operator= (const SIMLIB_module&); \/\/ disable =$/;"	p	class:simlib3::SIMLIB_module	access:private	signature:(const SIMLIB_module&)
operator =	opt-param.cc	/^ParameterVector & ParameterVector::operator = (const ParameterVector & a) {$/;"	f	class:simlib3::ParameterVector	signature:(const ParameterVector & a)
operator =	optimize.h	/^    Param & operator = (double x) {$/;"	f	class:simlib3::Param	access:public	signature:(double x)
operator =	optimize.h	/^    ParameterVector & operator = (const ParameterVector & a);$/;"	p	class:simlib3::ParameterVector	access:public	signature:(const ParameterVector & a)
operator =	print.cc	/^    void operator = (FILE *f)   { OutFile=f; }$/;"	f	class:simlib3::_FileWrap	access:public	signature:(FILE *f)
operator =	simlib.h	/^            iterator &operator=(const iterator&x) { p = x.p; return *this; }$/;"	f	class:simlib3::List::iterator	access:public	signature:(const iterator&x)
operator =	simlib.h	/^      Memory&operator=(const Memory&); \/\/ ## disable$/;"	p	class:simlib3::IntegrationMethod::Memory	access:private	signature:(const Memory&)
operator =	simlib.h	/^      void operator= (Memory&);  \/\/ disable the operation$/;"	p	class:simlib3::IntegrationMethod::Memory	access:private	signature:(Memory&)
operator =	simlib.h	/^    Entity&operator=(const Entity&); \/\/ disable$/;"	p	class:simlib3::Entity	access:private	signature:(const Entity&)
operator =	simlib.h	/^    Facility&operator=(const Facility&);        \/\/ disable$/;"	p	class:simlib3::Facility	access:private	signature:(const Facility&)
operator =	simlib.h	/^    Function1&operator=(const Function1&); \/\/ ## disable$/;"	p	class:simlib3::Function1	access:private	signature:(const Function1&)
operator =	simlib.h	/^    Function2&operator=(const Function2&); \/\/ ## disable$/;"	p	class:simlib3::Function2	access:private	signature:(const Function2&)
operator =	simlib.h	/^    Histogram&operator=(const Histogram&); \/\/ disable$/;"	p	class:simlib3::Histogram	access:private	signature:(const Histogram&)
operator =	simlib.h	/^    IntegrationMethod&operator=(const IntegrationMethod&); \/\/ ## disable$/;"	p	class:simlib3::IntegrationMethod	access:private	signature:(const IntegrationMethod&)
operator =	simlib.h	/^    MultiStepMethod&operator=(const MultiStepMethod&); \/\/ ## disable$/;"	p	class:simlib3::MultiStepMethod	access:private	signature:(const MultiStepMethod&)
operator =	simlib.h	/^    Rline&operator=(const Rline&); \/\/ ## disable$/;"	p	class:simlib3::Rline	access:private	signature:(const Rline&)
operator =	simlib.h	/^    Sampler&operator=(const Sampler&);  \/\/## disable$/;"	p	class:simlib3::Sampler	access:private	signature:(const Sampler&)
operator =	simlib.h	/^    Store&operator=(const Store&);    \/\/ disable$/;"	p	class:simlib3::Store	access:private	signature:(const Store&)
operator =	simlib.h	/^    void operator= (List&);              \/\/ disable$/;"	p	class:simlib3::List	access:private	signature:(List&)
operator =	simlib.h	/^    void operator= (StatusMemory&);  \/\/ disable the operation$/;"	p	class:simlib3::StatusMethod::StatusMemory	access:private	signature:(StatusMemory&)
operator =	simlib.h	/^    void operator= (const aContiBlock&);        \/\/ disable assignment$/;"	p	class:simlib3::aContiBlock	access:private	signature:(const aContiBlock&)
operator =	simlib.h	/^  Barrier&operator=(const Barrier&);    \/\/ ## disable$/;"	p	class:simlib3::Barrier	access:private	signature:(const Barrier&)
operator =	simlib.h	/^  Input &operator= (const Input&x) {$/;"	f	class:simlib3::Input	access:public	signature:(const Input&x)
operator =	simlib.h	/^  Integrator &operator= (const Integrator &x); \/\/ disable assignment$/;"	p	class:simlib3::Integrator	access:private	signature:(const Integrator &x)
operator =	simlib.h	/^  Integrator &operator= (double x) { Set(x); return *this; }$/;"	f	class:simlib3::Integrator	access:public	signature:(double x)
operator =	simlib.h	/^  Parameter &operator= (double x) { value = x; return *this; }$/;"	f	class:simlib3::Parameter	access:public	signature:(double x)
operator =	simlib.h	/^  Process&operator=(const Process&);    \/\/ disable copying$/;"	p	class:simlib3::Process	access:private	signature:(const Process&)
operator =	simlib.h	/^  Variable &operator= (double x)  { value = x; return *this; }$/;"	f	class:simlib3::Variable	access:public	signature:(double x)
operator =	simlib.h	/^  void operator= (Link&);              \/\/ disable operation$/;"	p	class:simlib3::Link	access:private	signature:(Link&)
operator =	simlib.h	/^  void operator= (SimObject&);         \/\/!< disabled operation$/;"	p	class:simlib3::SimObject	access:private	signature:(SimObject&)
operator =	simlib.h	/^  void operator= (Status&);            \/\/ disable assignment$/;"	p	class:simlib3::Status	access:private	signature:(Status&)
operator =	simlib.h	/^  void operator= (aCondition&);        \/\/ disable operation$/;"	p	class:simlib3::aCondition	access:private	signature:(aCondition&)
operator =	simlib2D.cc	/^Integrator2D &Integrator2D::operator = (Input2D i)$/;"	f	class:simlib3::Integrator2D	signature:(Input2D i)
operator =	simlib2D.cc	/^Integrator2D &Integrator2D::operator = (const Value2D &a)$/;"	f	class:simlib3::Integrator2D	signature:(const Value2D &a)
operator =	simlib2D.cc	/^Parameter2D &Parameter2D::operator= (const Value2D &x)    {$/;"	f	class:simlib3::Parameter2D	signature:(const Value2D &x)
operator =	simlib2D.h	/^  Input2D&operator=(const Input2D&x) { bp=x.bp; return *this; }$/;"	f	class:simlib3::Input2D	access:public	signature:(const Input2D&x)
operator =	simlib2D.h	/^  Integrator2D &operator = (Input2D i);$/;"	p	class:simlib3::Integrator2D	access:public	signature:(Input2D i)
operator =	simlib2D.h	/^  Integrator2D &operator = (const Value2D &a);$/;"	p	class:simlib3::Integrator2D	access:public	signature:(const Value2D &a)
operator =	simlib2D.h	/^  Parameter2D &operator= (const Value2D &x);$/;"	p	class:simlib3::Parameter2D	access:public	signature:(const Value2D &x)
operator =	simlib2D.h	/^  Variable2D &operator= (Value2D x)  { value = x; return *this; }$/;"	f	class:simlib3::Variable2D	access:public	signature:(Value2D x)
operator =	simlib2D.h	/^  void operator= (aContiBlock2D&);     \/\/ disable assignment$/;"	p	class:simlib3::aContiBlock2D	access:private	signature:(aContiBlock2D&)
operator =	simlib3D.cc	/^Integrator3D &Integrator3D::operator = (Input3D i)$/;"	f	class:simlib3::Integrator3D	signature:(Input3D i)
operator =	simlib3D.cc	/^Integrator3D &Integrator3D::operator = (const Value3D &a)$/;"	f	class:simlib3::Integrator3D	signature:(const Value3D &a)
operator =	simlib3D.cc	/^Parameter3D &Parameter3D::operator= (const Value3D &x)    {$/;"	f	class:simlib3::Parameter3D	signature:(const Value3D &x)
operator =	simlib3D.h	/^  Input3D&operator=(const Input3D &in) { bp = in.bp; return *this; }$/;"	f	class:simlib3::Input3D	access:public	signature:(const Input3D &in)
operator =	simlib3D.h	/^  Integrator3D &operator = (Input3D i);$/;"	p	class:simlib3::Integrator3D	access:public	signature:(Input3D i)
operator =	simlib3D.h	/^  Integrator3D &operator = (const Value3D &a);$/;"	p	class:simlib3::Integrator3D	access:public	signature:(const Value3D &a)
operator =	simlib3D.h	/^  Parameter3D &operator= (const Value3D &x);$/;"	p	class:simlib3::Parameter3D	access:public	signature:(const Value3D &x)
operator =	simlib3D.h	/^  Variable3D &operator= (Value3D x) { value = x; return *this; }$/;"	f	class:simlib3::Variable3D	access:public	signature:(Value3D x)
operator =	simlib3D.h	/^  void operator= (aContiBlock3D&);     \/\/ disable assignment$/;"	p	class:simlib3::aContiBlock3D	access:private	signature:(aContiBlock3D&)
operator =	zdelay.h	/^    ZDelayTimer&operator=(const ZDelayTimer&); \/\/ ##$/;"	p	class:simlib3::ZDelayTimer	access:private	signature:(const ZDelayTimer&)
operator =	zdelay.h	/^    void operator= (const ZDelay&);     \/\/ disable assignment$/;"	p	class:simlib3::ZDelay	access:private	signature:(const ZDelay&)
operator ==	calendar.cc	/^      bool operator == (iterator q) { return p==q.p; }$/;"	f	class:simlib3::CalendarListImplementation::iterator	access:public	signature:(iterator q)
operator ==	delay.cc	/^        bool operator == (Pair &p) { return p.time==time && p.value==value; }$/;"	f	struct:simlib3::SIMLIB_DelayBuffer::Pair	access:public	signature:(Pair &p)
operator ==	opt-param.cc	/^bool operator == (const ParameterVector & p1, const ParameterVector & p2) {$/;"	f	namespace:simlib3	signature:(const ParameterVector & p1, const ParameterVector & p2)
operator ==	optimize.h	/^    friend bool operator == (const ParameterVector & p1,$/;"	p	class:simlib3::ParameterVector	access:friend	signature:(const ParameterVector & p1, const ParameterVector & p2)
operator ==	simlib.h	/^            bool operator == (iterator q) const { return p==q.p; }$/;"	f	class:simlib3::List::iterator	access:public	signature:(iterator q) const
operator ==	simlib.h	/^  bool operator ==(aContiBlock *p) const { return bp==p; } \/\/ for tests only$/;"	f	class:simlib3::Input	access:public	signature:(aContiBlock *p) const
operator ==	simlib2D.h	/^  bool operator ==(void *p) { return bp==p; }         \/\/ for tests only!$/;"	f	class:simlib3::Input2D	access:public	signature:(void *p)
operator ==	simlib3D.h	/^  bool operator ==(void *p)       { return bp==p; }         \/\/ for tests only!$/;"	f	class:simlib3::Input3D	access:public	signature:(void *p)
operator Entity*	simlib.h	/^    operator Entity* () { return this; } \/\/ default conversion$/;"	f	class:simlib3::Entity	access:public	signature:()
operator FILE *	print.cc	/^    operator FILE *()           { return get(); }$/;"	f	class:simlib3::_FileWrap	access:public	signature:()
operator Facility*	simlib.h	/^  operator Facility* () { return this; }$/;"	f	class:simlib3::Facility	access:public	signature:()
operator Queue*	simlib.h	/^    operator Queue* () { return this; }  \/\/ allows Queue instead Queue*$/;"	f	class:simlib3::Queue	access:public	signature:()
operator Semaphore*	simlib.h	/^  operator Semaphore* () { return this; }$/;"	f	class:simlib3::Semaphore	access:public	signature:()
operator Store*	simlib.h	/^  operator Store* () { return this; }$/;"	f	class:simlib3::Store	access:public	signature:()
operator ZDelayTimer *	zdelay.h	/^    operator ZDelayTimer * () { return this; }$/;"	f	class:simlib3::ZDelayTimer	access:public	signature:()
operator []	histo.cc	/^unsigned Histogram::operator [] (unsigned i) const$/;"	f	class:simlib3::Histogram	signature:(unsigned i) const
operator []	optimize.h	/^    Param & operator[] (int i) { return p[i]; }$/;"	f	class:simlib3::ParameterVector	access:public	signature:(int i)
operator []	optimize.h	/^    Param & operator[](const char *name) {$/;"	f	class:simlib3::ParameterVector	access:public	signature:(const char *name)
operator []	optimize.h	/^    const Param & operator[] (int i) const { return p[i]; }$/;"	f	class:simlib3::ParameterVector	access:public	signature:(int i) const
operator []	simlib.h	/^      double& operator[](size_t ind) {  \/\/ access the element of the array$/;"	f	class:simlib3::IntegrationMethod::Memory	access:public	signature:(size_t ind)
operator []	simlib.h	/^  unsigned operator [](unsigned i) const;  \/\/ # of items in interval[i]$/;"	p	class:simlib3::Histogram	access:public	signature:(unsigned i) const
operator delete	object.cc	/^void SimObject::operator delete(void *ptr) {$/;"	f	class:simlib3::SimObject	signature:(void *ptr)
operator delete	simlib.h	/^  void operator delete(void *ptr);     \/\/!< deallocate object$/;"	p	class:simlib3::SimObject	access:public	signature:(void *ptr)
operator double	optimize.h	/^    operator double () const { return value; }$/;"	f	class:simlib3::Param	access:public	signature:() const
operator new	object.cc	/^void *SimObject::operator new(size_t size) {$/;"	f	class:simlib3::SimObject	signature:(size_t size)
operator new	simlib.h	/^  void *operator new(size_t size);     \/\/!< allocate object, set _flags$/;"	p	class:simlib3::SimObject	access:public	signature:(size_t size)
opt_function_t	optimize.h	/^typedef double (*opt_function_t) (const ParameterVector & p);$/;"	t	namespace:simlib3
p	calendar.cc	/^      EventNoticeLinkBase *p;$/;"	m	class:simlib3::CalendarListImplementation::iterator	file:	access:private
p	optimize.h	/^    Param *p;$/;"	m	class:simlib3::ParameterVector	access:private
p	simlib.h	/^            Link *p; \/\/ position in List$/;"	m	class:simlib3::List::iterator	access:private
p1	simlib.h	/^    double p1,p2;$/;"	m	class:simlib3::Hyst	access:protected
p1	simlib.h	/^  double p1,p2,p3,p4;           \/\/ points on x-axis$/;"	m	class:simlib3::Relay	access:protected
p1	simlib.h	/^  double p1,p2;$/;"	m	class:simlib3::Blash	access:protected
p2	simlib.h	/^    double p1,p2;$/;"	m	class:simlib3::Hyst	access:protected
p2	simlib.h	/^  double p1,p2,p3,p4;           \/\/ points on x-axis$/;"	m	class:simlib3::Relay	access:protected
p2	simlib.h	/^  double p1,p2;$/;"	m	class:simlib3::Blash	access:protected
p3	simlib.h	/^  double p1,p2,p3,p4;           \/\/ points on x-axis$/;"	m	class:simlib3::Relay	access:protected
p4	simlib.h	/^  double p1,p2,p3,p4;           \/\/ points on x-axis$/;"	m	class:simlib3::Relay	access:protected
page_size	numint.cc	/^const size_t IntegrationMethod::Memory::page_size = 256;$/;"	m	class:simlib3::IntegrationMethod::Memory	file:
page_size	simlib.h	/^      static const size_t page_size;  \/\/ size of memory page$/;"	m	class:simlib3::IntegrationMethod::Memory	access:private
phase	simlib.h	/^  int phase; \/\/ phase of computation$/;"	m	class:simlib3::AlgLoop	access:protected
prec	ni_fw.cc	/^const double FW::prec = DBL_EPSILON; \/\/ near zero number$/;"	m	class:simlib3::FW	file:
prec	ni_fw.h	/^  static const double prec; \/\/ near zero number$/;"	m	class:simlib3::FW	access:protected
pred	calendar.cc	/^    EventNoticeLinkBase * pred;         \/\/!< previous object in list$/;"	m	struct:simlib3::EventNoticeLinkBase	file:	access:public
pred	simlib.h	/^  Link *pred;                          \/\/!< previous object in List$/;"	m	class:simlib3::Link	access:private
prev_root	simlib.h	/^  double prev_root; \/\/ root from previous iteration step$/;"	m	class:simlib3::Newton	access:private
previous	simlib.h	/^    static Link *previous(Link*p)       { return p->pred; }$/;"	f	class:simlib3::List	access:private	signature:(Link*p)
priority	calendar.cc	/^    Entity::Priority_t priority;$/;"	m	struct:simlib3::EventNotice	file:	access:public
put	delay.cc	/^    virtual void put(double value, double time) = 0;    \/\/!< store value$/;"	p	struct:simlib3::Delay::Buffer	file:	access:public	signature:(double value, double time)
put	delay.cc	/^    virtual void put(double value, double time) {$/;"	f	class:simlib3::SIMLIB_DelayBuffer	access:public	signature:(double value, double time)
put	delay.h	/^        virtual void put(double value, double time) = 0; \/\/!< sample$/;"	p	struct:simlib3::Delay::Buffer	access:public	signature:(double value, double time)
rdtsc	rdtsc.h	/^static __inline__ unsigned long long rdtsc(void)$/;"	f	signature:(void)
remove	calendar.cc	/^    Entity *remove(Entity *e) {$/;"	f	class:simlib3::CalendarListImplementation	access:public	signature:(Entity *e)
remove	calendar.cc	/^    void remove() {$/;"	f	struct:simlib3::EventNoticeLinkBase	access:public	signature:()
remove_first	calendar.cc	/^    Entity *remove_first() {$/;"	f	class:simlib3::CalendarListImplementation	access:public	signature:()
root	simlib.h	/^  double root; \/\/ root of equation$/;"	m	class:simlib3::AlgLoop	access:protected
scalar_product	simlib2D.cc	/^double scalar_product(const Value2D& a, const Value2D &b)$/;"	f	namespace:simlib3	signature:(const Value2D& a, const Value2D &b)
scalar_product	simlib2D.h	/^  friend double scalar_product(const Value2D& a, const Value2D &b);$/;"	p	class:simlib3::Value2D	access:friend	signature:(const Value2D& a, const Value2D &b)
scalar_product	simlib3D.cc	/^double scalar_product(const Value3D& a, const Value3D &b)$/;"	f	namespace:simlib3	signature:(const Value3D& a, const Value3D &b)
scalar_product	simlib3D.h	/^  friend double scalar_product(const Value3D& a, const Value3D &b);$/;"	p	class:simlib3::Value3D	access:friend	signature:(const Value3D& a, const Value3D &b)
search	calendar.cc	/^    iterator search(EventNotice *en) {$/;"	f	class:simlib3::CalendarListImplementation	file:	access:private	signature:(EventNotice *en)
search	opt-param.cc	/^int ParameterVector::search(const char *name)$/;"	f	class:simlib3::ParameterVector	signature:(const char *name)
search	optimize.h	/^    int search(const char *name);$/;"	p	class:simlib3::ParameterVector	access:private	signature:(const char *name)
si	ni_euler.h	/^  Memory si, di, A;  \/\/ auxiliary memories$/;"	m	class:simlib3::EULER	access:private
si	ni_rke.h	/^  Memory si, di;$/;"	m	class:simlib3::RKE	access:private
sign	fun.cc	/^static double sign(double x)$/;"	f	namespace:simlib3	signature:(double x)
simlib3	algloop.cc	/^namespace simlib3 {$/;"	n	file:
simlib3	atexit.cc	/^namespace simlib3 {$/;"	n	file:
simlib3	barrier.cc	/^namespace simlib3 {$/;"	n	file:
simlib3	calendar.cc	/^namespace simlib3 {$/;"	n	file:
simlib3	cond.cc	/^namespace simlib3 {$/;"	n	file:
simlib3	continuous.cc	/^namespace simlib3 {$/;"	n	file:
simlib3	debug.cc	/^namespace simlib3 {$/;"	n	file:
simlib3	delay.cc	/^namespace simlib3 {$/;"	n	file:
simlib3	delay.h	/^namespace simlib3 {$/;"	n
simlib3	entity.cc	/^namespace simlib3 {$/;"	n	file:
simlib3	error.cc	/^namespace simlib3 {$/;"	n	file:
simlib3	errors.cc	/^namespace simlib3 {$/;"	n	file:
simlib3	event.cc	/^namespace simlib3 {$/;"	n	file:
simlib3	facility.cc	/^namespace simlib3 {$/;"	n	file:
simlib3	fun.cc	/^namespace simlib3 {$/;"	n	file:
simlib3	graph.cc	/^namespace simlib3 {$/;"	n	file:
simlib3	histo.cc	/^namespace simlib3 {$/;"	n	file:
simlib3	internal.h	/^namespace simlib3 {$/;"	n
simlib3	intg.cc	/^namespace simlib3 {$/;"	n	file:
simlib3	link.cc	/^namespace simlib3 {$/;"	n	file:
simlib3	list.cc	/^namespace simlib3 {$/;"	n	file:
simlib3	name.cc	/^namespace simlib3 {$/;"	n	file:
simlib3	ni_abm4.cc	/^namespace simlib3 {$/;"	n	file:
simlib3	ni_abm4.h	/^namespace simlib3 {$/;"	n
simlib3	ni_euler.cc	/^namespace simlib3 {$/;"	n	file:
simlib3	ni_euler.h	/^namespace simlib3 {$/;"	n
simlib3	ni_fw.cc	/^namespace simlib3 {$/;"	n	file:
simlib3	ni_fw.h	/^namespace simlib3 {$/;"	n
simlib3	ni_rke.cc	/^namespace simlib3 {$/;"	n	file:
simlib3	ni_rke.h	/^namespace simlib3 {$/;"	n
simlib3	ni_rkf3.cc	/^namespace simlib3 {$/;"	n	file:
simlib3	ni_rkf3.h	/^namespace simlib3 {$/;"	n
simlib3	ni_rkf5.cc	/^namespace simlib3 {$/;"	n	file:
simlib3	ni_rkf5.h	/^namespace simlib3 {$/;"	n
simlib3	ni_rkf8.cc	/^namespace simlib3 {$/;"	n	file:
simlib3	ni_rkf8.h	/^namespace simlib3 {$/;"	n
simlib3	numint.cc	/^namespace simlib3 {$/;"	n	file:
simlib3	object.cc	/^namespace simlib3 {$/;"	n	file:
simlib3	opt-hooke.cc	/^namespace simlib3 {$/;"	n	file:
simlib3	opt-param.cc	/^namespace simlib3 {$/;"	n	file:
simlib3	opt-simann.cc	/^namespace simlib3 {$/;"	n	file:
simlib3	optimize.h	/^namespace simlib3 {$/;"	n
simlib3	output1.cc	/^namespace simlib3 {$/;"	n	file:
simlib3	output2.cc	/^namespace simlib3 {$/;"	n	file:
simlib3	print.cc	/^namespace simlib3 {$/;"	n	file:
simlib3	process.cc	/^namespace simlib3 {$/;"	n	file:
simlib3	queue.cc	/^namespace simlib3 {$/;"	n	file:
simlib3	random1.cc	/^namespace simlib3 {$/;"	n	file:
simlib3	random2.cc	/^namespace simlib3 {$/;"	n	file:
simlib3	run.cc	/^namespace simlib3 {$/;"	n	file:
simlib3	sampler.cc	/^namespace simlib3 {$/;"	n	file:
simlib3	semaphor.cc	/^namespace simlib3 {$/;"	n	file:
simlib3	simlib.h	/^namespace simlib3 {$/;"	n
simlib3	simlib2D.cc	/^namespace simlib3 {$/;"	n	file:
simlib3	simlib2D.h	/^namespace simlib3 {$/;"	n
simlib3	simlib3D.cc	/^namespace simlib3 {$/;"	n	file:
simlib3	simlib3D.h	/^namespace simlib3 {$/;"	n
simlib3	stat.cc	/^namespace simlib3 {$/;"	n	file:
simlib3	stdblock.cc	/^namespace simlib3 {$/;"	n	file:
simlib3	store.cc	/^namespace simlib3 {$/;"	n	file:
simlib3	tstat.cc	/^namespace simlib3 {$/;"	n	file:
simlib3	version.cc	/^namespace simlib3 {$/;"	n	file:
simlib3	waitunti.cc	/^namespace simlib3 {$/;"	n	file:
simlib3	zdelay.cc	/^namespace simlib3 {$/;"	n	file:
simlib3	zdelay.h	/^namespace simlib3 {$/;"	n
simlib3::ABM4	ni_abm4.h	/^class ABM4 : public MultiStepMethod {$/;"	c	namespace:simlib3	inherits:MultiStepMethod
simlib3::ABM4::ABM4	ni_abm4.h	/^  ABM4(const char* name, const char* slave_name):$/;"	f	class:simlib3::ABM4	access:public	signature:(const char* name, const char* slave_name)
simlib3::ABM4::ABM_Count	ni_abm4.h	/^  int ABM_Count;  \/\/ # of start steps (done by starting method)$/;"	m	class:simlib3::ABM4	access:private
simlib3::ABM4::Integrate	ni_abm4.cc	/^void ABM4::Integrate(void)$/;"	f	class:simlib3::ABM4	signature:(void)
simlib3::ABM4::Integrate	ni_abm4.h	/^  virtual void Integrate(void);  \/\/ integration method$/;"	p	class:simlib3::ABM4	access:public	signature:(void)
simlib3::ABM4::PRED	ni_abm4.h	/^  Memory PRED;  \/\/ auxiliary memories -- value of predictor$/;"	m	class:simlib3::ABM4	access:private
simlib3::ABM4::PrepareStep	ni_abm4.cc	/^bool ABM4::PrepareStep(void)$/;"	f	class:simlib3::ABM4	signature:(void)
simlib3::ABM4::PrepareStep	ni_abm4.h	/^  virtual bool PrepareStep(void);  \/\/ prepare object for integration step$/;"	p	class:simlib3::ABM4	access:public	signature:(void)
simlib3::ABM4::Z	ni_abm4.h	/^  Memory Z[abm_ord];  \/\/ auxiliary memories$/;"	m	class:simlib3::ABM4	access:private
simlib3::ABM4::~ABM4	ni_abm4.h	/^  virtual ~ABM4()  \/\/ destructor$/;"	f	class:simlib3::ABM4	access:public	signature:()
simlib3::ACos	fun.cc	/^Input ACos(Input x)             { return new Function1(x, acos); }$/;"	f	namespace:simlib3	signature:(Input x)
simlib3::ACos	simlib.h	/^Input ACos(Input x);            \/\/ acos(x)$/;"	p	namespace:simlib3	signature:(Input x)
simlib3::ASin	fun.cc	/^Input ASin(Input x)             { return new Function1(x, asin); }$/;"	f	namespace:simlib3	signature:(Input x)
simlib3::ASin	simlib.h	/^Input ASin(Input x);            \/\/ asin(x)$/;"	p	namespace:simlib3	signature:(Input x)
simlib3::ATan	fun.cc	/^Input ATan(Input x)             { return new Function1(x, atan); }$/;"	f	namespace:simlib3	signature:(Input x)
simlib3::ATan	simlib.h	/^Input ATan(Input x);            \/\/ atan(x)$/;"	p	namespace:simlib3	signature:(Input x)
simlib3::ATan2	fun.cc	/^Input ATan2(Input y, Input x)   { return new Function2(y, x, atan2); }$/;"	f	namespace:simlib3	signature:(Input y, Input x)
simlib3::ATan2	simlib.h	/^Input ATan2(Input y, Input x);  \/\/ atan2(y,x)$/;"	p	namespace:simlib3	signature:(Input y, Input x)
simlib3::Abort	run.cc	/^void Abort()$/;"	f	namespace:simlib3	signature:()
simlib3::Abort	simlib.h	/^void Abort();$/;"	p	namespace:simlib3	signature:()
simlib3::Abs	fun.cc	/^Input Abs(Input x)              { return new Function1(x, fabs); }$/;"	f	namespace:simlib3	signature:(Input x)
simlib3::Abs	simlib.h	/^Input Abs(Input x);             \/\/ abs(x)     absolute value$/;"	p	namespace:simlib3	signature:(Input x)
simlib3::Abs	simlib2D.cc	/^Input Abs(Input2D x) { return new _Abs2D(x); } \/\/ absolute value of vector x$/;"	f	namespace:simlib3	signature:(Input2D x)
simlib3::Abs	simlib2D.h	/^Input Abs(Input2D x);$/;"	p	namespace:simlib3	signature:(Input2D x)
simlib3::Abs	simlib3D.cc	/^Input Abs(Input3D x) { return new _Abs3D(x); } \/\/ absolute value of vector x$/;"	f	namespace:simlib3	signature:(Input3D x)
simlib3::Abs	simlib3D.h	/^Input   Abs(Input3D x);$/;"	p	namespace:simlib3	signature:(Input3D x)
simlib3::AbsoluteError	intg.cc	/^const double &AbsoluteError=SIMLIB_AbsoluteError; \/\/!< max. abs. error of integration$/;"	m	namespace:simlib3	file:
simlib3::Activate	simlib.h	/^inline void Activate(Entity *e)  { e->Activate(); }   \/\/!< activate entity e$/;"	f	namespace:simlib3	signature:(Entity *e)
simlib3::Adaptor2D	simlib2D.h	/^class Adaptor2D : public aContiBlock2D {$/;"	c	namespace:simlib3	inherits:aContiBlock2D
simlib3::Adaptor2D::Adaptor2D	simlib2D.h	/^  Adaptor2D(Input _x, Input _y) : x(_x), y(_y) {}$/;"	f	class:simlib3::Adaptor2D	access:public	signature:(Input _x, Input _y)
simlib3::Adaptor2D::Value	simlib2D.h	/^  virtual Value2D Value() {$/;"	f	class:simlib3::Adaptor2D	access:public	signature:()
simlib3::Adaptor2D::x	simlib2D.h	/^  Input x, y;$/;"	m	class:simlib3::Adaptor2D	access:private
simlib3::Adaptor2D::y	simlib2D.h	/^  Input x, y;$/;"	m	class:simlib3::Adaptor2D	access:private
simlib3::Adaptor3D	simlib3D.h	/^class Adaptor3D : public aContiBlock3D {$/;"	c	namespace:simlib3	inherits:aContiBlock3D
simlib3::Adaptor3D::Adaptor3D	simlib3D.h	/^  Adaptor3D(Input _x, Input _y, Input _z) : x(_x), y(_y), z(_z) {}$/;"	f	class:simlib3::Adaptor3D	access:public	signature:(Input _x, Input _y, Input _z)
simlib3::Adaptor3D::Value	simlib3D.h	/^  virtual Value3D Value() {$/;"	f	class:simlib3::Adaptor3D	access:public	signature:()
simlib3::Adaptor3D::x	simlib3D.h	/^  Input x, y, z;$/;"	m	class:simlib3::Adaptor3D	access:private
simlib3::Adaptor3D::y	simlib3D.h	/^  Input x, y, z;$/;"	m	class:simlib3::Adaptor3D	access:private
simlib3::Adaptor3D::z	simlib3D.h	/^  Input x, y, z;$/;"	m	class:simlib3::Adaptor3D	access:private
simlib3::AlgLoop	simlib.h	/^class AlgLoop : public aContiBlock1 {$/;"	c	namespace:simlib3	inherits:aContiBlock1
simlib3::AlgLoop::AlgLoop	algloop.cc	/^AlgLoop::AlgLoop(Input i, double eps, unsigned long max_it,$/;"	f	class:simlib3::AlgLoop	signature:(Input i, double eps, unsigned long max_it, double t_min, double t_max, double t0)
simlib3::AlgLoop::AlgLoop	simlib.h	/^  AlgLoop(Input i, double eps, unsigned long max_it, \/\/ constructor$/;"	p	class:simlib3::AlgLoop	access:public	signature:(Input i, double eps, unsigned long max_it, double t_min, double t_max, double t0)
simlib3::AlgLoop::Eps	simlib.h	/^  double Eps; \/\/ required accuracy$/;"	m	class:simlib3::AlgLoop	access:protected
simlib3::AlgLoop::MaxIt	simlib.h	/^  unsigned long MaxIt; \/\/ max. number of iterations$/;"	m	class:simlib3::AlgLoop	access:protected
simlib3::AlgLoop::Name	algloop.cc	/^const char *AlgLoop::Name() const$/;"	f	class:simlib3::AlgLoop	signature:() const
simlib3::AlgLoop::Name	simlib.h	/^  virtual const char *Name() const;$/;"	p	class:simlib3::AlgLoop	access:public	signature:() const
simlib3::AlgLoop::Set	algloop.cc	/^void AlgLoop::Set(double eps, unsigned long max_it,$/;"	f	class:simlib3::AlgLoop	signature:(double eps, unsigned long max_it, double t_min, double t_max)
simlib3::AlgLoop::Set	algloop.cc	/^void AlgLoop::Set(double eps, unsigned long max_it,$/;"	f	class:simlib3::AlgLoop	signature:(double eps, unsigned long max_it, double t_min, double t_max, double t0)
simlib3::AlgLoop::Set	simlib.h	/^  void Set(double eps, unsigned long max_it, \/\/ set parameters$/;"	p	class:simlib3::AlgLoop	access:public	signature:(double eps, unsigned long max_it, double t_min, double t_max)
simlib3::AlgLoop::Set	simlib.h	/^  void Set(double eps, unsigned long max_it, \/\/ set parameters$/;"	p	class:simlib3::AlgLoop	access:public	signature:(double eps, unsigned long max_it, double t_min, double t_max, double t0)
simlib3::AlgLoop::T0	simlib.h	/^  double T0; \/\/ initial value$/;"	m	class:simlib3::AlgLoop	access:protected
simlib3::AlgLoop::TA	simlib.h	/^  double TA; \/\/ boundary values of interval$/;"	m	class:simlib3::AlgLoop	access:protected
simlib3::AlgLoop::TB	simlib.h	/^  double TB; \/\/ (also used for convergency check)$/;"	m	class:simlib3::AlgLoop	access:protected
simlib3::AlgLoop::Value	simlib.h	/^  virtual double Value()=0; \/\/ returned value$/;"	p	class:simlib3::AlgLoop	access:public	signature:()
simlib3::AlgLoop::phase	simlib.h	/^  int phase; \/\/ phase of computation$/;"	m	class:simlib3::AlgLoop	access:protected
simlib3::AlgLoop::root	simlib.h	/^  double root; \/\/ root of equation$/;"	m	class:simlib3::AlgLoop	access:protected
simlib3::AlgLoop::was_cycle	simlib.h	/^  bool was_cycle; \/\/ flag for going through loop$/;"	m	class:simlib3::AlgLoop	access:protected
simlib3::AlgLoopDetector	internal.h	/^class AlgLoopDetector {$/;"	c	namespace:simlib3
simlib3::AlgLoopDetector::AlgLoopDetector	internal.h	/^    AlgLoopDetector(aContiBlock *x): block(x)  { lock(); }$/;"	f	class:simlib3::AlgLoopDetector	access:public	signature:(aContiBlock *x)
simlib3::AlgLoopDetector::block	internal.h	/^    aContiBlock *block;$/;"	m	class:simlib3::AlgLoopDetector	access:private
simlib3::AlgLoopDetector::lock	internal.h	/^    void lock() {$/;"	f	class:simlib3::AlgLoopDetector	access:private	signature:()
simlib3::AlgLoopDetector::unlock	internal.h	/^    void unlock() {$/;"	f	class:simlib3::AlgLoopDetector	access:private	signature:()
simlib3::AlgLoopDetector::~AlgLoopDetector	internal.h	/^    ~AlgLoopDetector() { unlock(); }$/;"	f	class:simlib3::AlgLoopDetector	access:public	signature:()
simlib3::Alloc	histo.cc	/^static unsigned *Alloc(unsigned n)$/;"	f	namespace:simlib3	signature:(unsigned n)
simlib3::Backlash	simlib.h	/^typedef Blash Backlash; \/\/ alias$/;"	t	namespace:simlib3
simlib3::Barrier	simlib.h	/^class Barrier : public SimObject {$/;"	c	namespace:simlib3	inherits:SimObject
simlib3::Barrier::Barrier	barrier.cc	/^Barrier::Barrier(const char *name, unsigned height):$/;"	f	class:simlib3::Barrier	signature:(const char *name, unsigned height)
simlib3::Barrier::Barrier	barrier.cc	/^Barrier::Barrier(unsigned height):$/;"	f	class:simlib3::Barrier	signature:(unsigned height)
simlib3::Barrier::Barrier	simlib.h	/^  Barrier(const Barrier&);              \/\/ ## disable$/;"	p	class:simlib3::Barrier	access:private	signature:(const Barrier&)
simlib3::Barrier::Barrier	simlib.h	/^  Barrier(const char *_name, unsigned N);$/;"	p	class:simlib3::Barrier	access:public	signature:(const char *_name, unsigned N)
simlib3::Barrier::Barrier	simlib.h	/^  Barrier(unsigned N);$/;"	p	class:simlib3::Barrier	access:public	signature:(unsigned N)
simlib3::Barrier::Break	barrier.cc	/^int Barrier::Break() {$/;"	f	class:simlib3::Barrier	signature:()
simlib3::Barrier::Break	simlib.h	/^  virtual int Break();                  \/\/!< activate all waiting entities$/;"	p	class:simlib3::Barrier	access:public	signature:()
simlib3::Barrier::ChangeHeight	barrier.cc	/^void Barrier::ChangeHeight(unsigned new_height) {$/;"	f	class:simlib3::Barrier	signature:(unsigned new_height)
simlib3::Barrier::ChangeHeight	simlib.h	/^  void ChangeHeight(unsigned new_maxn);         \/\/!< change size$/;"	p	class:simlib3::Barrier	access:public	signature:(unsigned new_maxn)
simlib3::Barrier::Clear	barrier.cc	/^void Barrier::Clear() {$/;"	f	class:simlib3::Barrier	signature:()
simlib3::Barrier::Clear	simlib.h	/^  virtual void Clear();                 \/\/!< initialization$/;"	p	class:simlib3::Barrier	access:public	signature:()
simlib3::Barrier::Enter	barrier.cc	/^void Barrier::Enter(Entity * e) \/\/TODO without parameter: use Current?$/;"	f	class:simlib3::Barrier	signature:(Entity * e)
simlib3::Barrier::Enter	simlib.h	/^  virtual void Enter(Entity *e);        \/\/!< wait for barrier break TODO: remove\/rename$/;"	p	class:simlib3::Barrier	access:public	signature:(Entity *e)
simlib3::Barrier::Height	simlib.h	/^  unsigned Height() const { return maxn; }      \/\/!< barrier size$/;"	f	class:simlib3::Barrier	access:public	signature:() const
simlib3::Barrier::Init	barrier.cc	/^void Barrier::Init() {$/;"	f	class:simlib3::Barrier	signature:()
simlib3::Barrier::Init	simlib.h	/^  void Init();          \/\/!< initialization$/;"	p	class:simlib3::Barrier	access:protected	signature:()
simlib3::Barrier::Output	barrier.cc	/^void Barrier::Output() const {$/;"	f	class:simlib3::Barrier	signature:() const
simlib3::Barrier::Output	simlib.h	/^  virtual void Output() const;          \/\/!< print status$/;"	p	class:simlib3::Barrier	access:public	signature:() const
simlib3::Barrier::Wait	barrier.cc	/^bool Barrier::Wait()$/;"	f	class:simlib3::Barrier	signature:()
simlib3::Barrier::Wait	simlib.h	/^  virtual bool Wait();                  \/\/!< wait for barrier break (Current)$/;"	p	class:simlib3::Barrier	access:public	signature:()
simlib3::Barrier::maxn	simlib.h	/^  unsigned maxn;        \/\/!< barrier height\/size$/;"	m	class:simlib3::Barrier	access:protected
simlib3::Barrier::n	simlib.h	/^  unsigned n;           \/\/!< current number of waiting entities$/;"	m	class:simlib3::Barrier	access:protected
simlib3::Barrier::operator =	simlib.h	/^  Barrier&operator=(const Barrier&);    \/\/ ## disable$/;"	p	class:simlib3::Barrier	access:private	signature:(const Barrier&)
simlib3::Barrier::waiting	simlib.h	/^  Entity **waiting;     \/\/!< array of waiting entities (fixed size)$/;"	m	class:simlib3::Barrier	access:protected
simlib3::Barrier::~Barrier	barrier.cc	/^Barrier::~Barrier() {$/;"	f	class:simlib3::Barrier	signature:()
simlib3::Barrier::~Barrier	simlib.h	/^  virtual ~Barrier();$/;"	p	class:simlib3::Barrier	access:public	signature:()
simlib3::Beta	random2.cc	/^double Beta(double th, double fi, double min, double max)$/;"	f	namespace:simlib3	signature:(double th, double fi, double min, double max)
simlib3::Beta	simlib.h	/^double Beta(double th, double fi, double min, double max);$/;"	p	namespace:simlib3	signature:(double th, double fi, double min, double max)
simlib3::Bisect	simlib.h	/^class Bisect : public AlgLoop {$/;"	c	namespace:simlib3	inherits:AlgLoop
simlib3::Bisect::Bisect	simlib.h	/^  Bisect(Input i, double eps, unsigned long max_it,$/;"	f	class:simlib3::Bisect	access:public	signature:(Input i, double eps, unsigned long max_it, double t_min, double t_max)
simlib3::Bisect::Value	algloop.cc	/^double Bisect::Value()$/;"	f	class:simlib3::Bisect	signature:()
simlib3::Bisect::Value	simlib.h	/^  virtual double Value(); \/\/ returned value$/;"	p	class:simlib3::Bisect	access:public	signature:()
simlib3::Blash	simlib.h	/^class Blash : public Status {    \/\/ backlash$/;"	c	namespace:simlib3	inherits:Status
simlib3::Blash::Blash	simlib.h	/^  Blash(Input i, double p1, double p2, double tga);$/;"	p	class:simlib3::Blash	access:public	signature:(Input i, double p1, double p2, double tga)
simlib3::Blash::Blash	stdblock.cc	/^Blash::Blash(Input i, double _p1, double _p2, double _tga)$/;"	f	class:simlib3::Blash	signature:(Input i, double _p1, double _p2, double _tga)
simlib3::Blash::Eval	simlib.h	/^  virtual void Eval();           \/\/ block evaluation$/;"	p	class:simlib3::Blash	access:public	signature:()
simlib3::Blash::Eval	stdblock.cc	/^void Blash::Eval()$/;"	f	class:simlib3::Blash	signature:()
simlib3::Blash::Name	simlib.h	/^  virtual const char *Name() const;$/;"	p	class:simlib3::Blash	access:public	signature:() const
simlib3::Blash::Name	stdblock.cc	/^const char *Blash::Name() const$/;"	f	class:simlib3::Blash	signature:() const
simlib3::Blash::p1	simlib.h	/^  double p1,p2;$/;"	m	class:simlib3::Blash	access:protected
simlib3::Blash::p2	simlib.h	/^  double p1,p2;$/;"	m	class:simlib3::Blash	access:protected
simlib3::Blash::tga	simlib.h	/^  double tga;$/;"	m	class:simlib3::Blash	access:protected
simlib3::COEF_PAR	calendar.cc	/^const double COEF_PAR     = 1.5;  \/\/ TODO:tune parameter: cca 1.5$/;"	m	namespace:simlib3	file:
simlib3::Calendar	calendar.cc	/^class Calendar { \/\/ abstract base class$/;"	c	namespace:simlib3	file:
simlib3::Calendar::Calendar	calendar.cc	/^    Calendar(): _size(0), mintime(SIMLIB_MAXTIME) {}$/;"	f	class:simlib3::Calendar	access:protected	signature:()
simlib3::Calendar::Empty	calendar.cc	/^    bool     Empty() const { return _size == 0; }$/;"	f	class:simlib3::Calendar	access:public	signature:() const
simlib3::Calendar::Get	calendar.cc	/^    virtual Entity * Get(Entity *e) = 0;$/;"	p	class:simlib3::Calendar	file:	access:public	signature:(Entity *e)
simlib3::Calendar::GetFirst	calendar.cc	/^    virtual Entity * GetFirst() = 0;$/;"	p	class:simlib3::Calendar	file:	access:public	signature:()
simlib3::Calendar::MinTime	calendar.cc	/^    double MinTime() const { return mintime; }$/;"	f	class:simlib3::Calendar	access:public	signature:() const
simlib3::Calendar::ScheduleAt	calendar.cc	/^    virtual void     ScheduleAt(Entity *e, double t) = 0;$/;"	p	class:simlib3::Calendar	file:	access:public	signature:(Entity *e, double t)
simlib3::Calendar::SetCalendar	calendar.cc	/^  friend void SetCalendar(const char *name); \/\/ sets _instance$/;"	p	class:simlib3::Calendar	file:	access:friend	signature:(const char *name)
simlib3::Calendar::SetMinTime	calendar.cc	/^    void SetMinTime(double t) { mintime=t; }$/;"	f	class:simlib3::Calendar	access:protected	signature:(double t)
simlib3::Calendar::Size	calendar.cc	/^    unsigned Size()  const { return _size; }$/;"	f	class:simlib3::Calendar	access:public	signature:() const
simlib3::Calendar::_instance	calendar.cc	/^    static Calendar * _instance;        \/\/!< pointer to single instance$/;"	m	class:simlib3::Calendar	file:	access:private
simlib3::Calendar::_instance	calendar.cc	/^Calendar * Calendar::_instance = 0;$/;"	m	class:simlib3::Calendar	file:
simlib3::Calendar::_size	calendar.cc	/^    unsigned _size;     \/\/!< number of scheduled items$/;"	m	class:simlib3::Calendar	file:	access:protected
simlib3::Calendar::clear	calendar.cc	/^    virtual void clear(bool destroy_entities=false) = 0;$/;"	p	class:simlib3::Calendar	file:	access:public	signature:(bool destroy_entities=false)
simlib3::Calendar::debug_print	calendar.cc	/^    virtual void debug_print() = 0;     \/\/ print the calendar contents$/;"	p	class:simlib3::Calendar	file:	access:public	signature:()
simlib3::Calendar::delete_instance	calendar.cc	/^    static void delete_instance();      \/\/!< destroy single instance$/;"	p	class:simlib3::Calendar	file:	access:protected	signature:()
simlib3::Calendar::delete_instance	calendar.cc	/^void Calendar::delete_instance() {$/;"	f	class:simlib3::Calendar	signature:()
simlib3::Calendar::instance	calendar.cc	/^    static Calendar * instance();       \/\/!< create\/get single instance (singleton)$/;"	p	class:simlib3::Calendar	file:	access:public	signature:()
simlib3::Calendar::instance	calendar.cc	/^inline Calendar * Calendar::instance() {$/;"	f	class:simlib3::Calendar	signature:()
simlib3::Calendar::instance_exists	calendar.cc	/^    static bool instance_exists() {$/;"	f	class:simlib3::Calendar	access:public	signature:()
simlib3::Calendar::mintime	calendar.cc	/^    double mintime;     \/\/!< activation time of first event$/;"	m	class:simlib3::Calendar	file:	access:private
simlib3::Calendar::~Calendar	calendar.cc	/^    virtual ~Calendar() {} \/\/!< clear is called in derived class dtr$/;"	f	class:simlib3::Calendar	access:protected	signature:()
simlib3::CalendarList	calendar.cc	/^class CalendarList : public Calendar {$/;"	c	namespace:simlib3	file:	inherits:Calendar
simlib3::CalendarList::CalendarList	calendar.cc	/^    CalendarList() {$/;"	f	class:simlib3::CalendarList	file:	access:private	signature:()
simlib3::CalendarList::Get	calendar.cc	/^    virtual Entity *Get(Entity *p);              \/\/ remove process p from calendar$/;"	p	class:simlib3::CalendarList	file:	access:public	signature:(Entity *p)
simlib3::CalendarList::Get	calendar.cc	/^Entity * CalendarList::Get(Entity * e)$/;"	f	class:simlib3::CalendarList	signature:(Entity * e)
simlib3::CalendarList::GetFirst	calendar.cc	/^    virtual Entity *GetFirst();$/;"	p	class:simlib3::CalendarList	file:	access:public	signature:()
simlib3::CalendarList::GetFirst	calendar.cc	/^Entity *CalendarList::GetFirst()$/;"	f	class:simlib3::CalendarList	signature:()
simlib3::CalendarList::Name	calendar.cc	/^    virtual const char* Name() { return "CalendarList"; }$/;"	f	class:simlib3::CalendarList	access:public	signature:()
simlib3::CalendarList::ScheduleAt	calendar.cc	/^    virtual void ScheduleAt(Entity *p, double t);$/;"	p	class:simlib3::CalendarList	file:	access:public	signature:(Entity *p, double t)
simlib3::CalendarList::ScheduleAt	calendar.cc	/^void CalendarList::ScheduleAt(Entity *e, double t)$/;"	f	class:simlib3::CalendarList	signature:(Entity *e, double t)
simlib3::CalendarList::clear	calendar.cc	/^    virtual void clear(bool destroy=false); \/\/ remove\/destroy all items$/;"	p	class:simlib3::CalendarList	file:	access:public	signature:(bool destroy=false)
simlib3::CalendarList::clear	calendar.cc	/^void CalendarList::clear(bool destroy)$/;"	f	class:simlib3::CalendarList	signature:(bool destroy)
simlib3::CalendarList::create	calendar.cc	/^    static CalendarList * create() {  \/\/ create instance$/;"	f	class:simlib3::CalendarList	access:public	signature:()
simlib3::CalendarList::debug_print	calendar.cc	/^    virtual void debug_print(); \/\/ print of calendar contents - FOR DEBUGGING ONLY$/;"	p	class:simlib3::CalendarList	file:	access:public	signature:()
simlib3::CalendarList::debug_print	calendar.cc	/^void CalendarList::debug_print() \/\/ print of calendar contents$/;"	f	class:simlib3::CalendarList	signature:()
simlib3::CalendarList::l	calendar.cc	/^    CalendarListImplementation l;$/;"	m	class:simlib3::CalendarList	file:	access:private
simlib3::CalendarList::~CalendarList	calendar.cc	/^    ~CalendarList() {$/;"	f	class:simlib3::CalendarList	file:	access:private	signature:()
simlib3::CalendarListImplementation	calendar.cc	/^class CalendarListImplementation {$/;"	c	namespace:simlib3	file:
simlib3::CalendarListImplementation::CalendarListImplementation	calendar.cc	/^    CalendarListImplementation() { }$/;"	f	class:simlib3::CalendarListImplementation	access:public	signature:()
simlib3::CalendarListImplementation::begin	calendar.cc	/^    iterator begin()    { return l.succ; }$/;"	f	class:simlib3::CalendarListImplementation	access:public	signature:()
simlib3::CalendarListImplementation::clear	calendar.cc	/^    void clear(bool destroy) {$/;"	f	class:simlib3::CalendarListImplementation	access:public	signature:(bool destroy)
simlib3::CalendarListImplementation::debug_print	calendar.cc	/^    void debug_print();$/;"	p	class:simlib3::CalendarListImplementation	file:	access:public	signature:()
simlib3::CalendarListImplementation::debug_print	calendar.cc	/^void CalendarListImplementation::debug_print() \/\/ print of list contents$/;"	f	class:simlib3::CalendarListImplementation	signature:()
simlib3::CalendarListImplementation::empty	calendar.cc	/^    bool empty()        { return begin() == end(); }$/;"	f	class:simlib3::CalendarListImplementation	access:public	signature:()
simlib3::CalendarListImplementation::end	calendar.cc	/^    iterator end()      { return &l; }$/;"	f	class:simlib3::CalendarListImplementation	access:public	signature:()
simlib3::CalendarListImplementation::extract_first	calendar.cc	/^    EventNotice *extract_first() {$/;"	f	class:simlib3::CalendarListImplementation	access:public	signature:()
simlib3::CalendarListImplementation::first	calendar.cc	/^    EventNotice *first() { return *begin(); }$/;"	f	class:simlib3::CalendarListImplementation	access:public	signature:()
simlib3::CalendarListImplementation::first_time	calendar.cc	/^    double first_time() { return (*begin())->time; }$/;"	f	class:simlib3::CalendarListImplementation	access:public	signature:()
simlib3::CalendarListImplementation::insert	calendar.cc	/^    void insert(Entity *e, double t) {$/;"	f	class:simlib3::CalendarListImplementation	access:public	signature:(Entity *e, double t)
simlib3::CalendarListImplementation::insert_extracted	calendar.cc	/^    void insert_extracted(EventNotice *evn) {$/;"	f	class:simlib3::CalendarListImplementation	access:public	signature:(EventNotice *evn)
simlib3::CalendarListImplementation::iterator	calendar.cc	/^    class iterator { \/\/!< bidirectional iterator$/;"	c	class:simlib3::CalendarListImplementation	file:	access:public
simlib3::CalendarListImplementation::iterator::iterator	calendar.cc	/^      iterator(EventNoticeLinkBase *pos) : p(pos) {}$/;"	f	class:simlib3::CalendarListImplementation::iterator	access:public	signature:(EventNoticeLinkBase *pos)
simlib3::CalendarListImplementation::iterator::operator !=	calendar.cc	/^      bool operator != (iterator q) { return p!=q.p; }$/;"	f	class:simlib3::CalendarListImplementation::iterator	access:public	signature:(iterator q)
simlib3::CalendarListImplementation::iterator::operator *	calendar.cc	/^      EventNotice * operator*() {$/;"	f	class:simlib3::CalendarListImplementation::iterator	access:public	signature:()
simlib3::CalendarListImplementation::iterator::operator ++	calendar.cc	/^      iterator &operator++() { p = p->succ; return *this; }$/;"	f	class:simlib3::CalendarListImplementation::iterator	access:public	signature:()
simlib3::CalendarListImplementation::iterator::operator --	calendar.cc	/^      iterator &operator--() { p = p->pred; return *this; }$/;"	f	class:simlib3::CalendarListImplementation::iterator	access:public	signature:()
simlib3::CalendarListImplementation::iterator::operator ==	calendar.cc	/^      bool operator == (iterator q) { return p==q.p; }$/;"	f	class:simlib3::CalendarListImplementation::iterator	access:public	signature:(iterator q)
simlib3::CalendarListImplementation::iterator::p	calendar.cc	/^      EventNoticeLinkBase *p;$/;"	m	class:simlib3::CalendarListImplementation::iterator	file:	access:private
simlib3::CalendarListImplementation::l	calendar.cc	/^    EventNoticeLinkBase l;  \/\/!< head of circular list$/;"	m	class:simlib3::CalendarListImplementation	file:	access:private
simlib3::CalendarListImplementation::remove	calendar.cc	/^    Entity *remove(Entity *e) {$/;"	f	class:simlib3::CalendarListImplementation	access:public	signature:(Entity *e)
simlib3::CalendarListImplementation::remove_first	calendar.cc	/^    Entity *remove_first() {$/;"	f	class:simlib3::CalendarListImplementation	access:public	signature:()
simlib3::CalendarListImplementation::search	calendar.cc	/^    iterator search(EventNotice *en) {$/;"	f	class:simlib3::CalendarListImplementation	file:	access:private	signature:(EventNotice *en)
simlib3::CalendarListImplementation::~CalendarListImplementation	calendar.cc	/^    ~ CalendarListImplementation() {$/;"	f	class:simlib3::CalendarListImplementation	access:public	signature:()
simlib3::CalendarQueue	calendar.cc	/^class CalendarQueue : public Calendar {$/;"	c	namespace:simlib3	file:	inherits:Calendar
simlib3::CalendarQueue::BucketList	calendar.cc	/^    typedef CalendarListImplementation BucketList;$/;"	t	class:simlib3::CalendarQueue	file:	access:private
simlib3::CalendarQueue::CalendarQueue	calendar.cc	/^    CalendarQueue();$/;"	p	class:simlib3::CalendarQueue	file:	access:private	signature:()
simlib3::CalendarQueue::CalendarQueue	calendar.cc	/^CalendarQueue::CalendarQueue():$/;"	f	class:simlib3::CalendarQueue	signature:()
simlib3::CalendarQueue::Get	calendar.cc	/^    virtual Entity *Get(Entity *p);              \/\/ remove process p from calendar$/;"	p	class:simlib3::CalendarQueue	file:	access:public	signature:(Entity *p)
simlib3::CalendarQueue::Get	calendar.cc	/^Entity * CalendarQueue::Get(Entity * e)$/;"	f	class:simlib3::CalendarQueue	signature:(Entity * e)
simlib3::CalendarQueue::GetFirst	calendar.cc	/^    virtual Entity *GetFirst();$/;"	p	class:simlib3::CalendarQueue	file:	access:public	signature:()
simlib3::CalendarQueue::GetFirst	calendar.cc	/^Entity * CalendarQueue::GetFirst()$/;"	f	class:simlib3::CalendarQueue	signature:()
simlib3::CalendarQueue::Name	calendar.cc	/^    virtual const char* Name() { return "CalendarQueue"; }$/;"	f	class:simlib3::CalendarQueue	access:public	signature:()
simlib3::CalendarQueue::Resize	calendar.cc	/^    void Resize(int grow=0);                \/\/ grow\/shrink operation$/;"	p	class:simlib3::CalendarQueue	file:	access:private	signature:(int grow=0)
simlib3::CalendarQueue::Resize	calendar.cc	/^void CalendarQueue::Resize(int grow)  \/\/ TODO: is it better to use target size?$/;"	f	class:simlib3::CalendarQueue	signature:(int grow)
simlib3::CalendarQueue::ScheduleAt	calendar.cc	/^    virtual void ScheduleAt(Entity *p, double t);$/;"	p	class:simlib3::CalendarQueue	file:	access:public	signature:(Entity *p, double t)
simlib3::CalendarQueue::ScheduleAt	calendar.cc	/^void CalendarQueue::ScheduleAt(Entity *e, double t)$/;"	f	class:simlib3::CalendarQueue	signature:(Entity *e, double t)
simlib3::CalendarQueue::SearchMinTime	calendar.cc	/^    void SearchMinTime(double starttime);   \/\/ search for new minimum$/;"	p	class:simlib3::CalendarQueue	file:	access:private	signature:(double starttime)
simlib3::CalendarQueue::SearchMinTime	calendar.cc	/^void CalendarQueue::SearchMinTime (double starttime)$/;"	f	class:simlib3::CalendarQueue	signature:(double starttime)
simlib3::CalendarQueue::bucket_width	calendar.cc	/^    double bucket_width;    \/\/ parameter: width of each bucket$/;"	m	class:simlib3::CalendarQueue	file:	access:private
simlib3::CalendarQueue::buckets	calendar.cc	/^    BucketList *buckets;    \/\/ bucket array$/;"	m	class:simlib3::CalendarQueue	file:	access:private
simlib3::CalendarQueue::buckettop	calendar.cc	/^    double buckettop;       \/\/ top time of current bucket$/;"	m	class:simlib3::CalendarQueue	file:	access:private
simlib3::CalendarQueue::clear	calendar.cc	/^    virtual void clear(bool destroy=false); \/\/ remove\/destroy all items$/;"	p	class:simlib3::CalendarQueue	file:	access:public	signature:(bool destroy=false)
simlib3::CalendarQueue::clear	calendar.cc	/^void CalendarQueue::clear(bool destroy)$/;"	f	class:simlib3::CalendarQueue	signature:(bool destroy)
simlib3::CalendarQueue::create	calendar.cc	/^    static CalendarQueue * create() {  \/\/ create instance$/;"	f	class:simlib3::CalendarQueue	access:public	signature:()
simlib3::CalendarQueue::debug_print	calendar.cc	/^    virtual void debug_print(); \/\/ print of calendar contents - FOR DEBUGGING ONLY$/;"	p	class:simlib3::CalendarQueue	file:	access:public	signature:()
simlib3::CalendarQueue::debug_print	calendar.cc	/^void CalendarQueue::debug_print() \/\/ print of calendar queue contents$/;"	f	class:simlib3::CalendarQueue	signature:()
simlib3::CalendarQueue::estimate_bucket_width	calendar.cc	/^    double estimate_bucket_width();$/;"	p	class:simlib3::CalendarQueue	file:	access:private	signature:()
simlib3::CalendarQueue::estimate_bucket_width	calendar.cc	/^double CalendarQueue::estimate_bucket_width() {$/;"	f	class:simlib3::CalendarQueue	signature:()
simlib3::CalendarQueue::hi_bucket_mark	calendar.cc	/^    unsigned hi_bucket_mark;        \/\/ high bucket threshold for resize$/;"	m	class:simlib3::CalendarQueue	file:	access:private
simlib3::CalendarQueue::last_dequeue_time	calendar.cc	/^    double last_dequeue_time; \/\/ for deleta computation$/;"	m	class:simlib3::CalendarQueue	file:	access:private
simlib3::CalendarQueue::list	calendar.cc	/^    BucketList list;        \/\/ list for small number of items$/;"	m	class:simlib3::CalendarQueue	file:	access:private
simlib3::CalendarQueue::list_impl	calendar.cc	/^    bool list_impl() { return buckets==NULL; }$/;"	f	class:simlib3::CalendarQueue	file:	access:private	signature:()
simlib3::CalendarQueue::low_bucket_mark	calendar.cc	/^    unsigned low_bucket_mark;       \/\/ low bucket threshold for resize$/;"	m	class:simlib3::CalendarQueue	file:	access:private
simlib3::CalendarQueue::nbuckets	calendar.cc	/^    unsigned nbuckets;      \/\/ current number of buckets$/;"	m	class:simlib3::CalendarQueue	file:	access:private
simlib3::CalendarQueue::ndelta	calendar.cc	/^    unsigned ndelta;        \/\/ count$/;"	m	class:simlib3::CalendarQueue	file:	access:private
simlib3::CalendarQueue::nextbucket	calendar.cc	/^    unsigned nextbucket;    \/\/ next bucket to check for first item$/;"	m	class:simlib3::CalendarQueue	file:	access:private
simlib3::CalendarQueue::numop	calendar.cc	/^    unsigned numop;         \/\/ number of operations performed from last tuning$/;"	m	class:simlib3::CalendarQueue	file:	access:private
simlib3::CalendarQueue::sumdelta	calendar.cc	/^    double sumdelta;        \/\/ sum for bucket_width estimation$/;"	m	class:simlib3::CalendarQueue	file:	access:private
simlib3::CalendarQueue::switchtocq	calendar.cc	/^    void switchtocq();$/;"	p	class:simlib3::CalendarQueue	file:	access:private	signature:()
simlib3::CalendarQueue::switchtocq	calendar.cc	/^void CalendarQueue::switchtocq()$/;"	f	class:simlib3::CalendarQueue	signature:()
simlib3::CalendarQueue::switchtolist	calendar.cc	/^    void switchtolist();$/;"	p	class:simlib3::CalendarQueue	file:	access:private	signature:()
simlib3::CalendarQueue::switchtolist	calendar.cc	/^void CalendarQueue::switchtolist()$/;"	f	class:simlib3::CalendarQueue	signature:()
simlib3::CalendarQueue::time2bucket	calendar.cc	/^    inline int time2bucket (double t) {$/;"	f	class:simlib3::CalendarQueue	file:	access:private	signature:(double t)
simlib3::CalendarQueue::time2bucket_top	calendar.cc	/^    inline double time2bucket_top(double t) {$/;"	f	class:simlib3::CalendarQueue	file:	access:private	signature:(double t)
simlib3::CalendarQueue::visualize	calendar.cc	/^    void visualize(const char *msg);$/;"	p	class:simlib3::CalendarQueue	file:	access:public	signature:(const char *msg)
simlib3::CalendarQueue::visualize	calendar.cc	/^void CalendarQueue::visualize(const char *msg)$/;"	f	class:simlib3::CalendarQueue	signature:(const char *msg)
simlib3::CalendarQueue::~CalendarQueue	calendar.cc	/^    ~CalendarQueue();$/;"	p	class:simlib3::CalendarQueue	file:	access:private	signature:()
simlib3::CalendarQueue::~CalendarQueue	calendar.cc	/^CalendarQueue::~CalendarQueue()$/;"	f	class:simlib3::CalendarQueue	signature:()
simlib3::Condition	simlib.h	/^class Condition : public aCondition {  \/\/ state condition$/;"	c	namespace:simlib3	inherits:aCondition
simlib3::Condition::Action	simlib.h	/^  virtual void Action()=0;             \/\/ state event$/;"	p	class:simlib3::Condition	access:public	signature:()
simlib3::Condition::Change	simlib.h	/^  bool Change() { return ccl!=cc; }     \/\/ both changes$/;"	f	class:simlib3::Condition	access:protected	signature:()
simlib3::Condition::Condition	cond.cc	/^Condition::Condition(Input i) :$/;"	f	class:simlib3::Condition	signature:(Input i)
simlib3::Condition::Condition	simlib.h	/^  Condition(Input i);$/;"	p	class:simlib3::Condition	access:public	signature:(Input i)
simlib3::Condition::Down	simlib.h	/^  bool Down()   { return ccl>cc; }      \/\/ change: TRUE->FALSE$/;"	f	class:simlib3::Condition	access:protected	signature:()
simlib3::Condition::Init	cond.cc	/^void Condition::Init()$/;"	f	class:simlib3::Condition	signature:()
simlib3::Condition::Init	simlib.h	/^  virtual void Init();$/;"	p	class:simlib3::Condition	access:private	signature:()
simlib3::Condition::Name	cond.cc	/^const char *Condition::Name() const {$/;"	f	class:simlib3::Condition	signature:() const
simlib3::Condition::Name	simlib.h	/^  virtual const char *Name() const;$/;"	p	class:simlib3::Condition	access:public	signature:() const
simlib3::Condition::SetInput	simlib.h	/^  Input SetInput(Input inp) { return in.Set(inp); } \/\/ change input block$/;"	f	class:simlib3::Condition	access:public	signature:(Input inp)
simlib3::Condition::SetNewStatus	cond.cc	/^void Condition::SetNewStatus()$/;"	f	class:simlib3::Condition	signature:()
simlib3::Condition::SetNewStatus	simlib.h	/^  virtual void SetNewStatus();$/;"	p	class:simlib3::Condition	access:private	signature:()
simlib3::Condition::Test	cond.cc	/^bool Condition::Test() {$/;"	f	class:simlib3::Condition	signature:()
simlib3::Condition::Test	simlib.h	/^  virtual bool Test();                  \/\/ test function (input >= 0.0)$/;"	p	class:simlib3::Condition	access:protected	signature:()
simlib3::Condition::Up	simlib.h	/^  bool Up()     { return ccl<cc; }      \/\/ change: FALSE->TRUE$/;"	f	class:simlib3::Condition	access:protected	signature:()
simlib3::Condition::Value	simlib.h	/^  virtual bool Value() { return cc; }   \/\/ status$/;"	f	class:simlib3::Condition	access:public	signature:()
simlib3::Condition::cc	simlib.h	/^  unsigned char cc;                    \/\/ state$/;"	m	class:simlib3::Condition	access:private
simlib3::Condition::ccl	simlib.h	/^  unsigned char ccl;                   \/\/ old state$/;"	m	class:simlib3::Condition	access:private
simlib3::Condition::in	simlib.h	/^  Input in;                            \/\/ block input$/;"	m	class:simlib3::Condition	access:private
simlib3::Condition::~Condition	cond.cc	/^Condition::~Condition()$/;"	f	class:simlib3::Condition	signature:()
simlib3::Condition::~Condition	simlib.h	/^  ~Condition();$/;"	p	class:simlib3::Condition	access:public	signature:()
simlib3::ConditionDown	simlib.h	/^class ConditionDown : public Condition { \/\/ state event on TRUE-->FALSE change$/;"	c	namespace:simlib3	inherits:Condition
simlib3::ConditionDown::Action	simlib.h	/^  virtual void Action()=0;                \/\/ state event$/;"	p	class:simlib3::ConditionDown	access:public	signature:()
simlib3::ConditionDown::ConditionDown	simlib.h	/^  ConditionDown(Input i) : Condition(i) {}$/;"	f	class:simlib3::ConditionDown	access:public	signature:(Input i)
simlib3::ConditionDown::Name	cond.cc	/^const char *ConditionDown::Name() const {$/;"	f	class:simlib3::ConditionDown	signature:() const
simlib3::ConditionDown::Name	simlib.h	/^  virtual const char *Name() const;$/;"	p	class:simlib3::ConditionDown	access:public	signature:() const
simlib3::ConditionDown::Test	simlib.h	/^  bool Test() { return Condition::Test() && Down(); }$/;"	f	class:simlib3::ConditionDown	access:public	signature:()
simlib3::ConditionUp	simlib.h	/^class ConditionUp : public Condition { \/\/ state event on FALSE-->TRUE change$/;"	c	namespace:simlib3	inherits:Condition
simlib3::ConditionUp::Action	simlib.h	/^  virtual void Action()=0;             \/\/ state event$/;"	p	class:simlib3::ConditionUp	access:public	signature:()
simlib3::ConditionUp::ConditionUp	simlib.h	/^  ConditionUp(Input i) : Condition(i) {}$/;"	f	class:simlib3::ConditionUp	access:public	signature:(Input i)
simlib3::ConditionUp::Name	cond.cc	/^const char *ConditionUp::Name() const {$/;"	f	class:simlib3::ConditionUp	signature:() const
simlib3::ConditionUp::Name	simlib.h	/^  virtual const char *Name() const;$/;"	p	class:simlib3::ConditionUp	access:public	signature:() const
simlib3::ConditionUp::Test	simlib.h	/^  bool Test() { return Condition::Test() && Up(); }$/;"	f	class:simlib3::ConditionUp	access:public	signature:()
simlib3::Constant	simlib.h	/^class Constant : public aContiBlock {$/;"	c	namespace:simlib3	inherits:aContiBlock
simlib3::Constant2D	simlib2D.h	/^class Constant2D : public aContiBlock2D {$/;"	c	namespace:simlib3	inherits:aContiBlock2D
simlib3::Constant2D::Constant2D	simlib2D.h	/^  explicit Constant2D(Value2D x) : value(x) {}$/;"	f	class:simlib3::Constant2D	access:public	signature:(Value2D x)
simlib3::Constant2D::Constant2D	simlib2D.h	/^  explicit Constant2D(double x, double y) : value(x,y) {}$/;"	f	class:simlib3::Constant2D	access:public	signature:(double x, double y)
simlib3::Constant2D::Value	simlib2D.h	/^  virtual Value2D Value()  { return value; }      \/\/ without Eval$/;"	f	class:simlib3::Constant2D	access:public	signature:()
simlib3::Constant2D::value	simlib2D.h	/^  const Value2D value;$/;"	m	class:simlib3::Constant2D	access:private
simlib3::Constant3D	simlib3D.h	/^class Constant3D : public aContiBlock3D {$/;"	c	namespace:simlib3	inherits:aContiBlock3D
simlib3::Constant3D::Constant3D	simlib3D.h	/^  explicit Constant3D(Value3D x) : value(x) {}$/;"	f	class:simlib3::Constant3D	access:public	signature:(Value3D x)
simlib3::Constant3D::Constant3D	simlib3D.h	/^  explicit Constant3D(double x, double y, double z) : value(x,y,z) {}$/;"	f	class:simlib3::Constant3D	access:public	signature:(double x, double y, double z)
simlib3::Constant3D::Value	simlib3D.h	/^  virtual Value3D Value () { return value; }      \/\/ without Eval$/;"	f	class:simlib3::Constant3D	access:public	signature:()
simlib3::Constant3D::value	simlib3D.h	/^  const Value3D value;$/;"	m	class:simlib3::Constant3D	access:private
simlib3::Constant::Constant	simlib.h	/^  Constant(double x) : value(x) {}$/;"	f	class:simlib3::Constant	access:public	signature:(double x)
simlib3::Constant::Value	simlib.h	/^  virtual double Value ()       { return value; }$/;"	f	class:simlib3::Constant	access:public	signature:()
simlib3::Constant::value	simlib.h	/^  const double value;$/;"	m	class:simlib3::Constant	access:private
simlib3::ContractStep	intg.cc	/^void ContractStep() {$/;"	f	namespace:simlib3	signature:()
simlib3::ContractStep	intg.cc	/^void ContractStep(double time)$/;"	f	namespace:simlib3	signature:(double time)
simlib3::ContractStep	simlib.h	/^void ContractStep();$/;"	p	namespace:simlib3	signature:()
simlib3::ContractStep	simlib.h	/^void ContractStep(double time);$/;"	p	namespace:simlib3	signature:(double time)
simlib3::Cos	fun.cc	/^Input Cos(Input x)              { return new Function1(x, cos); }$/;"	f	namespace:simlib3	signature:(Input x)
simlib3::Cos	simlib.h	/^Input Cos(Input x);             \/\/ cos(x)$/;"	p	namespace:simlib3	signature:(Input x)
simlib3::Current	run.cc	/^Entity *const &Current = SIMLIB_Current;        \/\/ read-only reference$/;"	m	namespace:simlib3	file:
simlib3::DEFAULT_PRIORITY	simlib.h	/^  DEFAULT_PRIORITY = 0$/;"	e	enum:simlib3::__anon1
simlib3::DEFINE_HOOK	run.cc	/^DEFINE_HOOK(Break);     \/\/ called in Run()$/;"	p	namespace:simlib3	file:	signature:(Break)
simlib3::DEFINE_HOOK	run.cc	/^DEFINE_HOOK(Delay);     \/\/ called in Run() and SampleDelays()$/;"	p	namespace:simlib3	file:	signature:(Delay)
simlib3::DEFINE_HOOK	run.cc	/^DEFINE_HOOK(DelayInit); \/\/ called in Init()$/;"	p	namespace:simlib3	file:	signature:(DelayInit)
simlib3::DEFINE_HOOK	run.cc	/^DEFINE_HOOK(SamplerAct);        \/\/ called in Run()$/;"	p	namespace:simlib3	file:	signature:(SamplerAct)
simlib3::DEFINE_HOOK	run.cc	/^DEFINE_HOOK(SamplerInit);       \/\/ called in Init()$/;"	p	namespace:simlib3	file:	signature:(SamplerInit)
simlib3::DEFINE_HOOK	run.cc	/^DEFINE_HOOK(WUclear); \/\/ should be in run.cc$/;"	p	namespace:simlib3	file:	signature:(WUclear)
simlib3::DEFINE_HOOK	run.cc	/^DEFINE_HOOK(WUget_next);$/;"	p	namespace:simlib3	file:	signature:(WUget_next)
simlib3::DEFINE_HOOK	run.cc	/^DEFINE_HOOK(ZDelayTimerInit); \/\/ called in Run()$/;"	p	namespace:simlib3	file:	signature:(ZDelayTimerInit)
simlib3::DeadZone	simlib.h	/^typedef Insv DeadZone;$/;"	t	namespace:simlib3
simlib3::Debug	debug.cc	/^unsigned long Debug(unsigned long mode)$/;"	f	namespace:simlib3	signature:(unsigned long mode)
simlib3::Debug	simlib.h	/^unsigned long Debug(unsigned long mode=~0UL); \/\/ start\/stop partial debugging$/;"	p	namespace:simlib3	signature:(unsigned long mode=~0UL)
simlib3::DebugOFF	debug.cc	/^void DebugOFF()$/;"	f	namespace:simlib3	signature:()
simlib3::DebugOFF	simlib.h	/^void DebugOFF();  \/\/!< stop debugging output$/;"	p	namespace:simlib3	signature:()
simlib3::DebugON	debug.cc	/^void DebugON()$/;"	f	namespace:simlib3	signature:()
simlib3::DebugON	simlib.h	/^void DebugON();   \/\/!< start debugging output$/;"	p	namespace:simlib3	signature:()
simlib3::Delay	delay.h	/^class Delay : public aContiBlock1 {$/;"	c	namespace:simlib3	inherits:aContiBlock1
simlib3::Delay::Buffer	delay.cc	/^struct Delay::Buffer {$/;"	s	class:simlib3::Delay	file:
simlib3::Delay::Buffer	delay.h	/^    struct Buffer {$/;"	s	class:simlib3::Delay	access:public
simlib3::Delay::Buffer::clear	delay.cc	/^    virtual void clear() = 0;                   \/\/!< initialize buffer$/;"	p	struct:simlib3::Delay::Buffer	file:	access:public	signature:()
simlib3::Delay::Buffer::clear	delay.h	/^        virtual void clear() = 0; \/\/!< initialize buffer$/;"	p	struct:simlib3::Delay::Buffer	access:public	signature:()
simlib3::Delay::Buffer::get	delay.cc	/^    virtual double get(double time) = 0;        \/\/!< read interpolated value$/;"	p	struct:simlib3::Delay::Buffer	file:	access:public	signature:(double time)
simlib3::Delay::Buffer::get	delay.h	/^        virtual double get(double time) = 0; \/\/!< get interpolated value$/;"	p	struct:simlib3::Delay::Buffer	access:public	signature:(double time)
simlib3::Delay::Buffer::put	delay.cc	/^    virtual void put(double value, double time) = 0;    \/\/!< store value$/;"	p	struct:simlib3::Delay::Buffer	file:	access:public	signature:(double value, double time)
simlib3::Delay::Buffer::put	delay.h	/^        virtual void put(double value, double time) = 0; \/\/!< sample$/;"	p	struct:simlib3::Delay::Buffer	access:public	signature:(double value, double time)
simlib3::Delay::Buffer::~Buffer	delay.cc	/^    virtual ~Buffer() {};$/;"	f	struct:simlib3::Delay::Buffer	access:public	signature:()
simlib3::Delay::Buffer::~Buffer	delay.h	/^        virtual ~Buffer() {};$/;"	f	struct:simlib3::Delay::Buffer	access:public	signature:()
simlib3::Delay::Delay	delay.cc	/^Delay::Delay(Input i, double _dt, double ival) :$/;"	f	class:simlib3::Delay	signature:(Input i, double _dt, double ival)
simlib3::Delay::Delay	delay.h	/^    Delay(Input i, double dt, double initvalue=0); \/\/ dt > MaxStep$/;"	p	class:simlib3::Delay	access:public	signature:(Input i, double dt, double initvalue=0)
simlib3::Delay::Delay	delay.h	/^    Delay(const Delay&);                 \/\/ disable copy ctor$/;"	p	class:simlib3::Delay	access:private	signature:(const Delay&)
simlib3::Delay::Init	delay.cc	/^void Delay::Init() {$/;"	f	class:simlib3::Delay	signature:()
simlib3::Delay::Init	delay.h	/^    void Init();                \/\/!< initialize delay block$/;"	p	class:simlib3::Delay	access:public	signature:()
simlib3::Delay::Sample	delay.cc	/^void Delay::Sample()$/;"	f	class:simlib3::Delay	signature:()
simlib3::Delay::Sample	delay.h	/^    void Sample();              \/\/!< sample input (called automatically)$/;"	p	class:simlib3::Delay	access:public	signature:()
simlib3::Delay::Set	delay.cc	/^double Delay::Set(double newdelay)$/;"	f	class:simlib3::Delay	signature:(double newdelay)
simlib3::Delay::Set	delay.h	/^    double Set(double newDT);   \/\/!< change delay time (EXPERIMENTAL)$/;"	p	class:simlib3::Delay	access:public	signature:(double newDT)
simlib3::Delay::Value	delay.cc	/^double Delay::Value()$/;"	f	class:simlib3::Delay	signature:()
simlib3::Delay::Value	delay.h	/^    virtual double Value();     \/\/!< output of delay block$/;"	p	class:simlib3::Delay	access:public	signature:()
simlib3::Delay::buffer	delay.h	/^    Buffer *buffer;             \/\/!< memory for past values$/;"	m	class:simlib3::Delay	access:protected
simlib3::Delay::dt	delay.h	/^    double dt;                  \/\/!< Parameter: delay time (should be > MaxStep)$/;"	m	class:simlib3::Delay	access:protected
simlib3::Delay::initval	delay.h	/^    double initval;             \/\/!< initial value (used at start)$/;"	m	class:simlib3::Delay	access:protected
simlib3::Delay::last_time	delay.h	/^    double last_time;           \/\/!< last output time (for optimization)$/;"	m	class:simlib3::Delay	access:protected
simlib3::Delay::last_value	delay.h	/^    double last_value;          \/\/!< last output value$/;"	m	class:simlib3::Delay	access:protected
simlib3::Delay::operator =	delay.h	/^    void operator= (const Delay&);       \/\/ disable assignment$/;"	p	class:simlib3::Delay	access:private	signature:(const Delay&)
simlib3::Delay::~Delay	delay.cc	/^Delay::~Delay()$/;"	f	class:simlib3::Delay	signature:()
simlib3::Delay::~Delay	delay.h	/^    ~Delay();$/;"	p	class:simlib3::Delay	access:public	signature:()
simlib3::ERROREXIT	internal.h	/^    ERROREXIT       \/\/ fatal error handling phase$/;"	e	enum:simlib3::SIMLIB_Phase_t
simlib3::EULER	ni_euler.h	/^class EULER : public StatusMethod {$/;"	c	namespace:simlib3	inherits:StatusMethod
simlib3::EULER::A	ni_euler.h	/^  Memory si, di, A;  \/\/ auxiliary memories$/;"	m	class:simlib3::EULER	access:private
simlib3::EULER::EULER	ni_euler.h	/^  EULER(const char* name) :  \/\/ registrate method and name it$/;"	f	class:simlib3::EULER	access:public	signature:(const char* name)
simlib3::EULER::Integrate	ni_euler.cc	/^void EULER::Integrate(void)$/;"	f	class:simlib3::EULER	signature:(void)
simlib3::EULER::Integrate	ni_euler.h	/^  virtual void Integrate(void);  \/\/ integration method$/;"	p	class:simlib3::EULER	access:public	signature:(void)
simlib3::EULER::di	ni_euler.h	/^  Memory si, di, A;  \/\/ auxiliary memories$/;"	m	class:simlib3::EULER	access:private
simlib3::EULER::si	ni_euler.h	/^  Memory si, di, A;  \/\/ auxiliary memories$/;"	m	class:simlib3::EULER	access:private
simlib3::EULER::xi	ni_euler.h	/^  StatusMemory xi;$/;"	m	class:simlib3::EULER	access:private
simlib3::EULER::~EULER	ni_euler.h	/^  virtual ~EULER()  \/\/ destructor$/;"	f	class:simlib3::EULER	access:public	signature:()
simlib3::EndTime	run.cc	/^const double & EndTime   = SIMLIB_EndTime;      \/\/ time of simulation end$/;"	m	namespace:simlib3	file:
simlib3::Entity	simlib.h	/^class Entity : public Link {$/;"	c	namespace:simlib3	inherits:Link
simlib3::Entity::Activate	entity.cc	/^void Entity::Activate(double t)$/;"	f	class:simlib3::Entity	signature:(double t)
simlib3::Entity::Activate	simlib.h	/^    virtual void Activate(double t);    \/\/!< activate at time t (schedule)$/;"	p	class:simlib3::Entity	access:public	signature:(double t)
simlib3::Entity::Activate	simlib.h	/^    void Activate() { Activate(Time); } \/\/!< activate now$/;"	f	class:simlib3::Entity	access:public	signature:()
simlib3::Entity::ActivationTime	calendar.cc	/^double Entity::ActivationTime() { \/\/ activation time$/;"	f	class:simlib3::Entity	signature:()
simlib3::Entity::ActivationTime	simlib.h	/^    double ActivationTime();            \/\/ get activation time if scheduled$/;"	p	class:simlib3::Entity	access:public	signature:()
simlib3::Entity::Cancel	simlib.h	/^    void Cancel() { Terminate(); }      \/\/!< end Behavior() and remove entity$/;"	f	class:simlib3::Entity	access:public	signature:()
simlib3::Entity::Entity	entity.cc	/^Entity::Entity(Priority_t p) :$/;"	f	class:simlib3::Entity	signature:(Priority_t p)
simlib3::Entity::Entity	simlib.h	/^    Entity(Priority_t p = DEFAULT_PRIORITY);$/;"	p	class:simlib3::Entity	access:public	signature:(Priority_t p = DEFAULT_PRIORITY)
simlib3::Entity::Entity	simlib.h	/^    Entity(const Entity&);           \/\/ disable$/;"	p	class:simlib3::Entity	access:private	signature:(const Entity&)
simlib3::Entity::GetEventNotice	simlib.h	/^    EventNotice *GetEventNotice() { return _evn; }$/;"	f	class:simlib3::Entity	access:public	signature:()
simlib3::Entity::Idle	simlib.h	/^    bool Idle() { return _evn==0; }     \/\/!< entity activation is not scheduled in calendar$/;"	f	class:simlib3::Entity	access:public	signature:()
simlib3::Entity::Name	entity.cc	/^const char *Entity::Name() const$/;"	f	class:simlib3::Entity	signature:() const
simlib3::Entity::Name	simlib.h	/^    virtual const char *Name() const;   \/\/!< name of the entity$/;"	p	class:simlib3::Entity	access:public	signature:() const
simlib3::Entity::Out	entity.cc	/^void Entity::Out()$/;"	f	class:simlib3::Entity	signature:()
simlib3::Entity::Out	simlib.h	/^    virtual void Out();                 \/\/!< remove entity from queue$/;"	p	class:simlib3::Entity	access:public	signature:()
simlib3::Entity::Passivate	entity.cc	/^void Entity::Passivate()$/;"	f	class:simlib3::Entity	signature:()
simlib3::Entity::Passivate	simlib.h	/^    virtual void Passivate();           \/\/!< deactivation$/;"	p	class:simlib3::Entity	access:public	signature:()
simlib3::Entity::Priority	simlib.h	/^    Priority_t Priority;                \/\/!< priority of the entity$/;"	m	class:simlib3::Entity	access:public
simlib3::Entity::Priority_t	simlib.h	/^    typedef EntityPriority_t Priority_t;$/;"	t	class:simlib3::Entity	access:public
simlib3::Entity::SIMLIB_DoActions	simlib.h	/^    friend void SIMLIB_DoActions();     \/\/ internal function - event dispatcher$/;"	p	class:simlib3::Entity	access:friend	signature:()
simlib3::Entity::Terminate	entity.cc	/^void Entity::Terminate()$/;"	f	class:simlib3::Entity	signature:()
simlib3::Entity::Terminate	simlib.h	/^    virtual void Terminate() = 0;       \/\/!< end Behavior() and remove entity$/;"	p	class:simlib3::Entity	access:public	signature:()
simlib3::Entity::_Ident	simlib.h	/^    unsigned long _Ident;           \/\/!< unique identification number of entity$/;"	m	class:simlib3::Entity	access:protected
simlib3::Entity::_MarkTime	simlib.h	/^    double _MarkTime;               \/\/ beginning of waiting in queue ###!!!$/;"	m	class:simlib3::Entity	access:protected
simlib3::Entity::_Number	entity.cc	/^unsigned long Entity::_Number = 0L;     \/\/ # of entity creations$/;"	m	class:simlib3::Entity	file:
simlib3::Entity::_Number	simlib.h	/^    static unsigned long _Number;   \/\/!< current number of entities$/;"	m	class:simlib3::Entity	access:protected
simlib3::Entity::_Run	simlib.h	/^    virtual void _Run() throw() = 0;    \/\/!< run the Behavior() function$/;"	p	class:simlib3::Entity	access:private	signature:()
simlib3::Entity::_SPrio	simlib.h	/^    ServicePriority_t _SPrio;           \/\/!< priority of service in Facility$/;"	m	class:simlib3::Entity	access:protected
simlib3::Entity::__anon2::_RemainingTime	simlib.h	/^        double _RemainingTime; \/\/ rest of time of interrupted service (Facility) ###$/;"	m	union:simlib3::Entity::__anon2	access:public
simlib3::Entity::__anon2::_RequiredCapacity	simlib.h	/^        unsigned long _RequiredCapacity; \/\/ required store capacity of Store$/;"	m	union:simlib3::Entity::__anon2	access:public
simlib3::Entity::_evn	simlib.h	/^    EventNotice *_evn;                  \/\/!< points to calendar item, iff scheduled$/;"	m	class:simlib3::Entity	access:private
simlib3::Entity::operator =	simlib.h	/^    Entity&operator=(const Entity&); \/\/ disable$/;"	p	class:simlib3::Entity	access:private	signature:(const Entity&)
simlib3::Entity::operator Entity*	simlib.h	/^    operator Entity* () { return this; } \/\/ default conversion$/;"	f	class:simlib3::Entity	access:public	signature:()
simlib3::Entity::~Entity	entity.cc	/^Entity::~Entity() {$/;"	f	class:simlib3::Entity	signature:()
simlib3::Entity::~Entity	simlib.h	/^    virtual ~Entity();$/;"	p	class:simlib3::Entity	access:public	signature:()
simlib3::EntityPriority_t	simlib.h	/^typedef signed char EntityPriority_t;$/;"	t	namespace:simlib3
simlib3::Erlang	random2.cc	/^double Erlang(double alfa, int beta)$/;"	f	namespace:simlib3	signature:(double alfa, int beta)
simlib3::Erlang	simlib.h	/^double Erlang(double alfa, int beta);$/;"	p	namespace:simlib3	signature:(double alfa, int beta)
simlib3::Error	print.cc	/^void Error(const char *fmt, ...)$/;"	f	namespace:simlib3	signature:(const char *fmt, ...)
simlib3::Error	simlib.h	/^void Error(const char *fmt, ...);$/;"	p	namespace:simlib3	signature:(const char *fmt, ...)
simlib3::Event	simlib.h	/^class Event : public Entity {$/;"	c	namespace:simlib3	inherits:Entity
simlib3::Event::Behavior	simlib.h	/^  virtual void Behavior() = 0;    \/\/!< behavior description$/;"	p	class:simlib3::Event	access:public	signature:()
simlib3::Event::Event	event.cc	/^Event::Event(Priority_t p) : Entity(p)$/;"	f	class:simlib3::Event	signature:(Priority_t p)
simlib3::Event::Event	simlib.h	/^  Event(Priority_t p=DEFAULT_PRIORITY);$/;"	p	class:simlib3::Event	access:public	signature:(Priority_t p=DEFAULT_PRIORITY)
simlib3::Event::Name	event.cc	/^const char *Event::Name() const$/;"	f	class:simlib3::Event	signature:() const
simlib3::Event::Name	simlib.h	/^  virtual const char *Name() const;     \/\/!< name of object$/;"	p	class:simlib3::Event	access:public	signature:() const
simlib3::Event::Output	output1.cc	/^void Event::Output() const$/;"	f	class:simlib3::Event	signature:() const
simlib3::Event::Output	simlib.h	/^  virtual void Output() const;          \/\/!< print object to default output$/;"	p	class:simlib3::Event	access:public	signature:() const
simlib3::Event::Terminate	event.cc	/^void Event::Terminate()$/;"	f	class:simlib3::Event	signature:()
simlib3::Event::Terminate	simlib.h	/^  virtual void Terminate();       \/\/ do not use (deprecated)$/;"	p	class:simlib3::Event	access:private	signature:()
simlib3::Event::_Run	event.cc	/^void Event::_Run() throw()$/;"	f	class:simlib3::Event	signature:()
simlib3::Event::_Run	simlib.h	/^  virtual void _Run() throw();$/;"	p	class:simlib3::Event	access:private	signature:()
simlib3::Event::~Event	event.cc	/^Event::~Event()$/;"	f	class:simlib3::Event	signature:()
simlib3::Event::~Event	simlib.h	/^  virtual ~Event();$/;"	p	class:simlib3::Event	access:public	signature:()
simlib3::EventNotice	calendar.cc	/^struct EventNotice : public EventNoticeLinkBase {$/;"	s	namespace:simlib3	file:	inherits:EventNoticeLinkBase
simlib3::EventNotice::Create	calendar.cc	/^    static EventNotice *Create(Entity *p, double t);$/;"	p	struct:simlib3::EventNotice	file:	access:public	signature:(Entity *p, double t)
simlib3::EventNotice::Create	calendar.cc	/^inline EventNotice *EventNotice::Create(Entity *e, double t)$/;"	f	class:simlib3::EventNotice	signature:(Entity *e, double t)
simlib3::EventNotice::Destroy	calendar.cc	/^    static void Destroy(EventNotice *en);$/;"	p	struct:simlib3::EventNotice	file:	access:public	signature:(EventNotice *en)
simlib3::EventNotice::Destroy	calendar.cc	/^inline void EventNotice::Destroy(EventNotice *en)$/;"	f	class:simlib3::EventNotice	signature:(EventNotice *en)
simlib3::EventNotice::EventNotice	calendar.cc	/^    EventNotice(Entity *p, double t) :$/;"	f	struct:simlib3::EventNotice	access:public	signature:(Entity *p, double t)
simlib3::EventNotice::EventNotice	calendar.cc	/^    EventNotice(const EventNotice&); \/\/ disable$/;"	p	struct:simlib3::EventNotice	file:	access:private	signature:(const EventNotice&)
simlib3::EventNotice::Set	calendar.cc	/^    void Set(Entity *e, double t) {$/;"	f	struct:simlib3::EventNotice	access:public	signature:(Entity *e, double t)
simlib3::EventNotice::create_reverse_link	calendar.cc	/^    void create_reverse_link() {$/;"	f	struct:simlib3::EventNotice	access:public	signature:()
simlib3::EventNotice::delete_reverse_link	calendar.cc	/^    void delete_reverse_link() {$/;"	f	struct:simlib3::EventNotice	access:public	signature:()
simlib3::EventNotice::entity	calendar.cc	/^    Entity * entity;$/;"	m	struct:simlib3::EventNotice	file:	access:public
simlib3::EventNotice::operator =	calendar.cc	/^    EventNotice &operator=(const EventNotice&);$/;"	p	struct:simlib3::EventNotice	file:	access:private	signature:(const EventNotice&)
simlib3::EventNotice::priority	calendar.cc	/^    Entity::Priority_t priority;$/;"	m	struct:simlib3::EventNotice	file:	access:public
simlib3::EventNotice::time	calendar.cc	/^    double time;$/;"	m	struct:simlib3::EventNotice	file:	access:public
simlib3::EventNotice::~EventNotice	calendar.cc	/^    ~EventNotice() {$/;"	f	struct:simlib3::EventNotice	access:public	signature:()
simlib3::EventNoticeAllocator	calendar.cc	/^class EventNoticeAllocator {$/;"	c	namespace:simlib3	file:
simlib3::EventNoticeAllocator::EventNoticeAllocator	calendar.cc	/^    EventNoticeAllocator(): l(0), freed(0) {}$/;"	f	class:simlib3::EventNoticeAllocator	access:public	signature:()
simlib3::EventNoticeAllocator::MAXSIZELIMIT	calendar.cc	/^    static const unsigned MAXSIZELIMIT = 1000000;$/;"	m	class:simlib3::EventNoticeAllocator	file:	access:private
simlib3::EventNoticeAllocator::alloc	calendar.cc	/^    EventNotice *alloc(Entity *p, double t) {$/;"	f	class:simlib3::EventNoticeAllocator	access:public	signature:(Entity *p, double t)
simlib3::EventNoticeAllocator::clear	calendar.cc	/^    void clear() {$/;"	f	class:simlib3::EventNoticeAllocator	access:public	signature:()
simlib3::EventNoticeAllocator::free	calendar.cc	/^    void free(EventNotice *en) {$/;"	f	class:simlib3::EventNoticeAllocator	access:public	signature:(EventNotice *en)
simlib3::EventNoticeAllocator::freed	calendar.cc	/^    unsigned freed;$/;"	m	class:simlib3::EventNoticeAllocator	file:	access:private
simlib3::EventNoticeAllocator::l	calendar.cc	/^    EventNoticeLinkBase *l; \/\/ single-linked list of freed items$/;"	m	class:simlib3::EventNoticeAllocator	file:	access:private
simlib3::EventNoticeAllocator::~EventNoticeAllocator	calendar.cc	/^    ~EventNoticeAllocator() {$/;"	f	class:simlib3::EventNoticeAllocator	access:public	signature:()
simlib3::EventNoticeLinkBase	calendar.cc	/^struct EventNoticeLinkBase { \/\/ base class with list pointers only$/;"	s	namespace:simlib3	file:
simlib3::EventNoticeLinkBase::EventNoticeLinkBase	calendar.cc	/^    EventNoticeLinkBase() : pred(this), succ(this) {}$/;"	f	struct:simlib3::EventNoticeLinkBase	access:public	signature:()
simlib3::EventNoticeLinkBase::insert	calendar.cc	/^    void insert(EventNoticeLinkBase * p) {$/;"	f	struct:simlib3::EventNoticeLinkBase	access:public	signature:(EventNoticeLinkBase * p)
simlib3::EventNoticeLinkBase::pred	calendar.cc	/^    EventNoticeLinkBase * pred;         \/\/!< previous object in list$/;"	m	struct:simlib3::EventNoticeLinkBase	file:	access:public
simlib3::EventNoticeLinkBase::remove	calendar.cc	/^    void remove() {$/;"	f	struct:simlib3::EventNoticeLinkBase	access:public	signature:()
simlib3::EventNoticeLinkBase::succ	calendar.cc	/^    EventNoticeLinkBase * succ;         \/\/!< next object in list$/;"	m	struct:simlib3::EventNoticeLinkBase	file:	access:public
simlib3::Exp	fun.cc	/^Input Exp(Input x)              { return new Function1(x, exp); }$/;"	f	namespace:simlib3	signature:(Input x)
simlib3::Exp	simlib.h	/^Input Exp(Input x);             \/\/ exp(x)     e ** x$/;"	p	namespace:simlib3	signature:(Input x)
simlib3::Exponential	random2.cc	/^double Exponential(double mv)$/;"	f	namespace:simlib3	signature:(double mv)
simlib3::Exponential	simlib.h	/^double Exponential(double mv);$/;"	p	namespace:simlib3	signature:(double mv)
simlib3::Expression	simlib.h	/^struct Expression : public aContiBlock1 {$/;"	s	namespace:simlib3	inherits:aContiBlock1
simlib3::Expression2D	simlib2D.h	/^struct Expression2D : public aContiBlock2D1 {$/;"	s	namespace:simlib3	inherits:aContiBlock2D1
simlib3::Expression2D::Expression2D	simlib2D.h	/^  explicit Expression2D(Input2D i) : aContiBlock2D1(i) {}$/;"	f	struct:simlib3::Expression2D	access:public	signature:(Input2D i)
simlib3::Expression2D::Value	simlib2D.h	/^  Value2D Value() { return InputValue(); }$/;"	f	struct:simlib3::Expression2D	access:public	signature:()
simlib3::Expression3D	simlib3D.h	/^struct Expression3D : public aContiBlock3D1 {$/;"	s	namespace:simlib3	inherits:aContiBlock3D1
simlib3::Expression3D::Expression3D	simlib3D.h	/^  explicit Expression3D(Input3D i) : aContiBlock3D1(i) {}$/;"	f	struct:simlib3::Expression3D	access:public	signature:(Input3D i)
simlib3::Expression3D::Value	simlib3D.h	/^  Value3D Value() { return InputValue(); }$/;"	f	struct:simlib3::Expression3D	access:public	signature:()
simlib3::Expression::Expression	simlib.h	/^  Expression(Input i) : aContiBlock1(i) {}$/;"	f	struct:simlib3::Expression	access:public	signature:(Input i)
simlib3::Expression::Value	continuous.cc	/^double Expression::Value() { AlgLoopDetector _(this); return InputValue(); }$/;"	f	class:simlib3::Expression	signature:()
simlib3::Expression::Value	simlib.h	/^  double Value();       \/\/!< Evaluate expression and return the value$/;"	p	struct:simlib3::Expression	access:public	signature:()
simlib3::FW	ni_fw.h	/^class FW : public SingleStepMethod {$/;"	c	namespace:simlib3	inherits:SingleStepMethod
simlib3::FW::ERR	ni_fw.h	/^  Memory Y1, ERR;  \/\/ auxiliary memories$/;"	m	class:simlib3::FW	access:private
simlib3::FW::FW	ni_fw.h	/^  FW(const char* name) :  \/\/ registrate method and name it$/;"	f	class:simlib3::FW	access:public	signature:(const char* name)
simlib3::FW::FW_First	ni_fw.h	/^  bool FW_First;  \/\/ is method called for first time?$/;"	m	class:simlib3::FW	access:private
simlib3::FW::Integrate	ni_fw.cc	/^void FW::Integrate(void)$/;"	f	class:simlib3::FW	signature:(void)
simlib3::FW::Integrate	ni_fw.h	/^  virtual void Integrate(void);  \/\/ integration method$/;"	p	class:simlib3::FW	access:public	signature:(void)
simlib3::FW::PrepareStep	ni_fw.cc	/^bool FW::PrepareStep(void)$/;"	f	class:simlib3::FW	signature:(void)
simlib3::FW::PrepareStep	ni_fw.h	/^  virtual bool PrepareStep(void);  \/\/ prepare object for integration step$/;"	p	class:simlib3::FW	access:public	signature:(void)
simlib3::FW::Y1	ni_fw.h	/^  Memory Y1, ERR;  \/\/ auxiliary memories$/;"	m	class:simlib3::FW	access:private
simlib3::FW::prec	ni_fw.cc	/^const double FW::prec = DBL_EPSILON; \/\/ near zero number$/;"	m	class:simlib3::FW	file:
simlib3::FW::prec	ni_fw.h	/^  static const double prec; \/\/ near zero number$/;"	m	class:simlib3::FW	access:protected
simlib3::FW::~FW	ni_fw.h	/^  virtual ~FW()  \/\/ destructor$/;"	f	class:simlib3::FW	access:public	signature:()
simlib3::Facility	simlib.h	/^class Facility : public SimObject {$/;"	c	namespace:simlib3	inherits:SimObject
simlib3::Facility::Busy	simlib.h	/^  bool Busy() const { return in!=0; }$/;"	f	class:simlib3::Facility	access:public	signature:() const
simlib3::Facility::Clear	facility.cc	/^void Facility::Clear()$/;"	f	class:simlib3::Facility	signature:()
simlib3::Facility::Clear	simlib.h	/^  virtual void Clear();                          \/\/!< initialize$/;"	p	class:simlib3::Facility	access:public	signature:()
simlib3::Facility::Facility	facility.cc	/^Facility::Facility()$/;"	f	class:simlib3::Facility	signature:()
simlib3::Facility::Facility	facility.cc	/^Facility::Facility(Queue * queue)$/;"	f	class:simlib3::Facility	signature:(Queue * queue)
simlib3::Facility::Facility	facility.cc	/^Facility::Facility(const char *name)$/;"	f	class:simlib3::Facility	signature:(const char *name)
simlib3::Facility::Facility	facility.cc	/^Facility::Facility(const char *name, Queue * queue)$/;"	f	class:simlib3::Facility	signature:(const char *name, Queue * queue)
simlib3::Facility::Facility	simlib.h	/^    Facility(const Facility&);                  \/\/ disable$/;"	p	class:simlib3::Facility	access:private	signature:(const Facility&)
simlib3::Facility::Facility	simlib.h	/^  Facility();$/;"	p	class:simlib3::Facility	access:public	signature:()
simlib3::Facility::Facility	simlib.h	/^  Facility(Queue *_queue1);$/;"	p	class:simlib3::Facility	access:public	signature:(Queue *_queue1)
simlib3::Facility::Facility	simlib.h	/^  Facility(const char *_name);$/;"	p	class:simlib3::Facility	access:public	signature:(const char *_name)
simlib3::Facility::Facility	simlib.h	/^  Facility(const char *_name, Queue *_queue1);$/;"	p	class:simlib3::Facility	access:public	signature:(const char *_name, Queue *_queue1)
simlib3::Facility::Output	output2.cc	/^void Facility::Output() const$/;"	f	class:simlib3::Facility	signature:() const
simlib3::Facility::Output	simlib.h	/^  virtual void Output() const;                   \/\/!< print statistics$/;"	p	class:simlib3::Facility	access:public	signature:() const
simlib3::Facility::OwnQueue	facility.cc	/^bool Facility::OwnQueue() const$/;"	f	class:simlib3::Facility	signature:() const
simlib3::Facility::OwnQueue	simlib.h	/^  bool OwnQueue() const;                         \/\/!< test for default queue$/;"	p	class:simlib3::Facility	access:public	signature:() const
simlib3::Facility::Q1	simlib.h	/^  Queue  *Q1;                \/\/!< input queue$/;"	m	class:simlib3::Facility	access:public
simlib3::Facility::Q2	simlib.h	/^  Queue  *Q2;                \/\/!< interrupted requests queue$/;"	m	class:simlib3::Facility	access:public
simlib3::Facility::QueueIn	facility.cc	/^void Facility::QueueIn(Entity * e, ServicePriority_t sp)$/;"	f	class:simlib3::Facility	signature:(Entity * e, ServicePriority_t sp)
simlib3::Facility::QueueIn	simlib.h	/^  virtual void QueueIn(Entity *e, ServicePriority_t sp); \/\/ go into queue Q1$/;"	p	class:simlib3::Facility	access:public	signature:(Entity *e, ServicePriority_t sp)
simlib3::Facility::QueueIn2	facility.cc	/^void Facility::QueueIn2(Entity * e)$/;"	f	class:simlib3::Facility	signature:(Entity * e)
simlib3::Facility::QueueIn2	simlib.h	/^  virtual void QueueIn2(Entity *e);              \/\/ do into Q2$/;"	p	class:simlib3::Facility	access:protected	signature:(Entity *e)
simlib3::Facility::QueueLen	simlib.h	/^  unsigned QueueLen() const { return Q1->size(); }$/;"	f	class:simlib3::Facility	access:public	signature:() const
simlib3::Facility::Release	facility.cc	/^void Facility::Release(Entity * e)$/;"	f	class:simlib3::Facility	signature:(Entity * e)
simlib3::Facility::Release	simlib.h	/^  virtual void Release(Entity *e);$/;"	p	class:simlib3::Facility	access:public	signature:(Entity *e)
simlib3::Facility::Seize	facility.cc	/^void Facility::Seize(Entity * e, ServicePriority_t sp)$/;"	f	class:simlib3::Facility	signature:(Entity * e, ServicePriority_t sp)
simlib3::Facility::Seize	simlib.h	/^  virtual void Seize(Entity *e, ServicePriority_t sp=DEFAULT_PRIORITY);$/;"	p	class:simlib3::Facility	access:public	signature:(Entity *e, ServicePriority_t sp=DEFAULT_PRIORITY)
simlib3::Facility::SetQueue	facility.cc	/^void Facility::SetQueue(Queue * queue)$/;"	f	class:simlib3::Facility	signature:(Queue * queue)
simlib3::Facility::SetQueue	simlib.h	/^  void SetQueue(Queue *queue1);                  \/\/!< change input queue$/;"	p	class:simlib3::Facility	access:public	signature:(Queue *queue1)
simlib3::Facility::_Qflag	simlib.h	/^  unsigned char _Qflag;$/;"	m	class:simlib3::Facility	access:private
simlib3::Facility::in	simlib.h	/^  Entity *in;                \/\/!< entity currently in service$/;"	m	class:simlib3::Facility	access:public
simlib3::Facility::operator =	simlib.h	/^    Facility&operator=(const Facility&);        \/\/ disable$/;"	p	class:simlib3::Facility	access:private	signature:(const Facility&)
simlib3::Facility::operator Facility*	simlib.h	/^  operator Facility* () { return this; }$/;"	f	class:simlib3::Facility	access:public	signature:()
simlib3::Facility::tstat	simlib.h	/^  TStat tstat;               \/\/ stat$/;"	m	class:simlib3::Facility	access:public
simlib3::Facility::~Facility	facility.cc	/^Facility::~Facility()$/;"	f	class:simlib3::Facility	signature:()
simlib3::Facility::~Facility	simlib.h	/^  virtual ~Facility();$/;"	p	class:simlib3::Facility	access:public	signature:()
simlib3::Frict	simlib.h	/^class Frict : public aContiBlock1 {$/;"	c	namespace:simlib3	inherits:aContiBlock1
simlib3::Frict::Frict	simlib.h	/^  Frict(Input in, double l, double h, double tga=1.0);$/;"	p	class:simlib3::Frict	access:public	signature:(Input in, double l, double h, double tga=1.0)
simlib3::Frict::Frict	stdblock.cc	/^Frict::Frict(Input in, double l, double h, double tga)$/;"	f	class:simlib3::Frict	signature:(Input in, double l, double h, double tga)
simlib3::Frict::Name	simlib.h	/^  virtual const char *Name() const;$/;"	p	class:simlib3::Frict	access:public	signature:() const
simlib3::Frict::Name	stdblock.cc	/^const char *Frict::Name() const$/;"	f	class:simlib3::Frict	signature:() const
simlib3::Frict::Value	simlib.h	/^  virtual double Value();         \/\/ returned value$/;"	p	class:simlib3::Frict	access:public	signature:()
simlib3::Frict::Value	stdblock.cc	/^double Frict::Value()$/;"	f	class:simlib3::Frict	signature:()
simlib3::Frict::_Eval	simlib.h	/^  virtual void _Eval();           \/\/ evaluation with loop check$/;"	p	class:simlib3::Frict	access:public	signature:()
simlib3::Frict::_Eval	stdblock.cc	/^void Frict::_Eval()$/;"	f	class:simlib3::Frict	signature:()
simlib3::Frict::high	simlib.h	/^  double low, high;               \/\/ limits$/;"	m	class:simlib3::Frict	access:protected
simlib3::Frict::low	simlib.h	/^  double low, high;               \/\/ limits$/;"	m	class:simlib3::Frict	access:protected
simlib3::Frict::tgalpha	simlib.h	/^  double tgalpha;                 \/\/$/;"	m	class:simlib3::Frict	access:protected
simlib3::Friction	simlib.h	/^typedef Frict Friction;$/;"	t	namespace:simlib3
simlib3::Function1	simlib.h	/^class Function1 : public aContiBlock1 {$/;"	c	namespace:simlib3	inherits:aContiBlock1
simlib3::Function1::Function1	fun.cc	/^Function1::Function1(Input i, double (*pf)(double))$/;"	f	class:simlib3::Function1	signature:(Input i, double (*pf)(double))
simlib3::Function1::Function1	simlib.h	/^    Function1(const Function1&); \/\/ ## disable$/;"	p	class:simlib3::Function1	access:private	signature:(const Function1&)
simlib3::Function1::Function1	simlib.h	/^  Function1(Input i, double (*pf)(double));$/;"	p	class:simlib3::Function1	access:public	signature:(Input i, double (*pf)(double))
simlib3::Function1::Name	fun.cc	/^const char *Function1::Name() const {$/;"	f	class:simlib3::Function1	signature:() const
simlib3::Function1::Name	simlib.h	/^  virtual const char *Name() const;$/;"	p	class:simlib3::Function1	access:public	signature:() const
simlib3::Function1::Value	fun.cc	/^double Function1::Value() {$/;"	f	class:simlib3::Function1	signature:()
simlib3::Function1::Value	simlib.h	/^  virtual double Value();$/;"	p	class:simlib3::Function1	access:public	signature:()
simlib3::Function1::f	simlib.h	/^  double (*f)(double); \/\/ pointer to function$/;"	m	class:simlib3::Function1	access:private
simlib3::Function1::operator =	simlib.h	/^    Function1&operator=(const Function1&); \/\/ ## disable$/;"	p	class:simlib3::Function1	access:private	signature:(const Function1&)
simlib3::Function2	simlib.h	/^class Function2 : public aContiBlock2 {$/;"	c	namespace:simlib3	inherits:aContiBlock2
simlib3::Function2::Function2	fun.cc	/^Function2::Function2(Input i1, Input i2, double (*pf)(double,double))$/;"	f	class:simlib3::Function2	signature:(Input i1, Input i2, double (*pf)(double,double))
simlib3::Function2::Function2	simlib.h	/^    Function2(const Function2&); \/\/ ## disable$/;"	p	class:simlib3::Function2	access:private	signature:(const Function2&)
simlib3::Function2::Function2	simlib.h	/^  Function2(Input i1, Input i2, double (*pf)(double,double));$/;"	p	class:simlib3::Function2	access:public	signature:(Input i1, Input i2, double (*pf)(double,double))
simlib3::Function2::Name	fun.cc	/^const char *Function2::Name() const {$/;"	f	class:simlib3::Function2	signature:() const
simlib3::Function2::Name	simlib.h	/^  virtual const char *Name() const;$/;"	p	class:simlib3::Function2	access:public	signature:() const
simlib3::Function2::Value	fun.cc	/^double Function2::Value() {$/;"	f	class:simlib3::Function2	signature:()
simlib3::Function2::Value	simlib.h	/^  virtual double Value();$/;"	p	class:simlib3::Function2	access:public	signature:()
simlib3::Function2::f	simlib.h	/^  double (*f)(double,double); \/\/ pointer to function$/;"	m	class:simlib3::Function2	access:private
simlib3::Function2::operator =	simlib.h	/^    Function2&operator=(const Function2&); \/\/ ## disable$/;"	p	class:simlib3::Function2	access:private	signature:(const Function2&)
simlib3::Gamma	random2.cc	/^double Gamma(double alfa, double beta)$/;"	f	namespace:simlib3	signature:(double alfa, double beta)
simlib3::Gamma	simlib.h	/^double Gamma(double alfa, double beta);$/;"	p	namespace:simlib3	signature:(double alfa, double beta)
simlib3::Geom	random2.cc	/^int Geom(double q)$/;"	f	namespace:simlib3	signature:(double q)
simlib3::Geom	simlib.h	/^int    Geom(double q);$/;"	p	namespace:simlib3	signature:(double q)
simlib3::GetMethod	simlib.h	/^inline const char* GetMethod(void)$/;"	f	namespace:simlib3	signature:(void)
simlib3::GetName	name.cc	/^const char *GetName(SimObject & o)$/;"	f	namespace:simlib3	signature:(SimObject & o)
simlib3::GetName	name.cc	/^const char *GetName(SimObject * o)$/;"	f	namespace:simlib3	signature:(SimObject * o)
simlib3::GetName	simlib.h	/^const char *GetName(SimObject &o);$/;"	p	namespace:simlib3	signature:(SimObject &o)
simlib3::GetName	simlib.h	/^const char *GetName(SimObject *o);$/;"	p	namespace:simlib3	signature:(SimObject *o)
simlib3::GetStarter	simlib.h	/^inline const char* GetStarter(const char* name)$/;"	f	namespace:simlib3	signature:(const char* name)
simlib3::GetStarter	simlib.h	/^inline const char* GetStarter(void)$/;"	f	namespace:simlib3	signature:(void)
simlib3::Graph::Behavior	graph.cc	/^void Graph::Behavior()$/;"	f	class:simlib3::Graph	signature:()
simlib3::Graph::CtrInit	graph.cc	/^void Graph::CtrInit(char *name) \/\/ common initialization$/;"	f	class:simlib3::Graph	signature:(char *name)
simlib3::Graph::First	graph.cc	/^Graph *Graph::First = 0;$/;"	m	class:simlib3::Graph	file:
simlib3::Graph::Graph	graph.cc	/^Graph::Graph(char *_name, Input i, double dTime) : in(i), TimeStep(dTime)$/;"	f	class:simlib3::Graph	signature:(char *_name, Input i, double dTime)
simlib3::Graph::Initialize	graph.cc	/^void Graph::Initialize()$/;"	f	class:simlib3::Graph	signature:()
simlib3::Graph::Sample	graph.cc	/^void Graph::Sample()$/;"	f	class:simlib3::Graph	signature:()
simlib3::Graph::StartSampling	graph.cc	/^void Graph::StartSampling()$/;"	f	class:simlib3::Graph	signature:()
simlib3::Graph::StopSampling	graph.cc	/^void Graph::StopSampling()$/;"	f	class:simlib3::Graph	signature:()
simlib3::Graph::~Graph	graph.cc	/^Graph::~Graph()$/;"	f	class:simlib3::Graph	signature:()
simlib3::HIGHEST_PRIORITY	simlib.h	/^  HIGHEST_PRIORITY = 127,$/;"	e	enum:simlib3::__anon1
simlib3::Histogram	simlib.h	/^class Histogram : public SimObject {$/;"	c	namespace:simlib3	inherits:SimObject
simlib3::Histogram::Clear	histo.cc	/^void Histogram::Clear()$/;"	f	class:simlib3::Histogram	signature:()
simlib3::Histogram::Clear	simlib.h	/^  virtual void Clear();                \/\/ initialize (zero) value array$/;"	p	class:simlib3::Histogram	access:public	signature:()
simlib3::Histogram::Count	simlib.h	/^  unsigned Count() const { return count; }$/;"	f	class:simlib3::Histogram	access:public	signature:() const
simlib3::Histogram::High	simlib.h	/^  double High() const    { return low + step*count; }$/;"	f	class:simlib3::Histogram	access:public	signature:() const
simlib3::Histogram::Histogram	histo.cc	/^Histogram::Histogram() :$/;"	f	class:simlib3::Histogram	signature:()
simlib3::Histogram::Histogram	histo.cc	/^Histogram::Histogram(const char *n, double l, double s, unsigned c) :$/;"	f	class:simlib3::Histogram	signature:(const char *n, double l, double s, unsigned c)
simlib3::Histogram::Histogram	histo.cc	/^Histogram::Histogram(double l, double s, unsigned c) :$/;"	f	class:simlib3::Histogram	signature:(double l, double s, unsigned c)
simlib3::Histogram::Histogram	simlib.h	/^    Histogram(const Histogram&);           \/\/ disable$/;"	p	class:simlib3::Histogram	access:private	signature:(const Histogram&)
simlib3::Histogram::Histogram	simlib.h	/^  Histogram();$/;"	p	class:simlib3::Histogram	access:public	signature:()
simlib3::Histogram::Histogram	simlib.h	/^  Histogram(const char *_name, double low, double step, unsigned count=10);$/;"	p	class:simlib3::Histogram	access:public	signature:(const char *_name, double low, double step, unsigned count=10)
simlib3::Histogram::Histogram	simlib.h	/^  Histogram(double low, double step, unsigned count=10);$/;"	p	class:simlib3::Histogram	access:public	signature:(double low, double step, unsigned count=10)
simlib3::Histogram::Init	histo.cc	/^void Histogram::Init(double l, double s, unsigned c)$/;"	f	class:simlib3::Histogram	signature:(double l, double s, unsigned c)
simlib3::Histogram::Init	simlib.h	/^  void Init(double low, double step, unsigned count);$/;"	p	class:simlib3::Histogram	access:public	signature:(double low, double step, unsigned count)
simlib3::Histogram::Low	simlib.h	/^  double Low() const     { return low; }$/;"	f	class:simlib3::Histogram	access:public	signature:() const
simlib3::Histogram::Output	output2.cc	/^void Histogram::Output() const$/;"	f	class:simlib3::Histogram	signature:() const
simlib3::Histogram::Output	simlib.h	/^  virtual void Output() const;         \/\/!< print to default output$/;"	p	class:simlib3::Histogram	access:public	signature:() const
simlib3::Histogram::Step	simlib.h	/^  double Step() const    { return step; }$/;"	f	class:simlib3::Histogram	access:public	signature:() const
simlib3::Histogram::count	simlib.h	/^  unsigned count;            \/\/ number of intervals$/;"	m	class:simlib3::Histogram	access:protected
simlib3::Histogram::dptr	simlib.h	/^  unsigned *dptr;            \/\/ value array$/;"	m	class:simlib3::Histogram	access:protected
simlib3::Histogram::low	simlib.h	/^  double   low;              \/\/ low bound$/;"	m	class:simlib3::Histogram	access:protected
simlib3::Histogram::operator ()	histo.cc	/^void Histogram::operator () (double x)$/;"	f	class:simlib3::Histogram	signature:(double x)
simlib3::Histogram::operator ()	simlib.h	/^  void operator () (double x);         \/\/ record value x$/;"	p	class:simlib3::Histogram	access:public	signature:(double x)
simlib3::Histogram::operator =	simlib.h	/^    Histogram&operator=(const Histogram&); \/\/ disable$/;"	p	class:simlib3::Histogram	access:private	signature:(const Histogram&)
simlib3::Histogram::operator []	histo.cc	/^unsigned Histogram::operator [] (unsigned i) const$/;"	f	class:simlib3::Histogram	signature:(unsigned i) const
simlib3::Histogram::operator []	simlib.h	/^  unsigned operator [](unsigned i) const;  \/\/ # of items in interval[i]$/;"	p	class:simlib3::Histogram	access:public	signature:(unsigned i) const
simlib3::Histogram::stat	simlib.h	/^  Stat     stat;             \/\/ statistics$/;"	m	class:simlib3::Histogram	access:public
simlib3::Histogram::step	simlib.h	/^  double   step;             \/\/ interval width$/;"	m	class:simlib3::Histogram	access:protected
simlib3::Histogram::~Histogram	histo.cc	/^Histogram::~Histogram()$/;"	f	class:simlib3::Histogram	signature:()
simlib3::Histogram::~Histogram	simlib.h	/^  ~Histogram();$/;"	p	class:simlib3::Histogram	access:public	signature:()
simlib3::HyperGeom	random2.cc	/^int HyperGeom(double p, int n, int m)$/;"	f	namespace:simlib3	signature:(double p, int n, int m)
simlib3::HyperGeom	simlib.h	/^int    HyperGeom(double p, int n, int m);$/;"	p	namespace:simlib3	signature:(double p, int n, int m)
simlib3::Hyst	simlib.h	/^class Hyst : public Status {$/;"	c	namespace:simlib3	inherits:Status
simlib3::Hyst::Eval	simlib.h	/^    virtual void Eval();           \/\/ block evaluation$/;"	p	class:simlib3::Hyst	access:protected	signature:()
simlib3::Hyst::Eval	stdblock.cc	/^void Hyst::Eval()$/;"	f	class:simlib3::Hyst	signature:()
simlib3::Hyst::Hyst	simlib.h	/^    Hyst(Input i, double p1, double p2, double y1, double y2, double tga);$/;"	p	class:simlib3::Hyst	access:public	signature:(Input i, double p1, double p2, double y1, double y2, double tga)
simlib3::Hyst::Hyst	stdblock.cc	/^Hyst::Hyst(Input i, double _p1, double _p2, double _y1, double _y2, double _tga)$/;"	f	class:simlib3::Hyst	signature:(Input i, double _p1, double _p2, double _y1, double _y2, double _tga)
simlib3::Hyst::Name	simlib.h	/^    virtual const char *Name() const;$/;"	p	class:simlib3::Hyst	access:public	signature:() const
simlib3::Hyst::Name	stdblock.cc	/^const char *Hyst::Name() const$/;"	f	class:simlib3::Hyst	signature:() const
simlib3::Hyst::p1	simlib.h	/^    double p1,p2;$/;"	m	class:simlib3::Hyst	access:protected
simlib3::Hyst::p2	simlib.h	/^    double p1,p2;$/;"	m	class:simlib3::Hyst	access:protected
simlib3::Hyst::tga	simlib.h	/^    double tga;$/;"	m	class:simlib3::Hyst	access:protected
simlib3::Hyst::y1	simlib.h	/^    double y1,y2;$/;"	m	class:simlib3::Hyst	access:protected
simlib3::Hyst::y2	simlib.h	/^    double y1,y2;$/;"	m	class:simlib3::Hyst	access:protected
simlib3::Hysteresis	simlib.h	/^typedef Hyst Hysteresis; \/\/ alias name$/;"	t	namespace:simlib3
simlib3::INICONST	random1.cc	/^const myint32 INICONST   = 1537L;$/;"	m	namespace:simlib3	file:
simlib3::INITIALIZATION	internal.h	/^    INITIALIZATION, \/\/ after Init() call$/;"	e	enum:simlib3::SIMLIB_Phase_t
simlib3::Init	simlib.h	/^inline void Init(double t0, double t1=SIMLIB_MAXTIME) {$/;"	f	namespace:simlib3	signature:(double t0, double t1=SIMLIB_MAXTIME)
simlib3::Input	simlib.h	/^class Input {$/;"	c	namespace:simlib3
simlib3::Input2D	simlib2D.h	/^class Input2D {                   \/\/ small objects, without virtual methods$/;"	c	namespace:simlib3
simlib3::Input2D::Input2D	simlib2D.h	/^  Input2D(aContiBlock2D &cb): bp(&cb) {}         \/\/ reference to 2D block$/;"	f	class:simlib3::Input2D	access:public	signature:(aContiBlock2D &cb)
simlib3::Input2D::Input2D	simlib2D.h	/^  Input2D(aContiBlock2D *cb): bp(cb)  {}         \/\/ pointer to 2D block$/;"	f	class:simlib3::Input2D	access:public	signature:(aContiBlock2D *cb)
simlib3::Input2D::Input2D	simlib2D.h	/^  Input2D(const Input2D &in): bp(in.bp) {}       \/\/ copy reference$/;"	f	class:simlib3::Input2D	access:public	signature:(const Input2D &in)
simlib3::Input2D::Set	simlib2D.h	/^  Input2D Set(Input2D i)    { Input2D p=bp; bp=i.bp; return p; }$/;"	f	class:simlib3::Input2D	access:public	signature:(Input2D i)
simlib3::Input2D::Value	simlib2D.h	/^  Value2D Value()           { return bp->Value(); }   \/\/ get value$/;"	f	class:simlib3::Input2D	access:public	signature:()
simlib3::Input2D::bp	simlib2D.h	/^  aContiBlock2D *bp;$/;"	m	class:simlib3::Input2D	access:private
simlib3::Input2D::operator =	simlib2D.h	/^  Input2D&operator=(const Input2D&x) { bp=x.bp; return *this; }$/;"	f	class:simlib3::Input2D	access:public	signature:(const Input2D&x)
simlib3::Input2D::operator ==	simlib2D.h	/^  bool operator ==(void *p) { return bp==p; }         \/\/ for tests only!$/;"	f	class:simlib3::Input2D	access:public	signature:(void *p)
simlib3::Input3D	simlib3D.h	/^class Input3D {                   \/\/ small objects, without virtual methods$/;"	c	namespace:simlib3
simlib3::Input3D::Input3D	simlib3D.h	/^  Input3D(aContiBlock3D &cb): bp(&cb) {}          \/\/ reference to 3D block$/;"	f	class:simlib3::Input3D	access:public	signature:(aContiBlock3D &cb)
simlib3::Input3D::Input3D	simlib3D.h	/^  Input3D(aContiBlock3D *cb): bp(cb)  {}          \/\/ pointer to 3D block$/;"	f	class:simlib3::Input3D	access:public	signature:(aContiBlock3D *cb)
simlib3::Input3D::Input3D	simlib3D.h	/^  Input3D(const Input3D &inp): bp(inp.bp) {}      \/\/ copy reference$/;"	f	class:simlib3::Input3D	access:public	signature:(const Input3D &inp)
simlib3::Input3D::Set	simlib3D.h	/^  Input3D Set(Input3D i)     { Input3D p=bp; bp=i.bp; return p; }$/;"	f	class:simlib3::Input3D	access:public	signature:(Input3D i)
simlib3::Input3D::Value	simlib3D.h	/^  Value3D Value()            { return bp->Value(); }   \/\/ get value$/;"	f	class:simlib3::Input3D	access:public	signature:()
simlib3::Input3D::bp	simlib3D.h	/^  aContiBlock3D *bp;$/;"	m	class:simlib3::Input3D	access:private
simlib3::Input3D::operator =	simlib3D.h	/^  Input3D&operator=(const Input3D &in) { bp = in.bp; return *this; }$/;"	f	class:simlib3::Input3D	access:public	signature:(const Input3D &in)
simlib3::Input3D::operator ==	simlib3D.h	/^  bool operator ==(void *p)       { return bp==p; }         \/\/ for tests only!$/;"	f	class:simlib3::Input3D	access:public	signature:(void *p)
simlib3::Input::Input	simlib.h	/^  Input(); \/\/ disable default constructor$/;"	p	class:simlib3::Input	access:private	signature:()
simlib3::Input::Input	simlib.h	/^  Input(aContiBlock &cb): bp(&cb) { RegisterReference(bp); } \/\/!< reference to block$/;"	f	class:simlib3::Input	access:public	signature:(aContiBlock &cb)
simlib3::Input::Input	simlib.h	/^  Input(aContiBlock *cb): bp(cb)  { RegisterReference(bp); } \/\/!< pointer to block$/;"	f	class:simlib3::Input	access:public	signature:(aContiBlock *cb)
simlib3::Input::Input	simlib.h	/^  Input(const Input &i): bp(i.bp) { RegisterReference(bp); }$/;"	f	class:simlib3::Input	access:public	signature:(const Input &i)
simlib3::Input::Input	simlib.h	/^  Input(const double c):  bp(new Constant(c)) { RegisterReference(bp); }$/;"	f	class:simlib3::Input	access:public	signature:(const double c)
simlib3::Input::Set	simlib.h	/^  Input Set(Input i)     {$/;"	f	class:simlib3::Input	access:public	signature:(Input i)
simlib3::Input::Value	simlib.h	/^  double Value() const { return bp->Value(); } \/\/!< get target block value$/;"	f	class:simlib3::Input	access:public	signature:() const
simlib3::Input::bp	simlib.h	/^  aContiBlock *bp;$/;"	m	class:simlib3::Input	access:private
simlib3::Input::operator =	simlib.h	/^  Input &operator= (const Input&x) {$/;"	f	class:simlib3::Input	access:public	signature:(const Input&x)
simlib3::Input::operator ==	simlib.h	/^  bool operator ==(aContiBlock *p) const { return bp==p; } \/\/ for tests only$/;"	f	class:simlib3::Input	access:public	signature:(aContiBlock *p) const
simlib3::Input::~Input	simlib.h	/^  ~Input() { UnRegisterReference(bp); }$/;"	f	class:simlib3::Input	access:public	signature:()
simlib3::InstallBreak	run.cc	/^void InstallBreak(void (*f)()) { \/\/ for user interface (in simlib.h)$/;"	f	namespace:simlib3	signature:(void (*f)())
simlib3::InstallBreak	simlib.h	/^void InstallBreak(void (*f)());$/;"	p	namespace:simlib3	signature:(void (*f)())
simlib3::Insv	simlib.h	/^class Insv : public aContiBlock1 {$/;"	c	namespace:simlib3	inherits:aContiBlock1
simlib3::Insv::Insv	simlib.h	/^  Insv(Input in, double l, double h, double tga=1.0, double tgb=1.0);$/;"	p	class:simlib3::Insv	access:public	signature:(Input in, double l, double h, double tga=1.0, double tgb=1.0)
simlib3::Insv::Insv	stdblock.cc	/^Insv::Insv(Input in, double l, double h, double tga, double tgb)$/;"	f	class:simlib3::Insv	signature:(Input in, double l, double h, double tga, double tgb)
simlib3::Insv::Name	simlib.h	/^  virtual const char *Name() const;$/;"	p	class:simlib3::Insv	access:public	signature:() const
simlib3::Insv::Name	stdblock.cc	/^const char *Insv::Name() const$/;"	f	class:simlib3::Insv	signature:() const
simlib3::Insv::Value	simlib.h	/^  virtual double Value();         \/\/ returned value$/;"	p	class:simlib3::Insv	access:public	signature:()
simlib3::Insv::Value	stdblock.cc	/^double Insv::Value()$/;"	f	class:simlib3::Insv	signature:()
simlib3::Insv::_Eval	simlib.h	/^  virtual void _Eval();           \/\/ evaluation with loop check$/;"	p	class:simlib3::Insv	access:public	signature:()
simlib3::Insv::_Eval	stdblock.cc	/^void Insv::_Eval()$/;"	f	class:simlib3::Insv	signature:()
simlib3::Insv::high	simlib.h	/^  double low, high;               \/\/ limits$/;"	m	class:simlib3::Insv	access:protected
simlib3::Insv::low	simlib.h	/^  double low, high;               \/\/ limits$/;"	m	class:simlib3::Insv	access:protected
simlib3::Insv::tgalpha	simlib.h	/^  double tgalpha,tgbeta;          \/\/$/;"	m	class:simlib3::Insv	access:protected
simlib3::Insv::tgbeta	simlib.h	/^  double tgalpha,tgbeta;          \/\/$/;"	m	class:simlib3::Insv	access:protected
simlib3::IntegrationMethod	simlib.h	/^class IntegrationMethod {$/;"	c	namespace:simlib3
simlib3::IntegrationMethod::CurrentMethodPtr	numint.cc	/^IntegrationMethod* IntegrationMethod::CurrentMethodPtr = &rke;$/;"	m	class:simlib3::IntegrationMethod	file:
simlib3::IntegrationMethod::CurrentMethodPtr	simlib.h	/^  static IntegrationMethod* CurrentMethodPtr;  \/\/ method used at present$/;"	m	class:simlib3::IntegrationMethod	access:private
simlib3::IntegrationMethod::FirstIntegrator	simlib.h	/^  static Iterator FirstIntegrator(void) {  \/\/ it. to first integrator in list$/;"	f	class:simlib3::IntegrationMethod	access:protected	signature:(void)
simlib3::IntegrationMethod::FunCall	numint.cc	/^void IntegrationMethod::FunCall(double step_frag)$/;"	f	class:simlib3::IntegrationMethod	signature:(double step_frag)
simlib3::IntegrationMethod::FunCall	simlib.h	/^  static void FunCall(double step_frag); \/\/ evaluate y'(t) = f(t, y(t))$/;"	p	class:simlib3::IntegrationMethod	access:public	signature:(double step_frag)
simlib3::IntegrationMethod::GetErrNo	simlib.h	/^  static int GetErrNo(void) { \/\/ return # of errors$/;"	f	class:simlib3::IntegrationMethod	access:public	signature:(void)
simlib3::IntegrationMethod::GetMethod	simlib.h	/^  static const char* GetMethod(void) {  \/\/ get name of method which is used$/;"	f	class:simlib3::IntegrationMethod	access:public	signature:(void)
simlib3::IntegrationMethod::InitStep	numint.cc	/^void IntegrationMethod::InitStep(double step_frag)$/;"	f	class:simlib3::IntegrationMethod	signature:(double step_frag)
simlib3::IntegrationMethod::InitStep	simlib.h	/^  static void InitStep(double step_frag); \/\/ initialize step$/;"	p	class:simlib3::IntegrationMethod	access:public	signature:(double step_frag)
simlib3::IntegrationMethod::Integrate	simlib.h	/^  virtual void Integrate(void) = 0;  \/\/ the method does integration$/;"	p	class:simlib3::IntegrationMethod	access:public	signature:(void)
simlib3::IntegrationMethod::IntegrationDone	simlib.h	/^  static void IntegrationDone(void) {  \/\/ terminate integration$/;"	f	class:simlib3::IntegrationMethod	access:public	signature:(void)
simlib3::IntegrationMethod::IntegrationMethod	numint.cc	/^IntegrationMethod::IntegrationMethod(const char *name):$/;"	f	class:simlib3::IntegrationMethod	signature:(const char *name)
simlib3::IntegrationMethod::IntegrationMethod	simlib.h	/^    IntegrationMethod(const IntegrationMethod&); \/\/ ## disable$/;"	p	class:simlib3::IntegrationMethod	access:private	signature:(const IntegrationMethod&)
simlib3::IntegrationMethod::IntegrationMethod	simlib.h	/^  IntegrationMethod();  \/\/ forbid implicit constructor$/;"	p	class:simlib3::IntegrationMethod	access:private	signature:()
simlib3::IntegrationMethod::IntegrationMethod	simlib.h	/^  IntegrationMethod(IntegrationMethod&);  \/\/ forbid implicit copy-constructor$/;"	p	class:simlib3::IntegrationMethod	access:private	signature:(IntegrationMethod&)
simlib3::IntegrationMethod::IntegrationMethod	simlib.h	/^  IntegrationMethod(const char* name);  \/\/ registrate method and name it$/;"	p	class:simlib3::IntegrationMethod	access:public	signature:(const char* name)
simlib3::IntegrationMethod::IsConditionFlag	simlib.h	/^  static bool IsConditionFlag(void) { \/\/ wer any changes of condition vector?$/;"	f	class:simlib3::IntegrationMethod	access:public	signature:(void)
simlib3::IntegrationMethod::IsEndStepEvent	numint.cc	/^bool IntegrationMethod::IsEndStepEvent=false;$/;"	m	class:simlib3::IntegrationMethod	file:
simlib3::IntegrationMethod::IsEndStepEvent	simlib.h	/^  static bool IsEndStepEvent; \/\/ flag - will be event at the end of the step?$/;"	m	class:simlib3::IntegrationMethod	access:protected
simlib3::IntegrationMethod::IsSingleStep	simlib.h	/^  virtual bool IsSingleStep(void)=0; \/\/ is it a single-step method?$/;"	p	class:simlib3::IntegrationMethod	access:public	signature:(void)
simlib3::IntegrationMethod::ItList	simlib.h	/^  std::list<IntegrationMethod*>::iterator ItList;  \/\/ position in the list$/;"	m	class:simlib3::IntegrationMethod	access:private
simlib3::IntegrationMethod::Iterate	numint.cc	/^void IntegrationMethod::Iterate(void)$/;"	f	class:simlib3::IntegrationMethod	signature:(void)
simlib3::IntegrationMethod::Iterate	simlib.h	/^  static void Iterate(void);  \/\/ compute new values of state blocks$/;"	p	class:simlib3::IntegrationMethod	access:private	signature:(void)
simlib3::IntegrationMethod::Iterator	simlib.h	/^  typedef IntegratorContainer::iterator Iterator;  \/\/ iterator of intg. list$/;"	t	class:simlib3::IntegrationMethod	access:protected
simlib3::IntegrationMethod::LastIntegrator	simlib.h	/^  static Iterator LastIntegrator(void) {  \/\/ it. to last integrator in list$/;"	f	class:simlib3::IntegrationMethod	access:protected	signature:(void)
simlib3::IntegrationMethod::MList	simlib.h	/^  std::list<Memory*> MList;  \/\/ list of auxiliary memories$/;"	m	class:simlib3::IntegrationMethod	access:private
simlib3::IntegrationMethod::Memory	simlib.h	/^  class Memory {$/;"	c	class:simlib3::IntegrationMethod	access:protected
simlib3::IntegrationMethod::Memory::ListPtr	simlib.h	/^      std::list<Memory*> * ListPtr;  \/\/ which list is memory in$/;"	m	class:simlib3::IntegrationMethod::Memory	access:private
simlib3::IntegrationMethod::Memory::Memory	numint.cc	/^IntegrationMethod::Memory::Memory(std::list<Memory*>* PtrList) :$/;"	f	class:simlib3::IntegrationMethod::Memory	signature:(std::list<Memory*>* PtrList)
simlib3::IntegrationMethod::Memory::Memory	simlib.h	/^      Memory(Memory&);  \/\/ forbid copy constructor$/;"	p	class:simlib3::IntegrationMethod::Memory	access:private	signature:(Memory&)
simlib3::IntegrationMethod::Memory::Memory	simlib.h	/^      Memory(const Memory&); \/\/ ## disable$/;"	p	class:simlib3::IntegrationMethod::Memory	access:private	signature:(const Memory&)
simlib3::IntegrationMethod::Memory::Memory	simlib.h	/^      Memory(std::list<Memory*> * PtrList=PtrMList);  \/\/ create empty memory$/;"	p	class:simlib3::IntegrationMethod::Memory	access:public	signature:(std::list<Memory*> * PtrList=PtrMList)
simlib3::IntegrationMethod::Memory::Resize	numint.cc	/^void IntegrationMethod::Memory::Resize(size_t cs)$/;"	f	class:simlib3::IntegrationMethod::Memory	signature:(size_t cs)
simlib3::IntegrationMethod::Memory::Resize	simlib.h	/^      virtual void Resize(size_t cs); \/\/ change size, content will be undefined!$/;"	p	class:simlib3::IntegrationMethod::Memory	access:public	signature:(size_t cs)
simlib3::IntegrationMethod::Memory::arr	simlib.h	/^      double *arr;  \/\/ array$/;"	m	class:simlib3::IntegrationMethod::Memory	access:private
simlib3::IntegrationMethod::Memory::it_list	simlib.h	/^      std::list<Memory*>::iterator it_list;  \/\/ position in list$/;"	m	class:simlib3::IntegrationMethod::Memory	access:private
simlib3::IntegrationMethod::Memory::mem_size	simlib.h	/^      size_t mem_size;  \/\/ allocated memory size$/;"	m	class:simlib3::IntegrationMethod::Memory	access:private
simlib3::IntegrationMethod::Memory::operator =	simlib.h	/^      Memory&operator=(const Memory&); \/\/ ## disable$/;"	p	class:simlib3::IntegrationMethod::Memory	access:private	signature:(const Memory&)
simlib3::IntegrationMethod::Memory::operator =	simlib.h	/^      void operator= (Memory&);  \/\/ disable the operation$/;"	p	class:simlib3::IntegrationMethod::Memory	access:private	signature:(Memory&)
simlib3::IntegrationMethod::Memory::operator []	simlib.h	/^      double& operator[](size_t ind) {  \/\/ access the element of the array$/;"	f	class:simlib3::IntegrationMethod::Memory	access:public	signature:(size_t ind)
simlib3::IntegrationMethod::Memory::page_size	numint.cc	/^const size_t IntegrationMethod::Memory::page_size = 256;$/;"	m	class:simlib3::IntegrationMethod::Memory	file:
simlib3::IntegrationMethod::Memory::page_size	simlib.h	/^      static const size_t page_size;  \/\/ size of memory page$/;"	m	class:simlib3::IntegrationMethod::Memory	access:private
simlib3::IntegrationMethod::Memory::~Memory	numint.cc	/^IntegrationMethod::Memory::~Memory()$/;"	f	class:simlib3::IntegrationMethod::Memory	signature:()
simlib3::IntegrationMethod::Memory::~Memory	simlib.h	/^      virtual ~Memory();$/;"	p	class:simlib3::IntegrationMethod::Memory	access:public	signature:()
simlib3::IntegrationMethod::MthLstPtr	numint.cc	/^std::list<IntegrationMethod*>* IntegrationMethod::MthLstPtr=NULL;$/;"	m	class:simlib3::IntegrationMethod	file:
simlib3::IntegrationMethod::MthLstPtr	simlib.h	/^  static std::list<IntegrationMethod*>* MthLstPtr; \/\/ list of registrated methods$/;"	m	class:simlib3::IntegrationMethod	access:private
simlib3::IntegrationMethod::Prepare	numint.cc	/^bool IntegrationMethod::Prepare(void)$/;"	f	class:simlib3::IntegrationMethod	signature:(void)
simlib3::IntegrationMethod::Prepare	simlib.h	/^  static bool Prepare(void);  \/\/ prepare system for integration step$/;"	p	class:simlib3::IntegrationMethod	access:private	signature:(void)
simlib3::IntegrationMethod::PrepareStep	numint.cc	/^bool IntegrationMethod::PrepareStep(void)$/;"	f	class:simlib3::IntegrationMethod	signature:(void)
simlib3::IntegrationMethod::PrepareStep	simlib.h	/^  virtual bool PrepareStep(void);  \/\/ prepare object for integration step$/;"	p	class:simlib3::IntegrationMethod	access:public	signature:(void)
simlib3::IntegrationMethod::PrevINum	simlib.h	/^  size_t PrevINum;  \/\/ # of integrators in previous step$/;"	m	class:simlib3::IntegrationMethod	access:private
simlib3::IntegrationMethod::PtrMList	numint.cc	/^std::list<IntegrationMethod::Memory*>* IntegrationMethod::PtrMList;$/;"	m	class:simlib3::IntegrationMethod	file:
simlib3::IntegrationMethod::PtrMList	simlib.h	/^  static std::list<Memory*> * PtrMList;  \/\/ pointer to list being filled$/;"	m	class:simlib3::IntegrationMethod	access:private
simlib3::IntegrationMethod::Resize	numint.cc	/^void IntegrationMethod::Resize(size_t size)$/;"	f	class:simlib3::IntegrationMethod	signature:(size_t size)
simlib3::IntegrationMethod::Resize	simlib.h	/^  virtual void Resize(size_t size);  \/\/ resize all memories to given size$/;"	p	class:simlib3::IntegrationMethod	access:public	signature:(size_t size)
simlib3::IntegrationMethod::SearchMethod	numint.cc	/^IntegrationMethod* IntegrationMethod::SearchMethod(const char* name)$/;"	f	class:simlib3::IntegrationMethod	signature:(const char* name)
simlib3::IntegrationMethod::SearchMethod	simlib.h	/^  static IntegrationMethod* SearchMethod(const char* name);  \/\/ find method$/;"	p	class:simlib3::IntegrationMethod	access:protected	signature:(const char* name)
simlib3::IntegrationMethod::SetErrNo	simlib.h	/^  static void SetErrNo(int num) { \/\/ set # of errors$/;"	f	class:simlib3::IntegrationMethod	access:public	signature:(int num)
simlib3::IntegrationMethod::SetMethod	numint.cc	/^void IntegrationMethod::SetMethod(const char* name)$/;"	f	class:simlib3::IntegrationMethod	signature:(const char* name)
simlib3::IntegrationMethod::SetMethod	simlib.h	/^  static void SetMethod(const char* name);  \/\/ set method which will be used$/;"	p	class:simlib3::IntegrationMethod	access:public	signature:(const char* name)
simlib3::IntegrationMethod::SetOptStep	simlib.h	/^  static void SetOptStep(double opt_step) { \/\/ set optimal step size$/;"	f	class:simlib3::IntegrationMethod	access:public	signature:(double opt_step)
simlib3::IntegrationMethod::SetStepSize	simlib.h	/^  static void SetStepSize(double step_size) { \/\/ set step size$/;"	f	class:simlib3::IntegrationMethod	access:public	signature:(double step_size)
simlib3::IntegrationMethod::StateCond	numint.cc	/^bool IntegrationMethod::StateCond(void)$/;"	f	class:simlib3::IntegrationMethod	signature:(void)
simlib3::IntegrationMethod::StateCond	simlib.h	/^  static bool StateCond(void);  \/\/ check on changes of state conditions$/;"	p	class:simlib3::IntegrationMethod	access:protected	signature:(void)
simlib3::IntegrationMethod::StepSim	numint.cc	/^void IntegrationMethod::StepSim(void)$/;"	f	class:simlib3::IntegrationMethod	signature:(void)
simlib3::IntegrationMethod::StepSim	simlib.h	/^  static void StepSim(void);  \/\/ single step of numerical integration method$/;"	p	class:simlib3::IntegrationMethod	access:public	signature:(void)
simlib3::IntegrationMethod::Summarize	numint.cc	/^void IntegrationMethod::Summarize(void)$/;"	f	class:simlib3::IntegrationMethod	signature:(void)
simlib3::IntegrationMethod::Summarize	simlib.h	/^  static void Summarize(void);  \/\/ set up new state after integration$/;"	p	class:simlib3::IntegrationMethod	access:private	signature:(void)
simlib3::IntegrationMethod::TurnOff	numint.cc	/^void IntegrationMethod::TurnOff(void)$/;"	f	class:simlib3::IntegrationMethod	signature:(void)
simlib3::IntegrationMethod::TurnOff	simlib.h	/^  virtual void TurnOff(void);  \/\/ turn off integration method$/;"	p	class:simlib3::IntegrationMethod	access:public	signature:(void)
simlib3::IntegrationMethod::method_name	simlib.h	/^  const char* method_name;  \/\/ C-string --- the name of the method$/;"	m	class:simlib3::IntegrationMethod	access:private
simlib3::IntegrationMethod::operator =	simlib.h	/^    IntegrationMethod&operator=(const IntegrationMethod&); \/\/ ## disable$/;"	p	class:simlib3::IntegrationMethod	access:private	signature:(const IntegrationMethod&)
simlib3::IntegrationMethod::~IntegrationMethod	numint.cc	/^IntegrationMethod::~IntegrationMethod() {$/;"	f	class:simlib3::IntegrationMethod	signature:()
simlib3::IntegrationMethod::~IntegrationMethod	simlib.h	/^  virtual ~IntegrationMethod();  \/\/ destructor unregistrates method$/;"	p	class:simlib3::IntegrationMethod	access:public	signature:()
simlib3::Integrator	simlib.h	/^class Integrator : public aContiBlock {   \/\/ integrator$/;"	c	namespace:simlib3	inherits:aContiBlock
simlib3::Integrator2D	simlib2D.h	/^class Integrator2D : public aContiBlock2D {$/;"	c	namespace:simlib3	inherits:aContiBlock2D
simlib3::Integrator2D::Integrator2D	simlib2D.cc	/^Integrator2D::Integrator2D():$/;"	f	class:simlib3::Integrator2D	signature:()
simlib3::Integrator2D::Integrator2D	simlib2D.cc	/^Integrator2D::Integrator2D(Input2D i):$/;"	f	class:simlib3::Integrator2D	signature:(Input2D i)
simlib3::Integrator2D::Integrator2D	simlib2D.cc	/^Integrator2D::Integrator2D(Input2D i, Value2D initial_value):$/;"	f	class:simlib3::Integrator2D	signature:(Input2D i, Value2D initial_value)
simlib3::Integrator2D::Integrator2D	simlib2D.cc	/^Integrator2D::Integrator2D(Integrator2D &i, Value2D initial_value):$/;"	f	class:simlib3::Integrator2D	signature:(Integrator2D &i, Value2D initial_value)
simlib3::Integrator2D::Integrator2D	simlib2D.h	/^  Integrator2D();       \/\/ for arrays: implicit input value (0,0)$/;"	p	class:simlib3::Integrator2D	access:public	signature:()
simlib3::Integrator2D::Integrator2D	simlib2D.h	/^  Integrator2D(Input2D i);$/;"	p	class:simlib3::Integrator2D	access:public	signature:(Input2D i)
simlib3::Integrator2D::Integrator2D	simlib2D.h	/^  Integrator2D(Input2D i, Value2D initial_value);$/;"	p	class:simlib3::Integrator2D	access:public	signature:(Input2D i, Value2D initial_value)
simlib3::Integrator2D::Integrator2D	simlib2D.h	/^  Integrator2D(Integrator2D &i, Value2D initial_value=Value2D(0,0));$/;"	p	class:simlib3::Integrator2D	access:public	signature:(Integrator2D &i, Value2D initial_value=Value2D(0,0))
simlib3::Integrator2D::SetInput	simlib2D.h	/^  Input2D SetInput(Input2D i) { return in.in.Set(i); }$/;"	f	class:simlib3::Integrator2D	access:public	signature:(Input2D i)
simlib3::Integrator2D::Value	simlib2D.cc	/^Value2D Integrator2D::Value()$/;"	f	class:simlib3::Integrator2D	signature:()
simlib3::Integrator2D::Value	simlib2D.h	/^  virtual Value2D Value();      \/\/ 2D output$/;"	p	class:simlib3::Integrator2D	access:public	signature:()
simlib3::Integrator2D::_x	simlib2D.h	/^  Integrator _x,_y;          \/\/ 1D standard integrators$/;"	m	class:simlib3::Integrator2D	access:private
simlib3::Integrator2D::_y	simlib2D.h	/^  Integrator _x,_y;          \/\/ 1D standard integrators$/;"	m	class:simlib3::Integrator2D	access:private
simlib3::Integrator2D::in	simlib2D.h	/^  } in;$/;"	m	class:simlib3::Integrator2D	typeref:class:simlib3::Integrator2D::special_input	access:private
simlib3::Integrator2D::operator =	simlib2D.cc	/^Integrator2D &Integrator2D::operator = (Input2D i)$/;"	f	class:simlib3::Integrator2D	signature:(Input2D i)
simlib3::Integrator2D::operator =	simlib2D.cc	/^Integrator2D &Integrator2D::operator = (const Value2D &a)$/;"	f	class:simlib3::Integrator2D	signature:(const Value2D &a)
simlib3::Integrator2D::operator =	simlib2D.h	/^  Integrator2D &operator = (Input2D i);$/;"	p	class:simlib3::Integrator2D	access:public	signature:(Input2D i)
simlib3::Integrator2D::operator =	simlib2D.h	/^  Integrator2D &operator = (const Value2D &a);$/;"	p	class:simlib3::Integrator2D	access:public	signature:(const Value2D &a)
simlib3::Integrator2D::special_input	simlib2D.h	/^  class special_input : public aContiBlock {$/;"	c	class:simlib3::Integrator2D	inherits:aContiBlock	access:private
simlib3::Integrator2D::special_input::Value	simlib2D.cc	/^double Integrator2D::special_input::Value() {  \/\/ interface class$/;"	f	class:simlib3::Integrator2D::special_input	signature:()
simlib3::Integrator2D::special_input::Value	simlib2D.h	/^    double Value();             \/\/ expects 2 subsequent evaluations$/;"	p	class:simlib3::Integrator2D::special_input	access:public	signature:()
simlib3::Integrator2D::special_input::a	simlib2D.h	/^    Value2D a;                  \/\/ temporary value$/;"	m	class:simlib3::Integrator2D::special_input	access:private
simlib3::Integrator2D::special_input::count	simlib2D.h	/^    int count;                  \/\/ # of evaluations$/;"	m	class:simlib3::Integrator2D::special_input	access:private
simlib3::Integrator2D::special_input::in	simlib2D.h	/^    Input2D in;                 \/\/ 2D input$/;"	m	class:simlib3::Integrator2D::special_input	access:private
simlib3::Integrator2D::special_input::special_input	simlib2D.h	/^    special_input(Input2D i) : a(0,0), in(i), count(0) {}$/;"	f	class:simlib3::Integrator2D::special_input	access:public	signature:(Input2D i)
simlib3::Integrator3D	simlib3D.h	/^class Integrator3D : public aContiBlock3D {$/;"	c	namespace:simlib3	inherits:aContiBlock3D
simlib3::Integrator3D::Init	simlib3D.h	/^  void Init(const Value3D &v) {_x.Init(v.x()); _y.Init(v.y()); _z.Init(v.z());}$/;"	f	class:simlib3::Integrator3D	access:public	signature:(const Value3D &v)
simlib3::Integrator3D::Integrator3D	simlib3D.cc	/^Integrator3D::Integrator3D():$/;"	f	class:simlib3::Integrator3D	signature:()
simlib3::Integrator3D::Integrator3D	simlib3D.cc	/^Integrator3D::Integrator3D(Input3D i):$/;"	f	class:simlib3::Integrator3D	signature:(Input3D i)
simlib3::Integrator3D::Integrator3D	simlib3D.cc	/^Integrator3D::Integrator3D(Input3D i, Value3D initial_value):$/;"	f	class:simlib3::Integrator3D	signature:(Input3D i, Value3D initial_value)
simlib3::Integrator3D::Integrator3D	simlib3D.cc	/^Integrator3D::Integrator3D(Integrator3D &i, Value3D initial_value):$/;"	f	class:simlib3::Integrator3D	signature:(Integrator3D &i, Value3D initial_value)
simlib3::Integrator3D::Integrator3D	simlib3D.h	/^  Integrator3D();       \/\/ for arrays: implicit input value (0,0,0)$/;"	p	class:simlib3::Integrator3D	access:public	signature:()
simlib3::Integrator3D::Integrator3D	simlib3D.h	/^  Integrator3D(Input3D i);$/;"	p	class:simlib3::Integrator3D	access:public	signature:(Input3D i)
simlib3::Integrator3D::Integrator3D	simlib3D.h	/^  Integrator3D(Input3D i, Value3D initial_value);$/;"	p	class:simlib3::Integrator3D	access:public	signature:(Input3D i, Value3D initial_value)
simlib3::Integrator3D::Integrator3D	simlib3D.h	/^  Integrator3D(Integrator3D &i, Value3D initial_value=Value3D(0,0,0));$/;"	p	class:simlib3::Integrator3D	access:public	signature:(Integrator3D &i, Value3D initial_value=Value3D(0,0,0))
simlib3::Integrator3D::SetInput	simlib3D.h	/^  Input3D SetInput(Input3D i) { return in.in.Set(i); }$/;"	f	class:simlib3::Integrator3D	access:public	signature:(Input3D i)
simlib3::Integrator3D::Value	simlib3D.cc	/^Value3D Integrator3D::Value()$/;"	f	class:simlib3::Integrator3D	signature:()
simlib3::Integrator3D::Value	simlib3D.h	/^  virtual Value3D Value();      \/\/ 3D output$/;"	p	class:simlib3::Integrator3D	access:public	signature:()
simlib3::Integrator3D::_x	simlib3D.h	/^  Integrator _x,_y,_z;          \/\/ 1D standard integrators$/;"	m	class:simlib3::Integrator3D	access:private
simlib3::Integrator3D::_y	simlib3D.h	/^  Integrator _x,_y,_z;          \/\/ 1D standard integrators$/;"	m	class:simlib3::Integrator3D	access:private
simlib3::Integrator3D::_z	simlib3D.h	/^  Integrator _x,_y,_z;          \/\/ 1D standard integrators$/;"	m	class:simlib3::Integrator3D	access:private
simlib3::Integrator3D::in	simlib3D.h	/^  } in;$/;"	m	class:simlib3::Integrator3D	typeref:class:simlib3::Integrator3D::special_input	access:private
simlib3::Integrator3D::operator =	simlib3D.cc	/^Integrator3D &Integrator3D::operator = (Input3D i)$/;"	f	class:simlib3::Integrator3D	signature:(Input3D i)
simlib3::Integrator3D::operator =	simlib3D.cc	/^Integrator3D &Integrator3D::operator = (const Value3D &a)$/;"	f	class:simlib3::Integrator3D	signature:(const Value3D &a)
simlib3::Integrator3D::operator =	simlib3D.h	/^  Integrator3D &operator = (Input3D i);$/;"	p	class:simlib3::Integrator3D	access:public	signature:(Input3D i)
simlib3::Integrator3D::operator =	simlib3D.h	/^  Integrator3D &operator = (const Value3D &a);$/;"	p	class:simlib3::Integrator3D	access:public	signature:(const Value3D &a)
simlib3::Integrator3D::special_input	simlib3D.h	/^  class special_input : public aContiBlock {$/;"	c	class:simlib3::Integrator3D	inherits:aContiBlock	access:private
simlib3::Integrator3D::special_input::Value	simlib3D.cc	/^double Integrator3D::special_input::Value() {  \/\/ interface class$/;"	f	class:simlib3::Integrator3D::special_input	signature:()
simlib3::Integrator3D::special_input::Value	simlib3D.h	/^    double Value();             \/\/ expects 3 subsequent evaluations$/;"	p	class:simlib3::Integrator3D::special_input	access:public	signature:()
simlib3::Integrator3D::special_input::a	simlib3D.h	/^    Value3D a;                  \/\/ temporary value$/;"	m	class:simlib3::Integrator3D::special_input	access:private
simlib3::Integrator3D::special_input::count	simlib3D.h	/^    int count;                  \/\/ # of evaluations$/;"	m	class:simlib3::Integrator3D::special_input	access:private
simlib3::Integrator3D::special_input::in	simlib3D.h	/^    Input3D in;                 \/\/ 3D input$/;"	m	class:simlib3::Integrator3D::special_input	access:private
simlib3::Integrator3D::special_input::special_input	simlib3D.h	/^    special_input(Input3D i) : a(0,0,0), in(i), count(0) {}$/;"	f	class:simlib3::Integrator3D::special_input	access:public	signature:(Input3D i)
simlib3::Integrator::CtrInit	intg.cc	/^void Integrator::CtrInit() {$/;"	f	class:simlib3::Integrator	signature:()
simlib3::Integrator::CtrInit	simlib.h	/^  void CtrInit();$/;"	p	class:simlib3::Integrator	access:protected	signature:()
simlib3::Integrator::Eval	intg.cc	/^void Integrator::Eval()$/;"	f	class:simlib3::Integrator	signature:()
simlib3::Integrator::Eval	simlib.h	/^  void Eval();                         \/\/ integrator input evaluation$/;"	p	class:simlib3::Integrator	access:public	signature:()
simlib3::Integrator::GetDiff	simlib.h	/^  double GetDiff(void) { return dd; }$/;"	f	class:simlib3::Integrator	access:public	signature:(void)
simlib3::Integrator::GetOldDiff	simlib.h	/^  double GetOldDiff(void) { return ddl; }$/;"	f	class:simlib3::Integrator	access:public	signature:(void)
simlib3::Integrator::GetOldState	simlib.h	/^  double GetOldState(void) { return ssl; }$/;"	f	class:simlib3::Integrator	access:public	signature:(void)
simlib3::Integrator::GetState	simlib.h	/^  double GetState(void) { return ss; }$/;"	f	class:simlib3::Integrator	access:public	signature:(void)
simlib3::Integrator::Init	intg.cc	/^void Integrator::Init(double initvalue) {$/;"	f	class:simlib3::Integrator	signature:(double initvalue)
simlib3::Integrator::Init	simlib.h	/^  void Init() { Init(initval); }       \/\/!< use preset initial value$/;"	f	class:simlib3::Integrator	access:public	signature:()
simlib3::Integrator::Init	simlib.h	/^  void Init(double initvalue);         \/\/ set value$/;"	p	class:simlib3::Integrator	access:public	signature:(double initvalue)
simlib3::Integrator::InputValue	simlib.h	/^  double InputValue() { return input.Value(); } \/\/!< current input value$/;"	f	class:simlib3::Integrator	access:public	signature:()
simlib3::Integrator::Integrator	intg.cc	/^Integrator::Integrator() : input(SIMLIB_Integrator_0input)$/;"	f	class:simlib3::Integrator	signature:()
simlib3::Integrator::Integrator	intg.cc	/^Integrator::Integrator(Input i, double initvalue) : input(i)$/;"	f	class:simlib3::Integrator	signature:(Input i, double initvalue)
simlib3::Integrator::Integrator	intg.cc	/^Integrator::Integrator(Integrator &i, double initvalue) :$/;"	f	class:simlib3::Integrator	signature:(Integrator &i, double initvalue)
simlib3::Integrator::Integrator	simlib.h	/^  Integrator();                        \/\/ implicit CTR (input = 0)$/;"	p	class:simlib3::Integrator	access:public	signature:()
simlib3::Integrator::Integrator	simlib.h	/^  Integrator(Input i, double initvalue=0);$/;"	p	class:simlib3::Integrator	access:public	signature:(Input i, double initvalue=0)
simlib3::Integrator::Integrator	simlib.h	/^  Integrator(Integrator &i, double initvalue=0); \/\/ copy-ctr$/;"	p	class:simlib3::Integrator	access:public	signature:(Integrator &i, double initvalue=0)
simlib3::Integrator::Name	intg.cc	/^const char *Integrator::Name() const$/;"	f	class:simlib3::Integrator	signature:() const
simlib3::Integrator::Name	simlib.h	/^  virtual const char *Name() const;$/;"	p	class:simlib3::Integrator	access:public	signature:() const
simlib3::Integrator::Restore	simlib.h	/^  void Restore(void) { dd=ddl; ss=ssl; }  \/\/ restore saved status$/;"	f	class:simlib3::Integrator	access:public	signature:(void)
simlib3::Integrator::Save	simlib.h	/^  void Save(void) { ddl=dd; ssl=ss; }     \/\/ save status$/;"	f	class:simlib3::Integrator	access:public	signature:(void)
simlib3::Integrator::Set	intg.cc	/^void Integrator::Set(double value)$/;"	f	class:simlib3::Integrator	signature:(double value)
simlib3::Integrator::Set	simlib.h	/^  void Set(double value);              \/\/ set integrator state value$/;"	p	class:simlib3::Integrator	access:public	signature:(double value)
simlib3::Integrator::SetDiff	simlib.h	/^  void SetDiff(double d) { dd=d; }$/;"	f	class:simlib3::Integrator	access:public	signature:(double d)
simlib3::Integrator::SetInput	simlib.h	/^  Input SetInput(Input inp) { return input.Set(inp); }$/;"	f	class:simlib3::Integrator	access:public	signature:(Input inp)
simlib3::Integrator::SetOldDiff	simlib.h	/^  void SetOldDiff(double d) { ddl=d; }$/;"	f	class:simlib3::Integrator	access:public	signature:(double d)
simlib3::Integrator::SetOldState	simlib.h	/^  void SetOldState(double s) { ssl=s; }$/;"	f	class:simlib3::Integrator	access:public	signature:(double s)
simlib3::Integrator::SetState	simlib.h	/^  void SetState(double s) { ss=s; }$/;"	f	class:simlib3::Integrator	access:public	signature:(double s)
simlib3::Integrator::Value	intg.cc	/^double Integrator::Value()$/;"	f	class:simlib3::Integrator	signature:()
simlib3::Integrator::Value	simlib.h	/^  double Value();                      \/\/!< the state of integrator$/;"	p	class:simlib3::Integrator	access:public	signature:()
simlib3::Integrator::dd	simlib.h	/^  double dd;                           \/\/ input value: y'=f(t,y)$/;"	m	class:simlib3::Integrator	access:private
simlib3::Integrator::ddl	simlib.h	/^  double ddl;                          \/\/ the same from previous step$/;"	m	class:simlib3::Integrator	access:private
simlib3::Integrator::initval	simlib.h	/^  double initval;                      \/\/!< initial value: y(t0)$/;"	m	class:simlib3::Integrator	access:protected
simlib3::Integrator::input	simlib.h	/^  Input input;                         \/\/!< input expression: f(t,y)$/;"	m	class:simlib3::Integrator	access:protected
simlib3::Integrator::it_list	simlib.h	/^  IntegratorContainer::iterator it_list; \/\/!< position in list of integrators$/;"	m	class:simlib3::Integrator	access:protected
simlib3::Integrator::operator =	simlib.h	/^  Integrator &operator= (const Integrator &x); \/\/ disable assignment$/;"	p	class:simlib3::Integrator	access:private	signature:(const Integrator &x)
simlib3::Integrator::operator =	simlib.h	/^  Integrator &operator= (double x) { Set(x); return *this; }$/;"	f	class:simlib3::Integrator	access:public	signature:(double x)
simlib3::Integrator::ss	simlib.h	/^  double ss;                           \/\/ status: y = S f(t,y) dt$/;"	m	class:simlib3::Integrator	access:private
simlib3::Integrator::ssl	simlib.h	/^  double ssl;                          \/\/ the same from previous step$/;"	m	class:simlib3::Integrator	access:private
simlib3::Integrator::~Integrator	intg.cc	/^Integrator::~Integrator()$/;"	f	class:simlib3::Integrator	signature:()
simlib3::Integrator::~Integrator	simlib.h	/^  ~Integrator();$/;"	p	class:simlib3::Integrator	access:public	signature:()
simlib3::IntegratorContainer	simlib.h	/^class IntegratorContainer {$/;"	c	namespace:simlib3
simlib3::IntegratorContainer::Begin	simlib.h	/^  static iterator Begin(void) {$/;"	f	class:simlib3::IntegratorContainer	access:public	signature:(void)
simlib3::IntegratorContainer::End	simlib.h	/^  static iterator End(void) {$/;"	f	class:simlib3::IntegratorContainer	access:public	signature:(void)
simlib3::IntegratorContainer::Erase	intg.cc	/^void IntegratorContainer::Erase(IntegratorContainer::iterator it)$/;"	f	class:simlib3::IntegratorContainer	signature:(IntegratorContainer::iterator it)
simlib3::IntegratorContainer::Erase	simlib.h	/^  static void Erase(iterator it);  \/\/ exclude element$/;"	p	class:simlib3::IntegratorContainer	access:public	signature:(iterator it)
simlib3::IntegratorContainer::EvaluateAll	intg.cc	/^void IntegratorContainer::EvaluateAll()$/;"	f	class:simlib3::IntegratorContainer	signature:()
simlib3::IntegratorContainer::EvaluateAll	simlib.h	/^  static void EvaluateAll();       \/\/ evaluate all integrators$/;"	p	class:simlib3::IntegratorContainer	access:public	signature:()
simlib3::IntegratorContainer::InitAll	intg.cc	/^void IntegratorContainer::InitAll()$/;"	f	class:simlib3::IntegratorContainer	signature:()
simlib3::IntegratorContainer::InitAll	simlib.h	/^  static void InitAll();           \/\/ initialize all$/;"	p	class:simlib3::IntegratorContainer	access:public	signature:()
simlib3::IntegratorContainer::Insert	intg.cc	/^IntegratorContainer::iterator IntegratorContainer::Insert(Integrator* ptr)$/;"	f	class:simlib3::IntegratorContainer	signature:(Integrator* ptr)
simlib3::IntegratorContainer::Insert	simlib.h	/^  static iterator Insert(Integrator* ptr);  \/\/ insert element into container$/;"	p	class:simlib3::IntegratorContainer	access:public	signature:(Integrator* ptr)
simlib3::IntegratorContainer::Instance	intg.cc	/^std::list<Integrator*>* IntegratorContainer::Instance(void)$/;"	f	class:simlib3::IntegratorContainer	signature:(void)
simlib3::IntegratorContainer::Instance	simlib.h	/^  static std::list<Integrator*> * Instance(void);  \/\/ return list (& create)$/;"	p	class:simlib3::IntegratorContainer	access:private	signature:(void)
simlib3::IntegratorContainer::IntegratorContainer	simlib.h	/^  IntegratorContainer();  \/\/ forbid constructor$/;"	p	class:simlib3::IntegratorContainer	access:private	signature:()
simlib3::IntegratorContainer::ListPtr	intg.cc	/^std::list<Integrator*>* IntegratorContainer::ListPtr=NULL;$/;"	m	class:simlib3::IntegratorContainer	file:
simlib3::IntegratorContainer::ListPtr	simlib.h	/^  static std::list<Integrator*> * ListPtr;  \/\/ list of integrators$/;"	m	class:simlib3::IntegratorContainer	access:private
simlib3::IntegratorContainer::LtoN	intg.cc	/^void IntegratorContainer::LtoN()$/;"	f	class:simlib3::IntegratorContainer	signature:()
simlib3::IntegratorContainer::LtoN	simlib.h	/^  static void LtoN();              \/\/ last -> now$/;"	p	class:simlib3::IntegratorContainer	access:public	signature:()
simlib3::IntegratorContainer::NtoL	intg.cc	/^void IntegratorContainer::NtoL()$/;"	f	class:simlib3::IntegratorContainer	signature:()
simlib3::IntegratorContainer::NtoL	simlib.h	/^  static void NtoL();              \/\/ now -> last$/;"	p	class:simlib3::IntegratorContainer	access:public	signature:()
simlib3::IntegratorContainer::Size	simlib.h	/^  static size_t Size(void) {$/;"	f	class:simlib3::IntegratorContainer	access:public	signature:(void)
simlib3::IntegratorContainer::isAny	simlib.h	/^  static bool isAny(void) {$/;"	f	class:simlib3::IntegratorContainer	access:public	signature:(void)
simlib3::IntegratorContainer::iterator	simlib.h	/^  typedef std::list<Integrator*>::iterator iterator;$/;"	t	class:simlib3::IntegratorContainer	access:public
simlib3::Iterations	simlib.h	/^class Iterations : public AlgLoop {$/;"	c	namespace:simlib3	inherits:AlgLoop
simlib3::Iterations::Iterations	simlib.h	/^  Iterations(Input i, double eps, unsigned long max_it,$/;"	f	class:simlib3::Iterations	access:public	signature:(Input i, double eps, unsigned long max_it, double t_min, double t_max, double t0)
simlib3::Iterations::Value	algloop.cc	/^double Iterations::Value()$/;"	f	class:simlib3::Iterations	signature:()
simlib3::Iterations::Value	simlib.h	/^  virtual double Value(); \/\/ returned value$/;"	p	class:simlib3::Iterations	access:public	signature:()
simlib3::LIST_MAX	calendar.cc	/^const unsigned LIST_MAX   = 512; \/\/ TODO:tune parameter: 64-1024$/;"	m	namespace:simlib3	file:
simlib3::LIST_MIN	calendar.cc	/^const unsigned LIST_MIN   = LIST_MAX\/2; \/\/ TODO:tune parameter$/;"	m	namespace:simlib3	file:
simlib3::LOWEST_PRIORITY	simlib.h	/^  LOWEST_PRIORITY  = -127,$/;"	e	enum:simlib3::__anon1
simlib3::Lim	simlib.h	/^class Lim : public aContiBlock1 {$/;"	c	namespace:simlib3	inherits:aContiBlock1
simlib3::Lim::Lim	simlib.h	/^  Lim(Input in, double l, double h, double tga=1.0);$/;"	p	class:simlib3::Lim	access:public	signature:(Input in, double l, double h, double tga=1.0)
simlib3::Lim::Lim	stdblock.cc	/^Lim::Lim(Input in, double l, double h, double tga)$/;"	f	class:simlib3::Lim	signature:(Input in, double l, double h, double tga)
simlib3::Lim::Name	simlib.h	/^  virtual const char *Name() const;$/;"	p	class:simlib3::Lim	access:public	signature:() const
simlib3::Lim::Name	stdblock.cc	/^const char *Lim::Name() const$/;"	f	class:simlib3::Lim	signature:() const
simlib3::Lim::Value	simlib.h	/^  virtual double Value();         \/\/ returned value$/;"	p	class:simlib3::Lim	access:public	signature:()
simlib3::Lim::Value	stdblock.cc	/^double Lim::Value()$/;"	f	class:simlib3::Lim	signature:()
simlib3::Lim::_Eval	simlib.h	/^  virtual void _Eval();           \/\/ evaluation with loop check$/;"	p	class:simlib3::Lim	access:public	signature:()
simlib3::Lim::_Eval	stdblock.cc	/^void Lim::_Eval()$/;"	f	class:simlib3::Lim	signature:()
simlib3::Lim::high	simlib.h	/^  double low, high;               \/\/ limits$/;"	m	class:simlib3::Lim	access:protected
simlib3::Lim::low	simlib.h	/^  double low, high;               \/\/ limits$/;"	m	class:simlib3::Lim	access:protected
simlib3::Lim::tgalpha	simlib.h	/^  double tgalpha;                 \/\/$/;"	m	class:simlib3::Lim	access:protected
simlib3::Limitation	simlib.h	/^typedef Lim Limitation;$/;"	t	namespace:simlib3
simlib3::Link	simlib.h	/^class Link : public SimObject {$/;"	c	namespace:simlib3	inherits:SimObject
simlib3::Link::Into	link.cc	/^void Link::Into(List *l)$/;"	f	class:simlib3::Link	signature:(List *l)
simlib3::Link::Into	simlib.h	/^  virtual void Into(List *l);          \/\/!< insert last$/;"	p	class:simlib3::Link	access:public	signature:(List *l)
simlib3::Link::Link	link.cc	/^Link::Link() :$/;"	f	class:simlib3::Link	signature:()
simlib3::Link::Link	link.cc	/^Link::Link(Link *p, Link *s, List *h) :$/;"	f	class:simlib3::Link	signature:(Link *p, Link *s, List *h)
simlib3::Link::Link	simlib.h	/^  Link();$/;"	p	class:simlib3::Link	access:public	signature:()
simlib3::Link::Link	simlib.h	/^  Link(Link *p, Link *s, List *h);$/;"	p	class:simlib3::Link	access:protected	signature:(Link *p, Link *s, List *h)
simlib3::Link::Link	simlib.h	/^  Link(Link&);                         \/\/ disable operation$/;"	p	class:simlib3::Link	access:private	signature:(Link&)
simlib3::Link::Out	link.cc	/^void Link::Out()$/;"	f	class:simlib3::Link	signature:()
simlib3::Link::Out	simlib.h	/^  virtual void Out();                  \/\/!< remove from list$/;"	p	class:simlib3::Link	access:public	signature:()
simlib3::Link::Where	simlib.h	/^  List *Where() { return head; }       \/\/!< where is linked$/;"	f	class:simlib3::Link	access:public	signature:()
simlib3::Link::head	simlib.h	/^  List *head;                          \/\/!< pointer to List (if any)$/;"	m	class:simlib3::Link	access:private
simlib3::Link::isInQueue	simlib.h	/^  virtual bool isInQueue() { return Where()!=NULL; } \/\/!< present in queue$/;"	f	class:simlib3::Link	access:public	signature:()
simlib3::Link::operator =	simlib.h	/^  void operator= (Link&);              \/\/ disable operation$/;"	p	class:simlib3::Link	access:private	signature:(Link&)
simlib3::Link::pred	simlib.h	/^  Link *pred;                          \/\/!< previous object in List$/;"	m	class:simlib3::Link	access:private
simlib3::Link::succ	simlib.h	/^  Link *succ;                          \/\/!< next object in List$/;"	m	class:simlib3::Link	access:private
simlib3::Link::~Link	link.cc	/^Link::~Link() {$/;"	f	class:simlib3::Link	signature:()
simlib3::Link::~Link	simlib.h	/^  virtual ~Link();$/;"	p	class:simlib3::Link	access:public	signature:()
simlib3::List	simlib.h	/^class List : public Link { \/\/ circular list of Link items$/;"	c	namespace:simlib3	inherits:Link
simlib3::List::Get	list.cc	/^Link *List::Get(iterator pos)$/;"	f	class:simlib3::List	signature:(iterator pos)
simlib3::List::Get	simlib.h	/^    virtual Link *Get(iterator pos);     \/\/!< remove at position$/;"	p	class:simlib3::List	access:public	signature:(iterator pos)
simlib3::List::GetFirst	list.cc	/^Link *List::GetFirst()$/;"	f	class:simlib3::List	signature:()
simlib3::List::GetFirst	simlib.h	/^    Link *GetFirst();                    \/\/!< remove first$/;"	p	class:simlib3::List	access:public	signature:()
simlib3::List::GetLast	list.cc	/^Link *List::GetLast()$/;"	f	class:simlib3::List	signature:()
simlib3::List::GetLast	simlib.h	/^    Link *GetLast();                     \/\/!< remove last$/;"	p	class:simlib3::List	access:public	signature:()
simlib3::List::InsFirst	list.cc	/^void List::InsFirst(Link *ent)$/;"	f	class:simlib3::List	signature:(Link *ent)
simlib3::List::InsFirst	simlib.h	/^    void InsFirst(Link *e);              \/\/ insert operation$/;"	p	class:simlib3::List	access:public	signature:(Link *e)
simlib3::List::InsLast	list.cc	/^void List::InsLast(Link *ent)$/;"	f	class:simlib3::List	signature:(Link *ent)
simlib3::List::InsLast	simlib.h	/^    void InsLast (Link *e);$/;"	p	class:simlib3::List	access:public	signature:(Link *e)
simlib3::List::List	list.cc	/^List::List() : Link(this,this,this), n(0)$/;"	f	class:simlib3::List	signature:()
simlib3::List::List	list.cc	/^List::List(const char *name) : Link(this,this,this), n(0)$/;"	f	class:simlib3::List	signature:(const char *name)
simlib3::List::List	simlib.h	/^    List();$/;"	p	class:simlib3::List	access:public	signature:()
simlib3::List::List	simlib.h	/^    List(List&);                         \/\/ disable$/;"	p	class:simlib3::List	access:private	signature:(List&)
simlib3::List::List	simlib.h	/^    List(const char *_name);$/;"	p	class:simlib3::List	access:public	signature:(const char *_name)
simlib3::List::Output	output1.cc	/^void List::Output() const$/;"	f	class:simlib3::List	signature:() const
simlib3::List::Output	simlib.h	/^    virtual void Output() const;          \/\/!< print object to default output$/;"	p	class:simlib3::List	access:public	signature:() const
simlib3::List::PostIns	list.cc	/^void List::PostIns(Link *ent, iterator pos)$/;"	f	class:simlib3::List	signature:(Link *ent, iterator pos)
simlib3::List::PostIns	simlib.h	/^    void PostIns(Link *e, iterator pos); \/\/$/;"	p	class:simlib3::List	access:public	signature:(Link *e, iterator pos)
simlib3::List::PredIns	list.cc	/^void List::PredIns(Link *ent, iterator pos)$/;"	f	class:simlib3::List	signature:(Link *ent, iterator pos)
simlib3::List::PredIns	simlib.h	/^    void PredIns(Link *e, iterator pos); \/\/$/;"	p	class:simlib3::List	access:public	signature:(Link *e, iterator pos)
simlib3::List::back	simlib.h	/^    Link *back()      { return empty() ? 0 : Link::pred; }$/;"	f	class:simlib3::List	access:public	signature:()
simlib3::List::begin	simlib.h	/^    iterator begin()  { return Link::succ; }$/;"	f	class:simlib3::List	access:public	signature:()
simlib3::List::clear	list.cc	/^void List::clear()$/;"	f	class:simlib3::List	signature:()
simlib3::List::clear	simlib.h	/^    void clear();$/;"	p	class:simlib3::List	access:public	signature:()
simlib3::List::empty	simlib.h	/^    bool empty()      { return Link::succ == this; }$/;"	f	class:simlib3::List	access:public	signature:()
simlib3::List::end	simlib.h	/^    iterator end()    { return this; }$/;"	f	class:simlib3::List	access:public	signature:()
simlib3::List::front	simlib.h	/^    Link *front()     { return empty() ? 0 : Link::succ; }$/;"	f	class:simlib3::List	access:public	signature:()
simlib3::List::iterator	simlib.h	/^    class iterator {$/;"	c	class:simlib3::List	access:protected
simlib3::List::iterator::iterator	simlib.h	/^            iterator(Link *pos) : p(pos) {}$/;"	f	class:simlib3::List::iterator	access:public	signature:(Link *pos)
simlib3::List::iterator::iterator	simlib.h	/^            iterator(const iterator&x): p(x.p) {}$/;"	f	class:simlib3::List::iterator	access:public	signature:(const iterator&x)
simlib3::List::iterator::operator !=	simlib.h	/^            bool operator != (iterator q) const { return p!=q.p; }$/;"	f	class:simlib3::List::iterator	access:public	signature:(iterator q) const
simlib3::List::iterator::operator *	simlib.h	/^            Link * operator*() const { return p; }$/;"	f	class:simlib3::List::iterator	access:public	signature:() const
simlib3::List::iterator::operator ++	simlib.h	/^            iterator &operator++() { p = List::next(p); return *this; }$/;"	f	class:simlib3::List::iterator	access:public	signature:()
simlib3::List::iterator::operator ++	simlib.h	/^            iterator operator++(int) {$/;"	f	class:simlib3::List::iterator	access:public	signature:(int)
simlib3::List::iterator::operator --	simlib.h	/^            iterator &operator--() { p = List::previous(p); return *this; }$/;"	f	class:simlib3::List::iterator	access:public	signature:()
simlib3::List::iterator::operator --	simlib.h	/^            iterator operator--(int) {$/;"	f	class:simlib3::List::iterator	access:public	signature:(int)
simlib3::List::iterator::operator =	simlib.h	/^            iterator &operator=(const iterator&x) { p = x.p; return *this; }$/;"	f	class:simlib3::List::iterator	access:public	signature:(const iterator&x)
simlib3::List::iterator::operator ==	simlib.h	/^            bool operator == (iterator q) const { return p==q.p; }$/;"	f	class:simlib3::List::iterator	access:public	signature:(iterator q) const
simlib3::List::iterator::p	simlib.h	/^            Link *p; \/\/ position in List$/;"	m	class:simlib3::List::iterator	access:private
simlib3::List::n	simlib.h	/^    unsigned n;                          \/\/ number of objects in list$/;"	m	class:simlib3::List	access:private
simlib3::List::next	simlib.h	/^    static Link *next(Link*p)           { return p->succ; }$/;"	f	class:simlib3::List	access:private	signature:(Link*p)
simlib3::List::operator =	simlib.h	/^    void operator= (List&);              \/\/ disable$/;"	p	class:simlib3::List	access:private	signature:(List&)
simlib3::List::previous	simlib.h	/^    static Link *previous(Link*p)       { return p->pred; }$/;"	f	class:simlib3::List	access:private	signature:(Link*p)
simlib3::List::size	simlib.h	/^    unsigned size() const  { return n; }$/;"	f	class:simlib3::List	access:public	signature:() const
simlib3::List::~List	list.cc	/^List::~List() {$/;"	f	class:simlib3::List	signature:()
simlib3::List::~List	simlib.h	/^    ~List();$/;"	p	class:simlib3::List	access:public	signature:()
simlib3::Ln	fun.cc	/^Input Ln(Input x)               { return new Function1(x, log); }$/;"	f	namespace:simlib3	signature:(Input x)
simlib3::Ln	simlib.h	/^Input Ln(Input x);              \/\/ ln(x)      natural logarithm$/;"	p	namespace:simlib3	signature:(Input x)
simlib3::Log10	fun.cc	/^Input Log10(Input x)            { return new Function1(x, log10); }$/;"	f	namespace:simlib3	signature:(Input x)
simlib3::Log10	simlib.h	/^Input Log10(Input x);           \/\/ log10(x)$/;"	p	namespace:simlib3	signature:(Input x)
simlib3::Logar	random2.cc	/^double Logar(double mi, double delta)$/;"	f	namespace:simlib3	signature:(double mi, double delta)
simlib3::Logar	simlib.h	/^double Logar(double mi, double delta);$/;"	p	namespace:simlib3	signature:(double mi, double delta)
simlib3::MAXHISTOCOUNT	histo.cc	/^const unsigned MAXHISTOCOUNT = 10000;$/;"	m	namespace:simlib3	file:
simlib3::MAXLONGINT	random1.cc	/^const myint32 MAXLONGINT = 0x7FFFFFFFUL;$/;"	m	namespace:simlib3	file:
simlib3::MAX_ATEXIT	atexit.cc	/^static const int MAX_ATEXIT = 10; \/\/ for internal use it is enough$/;"	m	namespace:simlib3	file:
simlib3::MINBUCKETS	calendar.cc	/^const unsigned MINBUCKETS = LIST_MAX>4?LIST_MAX:4; \/\/ should be power of 2 and >=4$/;"	m	namespace:simlib3	file:
simlib3::MULCONST	random1.cc	/^const myint32 MULCONST   = 1220703125L;$/;"	m	namespace:simlib3	file:
simlib3::MUL_PAR	calendar.cc	/^const double MUL_PAR      = 1.0; \/\/ TODO:tune parameter: 1.0--5.0$/;"	m	namespace:simlib3	file:
simlib3::Max	fun.cc	/^Input Max(Input x, Input y)     { return new Function2(x, y, max); }$/;"	f	namespace:simlib3	signature:(Input x, Input y)
simlib3::Max	simlib.h	/^Input Max(Input x, Input y);    \/\/ maximum$/;"	p	namespace:simlib3	signature:(Input x, Input y)
simlib3::MaxStep	intg.cc	/^const double &MaxStep=SIMLIB_MaxStep;        \/\/!< maximal integration step$/;"	m	namespace:simlib3	file:
simlib3::Min	fun.cc	/^Input Min(Input x, Input y)     { return new Function2(x, y, min); }$/;"	f	namespace:simlib3	signature:(Input x, Input y)
simlib3::Min	simlib.h	/^Input Min(Input x, Input y);    \/\/ minimum$/;"	p	namespace:simlib3	signature:(Input x, Input y)
simlib3::MinStep	intg.cc	/^const double &MinStep=SIMLIB_MinStep;        \/\/!< minimal integration step$/;"	m	namespace:simlib3	file:
simlib3::MultiStepMethod	simlib.h	/^class MultiStepMethod : public IntegrationMethod {$/;"	c	namespace:simlib3	inherits:IntegrationMethod
simlib3::MultiStepMethod::GetStarter	numint.cc	/^const char* MultiStepMethod::GetStarter(const char* name)$/;"	f	class:simlib3::MultiStepMethod	signature:(const char* name)
simlib3::MultiStepMethod::GetStarter	simlib.h	/^  static const char* GetStarter(const char* name);$/;"	p	class:simlib3::MultiStepMethod	access:public	signature:(const char* name)
simlib3::MultiStepMethod::Integrate	simlib.h	/^  virtual void Integrate(void) = 0;  \/\/ the method does integration$/;"	p	class:simlib3::MultiStepMethod	access:public	signature:(void)
simlib3::MultiStepMethod::IsSingleStep	simlib.h	/^  virtual bool IsSingleStep(void) {  \/\/ it's a multi-step method$/;"	f	class:simlib3::MultiStepMethod	access:public	signature:(void)
simlib3::MultiStepMethod::MultiStepMethod	numint.cc	/^MultiStepMethod::MultiStepMethod(const char* name, const char* slave_name) :$/;"	f	class:simlib3::MultiStepMethod	signature:(const char* name, const char* slave_name)
simlib3::MultiStepMethod::MultiStepMethod	simlib.h	/^    MultiStepMethod(const MultiStepMethod&); \/\/ ## disable$/;"	p	class:simlib3::MultiStepMethod	access:private	signature:(const MultiStepMethod&)
simlib3::MultiStepMethod::MultiStepMethod	simlib.h	/^  MultiStepMethod(const char* name, const char* slave_name);$/;"	p	class:simlib3::MultiStepMethod	access:public	signature:(const char* name, const char* slave_name)
simlib3::MultiStepMethod::PrepareStep	numint.cc	/^bool MultiStepMethod::PrepareStep(void)$/;"	f	class:simlib3::MultiStepMethod	signature:(void)
simlib3::MultiStepMethod::PrepareStep	simlib.h	/^  virtual bool PrepareStep(void);  \/\/ prepare the object for the step$/;"	p	class:simlib3::MultiStepMethod	access:public	signature:(void)
simlib3::MultiStepMethod::SetStarter	numint.cc	/^void MultiStepMethod::SetStarter(const char* name, const char* slave_name)$/;"	f	class:simlib3::MultiStepMethod	signature:(const char* name, const char* slave_name)
simlib3::MultiStepMethod::SetStarter	numint.cc	/^void MultiStepMethod::SetStarter(const char* slave_name)$/;"	f	class:simlib3::MultiStepMethod	signature:(const char* slave_name)
simlib3::MultiStepMethod::SetStarter	simlib.h	/^  static void SetStarter(const char* name, const char* slave_name);$/;"	p	class:simlib3::MultiStepMethod	access:public	signature:(const char* name, const char* slave_name)
simlib3::MultiStepMethod::SetStarter	simlib.h	/^  virtual void SetStarter(const char* slave_name);$/;"	p	class:simlib3::MultiStepMethod	access:public	signature:(const char* slave_name)
simlib3::MultiStepMethod::SlaveName	simlib.h	/^  char* SlaveName;  \/\/ the name of the method used for starting$/;"	m	class:simlib3::MultiStepMethod	access:private
simlib3::MultiStepMethod::SlavePtr	numint.cc	/^SingleStepMethod* MultiStepMethod::SlavePtr(void)$/;"	f	class:simlib3::MultiStepMethod	signature:(void)
simlib3::MultiStepMethod::SlavePtr	simlib.h	/^  SingleStepMethod* SlavePtr(void);  \/\/ return pointer to the starting method$/;"	p	class:simlib3::MultiStepMethod	access:protected	signature:(void)
simlib3::MultiStepMethod::Slave_Ptr	simlib.h	/^  SingleStepMethod* Slave_Ptr;  \/\/ pointer to the method used for starting$/;"	m	class:simlib3::MultiStepMethod	access:private
simlib3::MultiStepMethod::TurnOff	numint.cc	/^void MultiStepMethod::TurnOff(void)$/;"	f	class:simlib3::MultiStepMethod	signature:(void)
simlib3::MultiStepMethod::TurnOff	simlib.h	/^  virtual void TurnOff(void);  \/\/ turn off method & its slave$/;"	p	class:simlib3::MultiStepMethod	access:public	signature:(void)
simlib3::MultiStepMethod::operator =	simlib.h	/^    MultiStepMethod&operator=(const MultiStepMethod&); \/\/ ## disable$/;"	p	class:simlib3::MultiStepMethod	access:private	signature:(const MultiStepMethod&)
simlib3::MultiStepMethod::~MultiStepMethod	numint.cc	/^MultiStepMethod::~MultiStepMethod()$/;"	f	class:simlib3::MultiStepMethod	signature:()
simlib3::MultiStepMethod::~MultiStepMethod	simlib.h	/^  ~MultiStepMethod();  \/\/ destructor frees dynamic data$/;"	p	class:simlib3::MultiStepMethod	access:public	signature:()
simlib3::NegBin	random2.cc	/^int NegBin(double q, int k)$/;"	f	namespace:simlib3	signature:(double q, int k)
simlib3::NegBin	simlib.h	/^int    NegBin(double q, int k);$/;"	p	namespace:simlib3	signature:(double q, int k)
simlib3::NegBinM	random2.cc	/^int NegBinM(double p, int m)$/;"	f	namespace:simlib3	signature:(double p, int m)
simlib3::NegBinM	simlib.h	/^int    NegBinM(double p,int m);$/;"	p	namespace:simlib3	signature:(double p,int m)
simlib3::Newton	simlib.h	/^class Newton : public AlgLoop {$/;"	c	namespace:simlib3	inherits:AlgLoop
simlib3::Newton::Newton	simlib.h	/^  Newton(Input i, double eps, unsigned long max_it,$/;"	f	class:simlib3::Newton	access:public	signature:(Input i, double eps, unsigned long max_it, double t_min, double t_max, double t0)
simlib3::Newton::Value	algloop.cc	/^double Newton::Value()$/;"	f	class:simlib3::Newton	signature:()
simlib3::Newton::Value	simlib.h	/^  virtual double Value(); \/\/ returned value$/;"	p	class:simlib3::Newton	access:public	signature:()
simlib3::Newton::eps_root	simlib.h	/^  double eps_root; \/\/ root for force precision test$/;"	m	class:simlib3::Newton	access:private
simlib3::Newton::prev_root	simlib.h	/^  double prev_root; \/\/ root from previous iteration step$/;"	m	class:simlib3::Newton	access:private
simlib3::NextTime	run.cc	/^const double & NextTime  = SIMLIB_NextTime;     \/\/ next-event time$/;"	m	namespace:simlib3	file:
simlib3::Normal	random2.cc	/^double Normal(double mi, double sigma)$/;"	f	namespace:simlib3	signature:(double mi, double sigma)
simlib3::Normal	simlib.h	/^double Normal(double mi, double sigma);$/;"	p	namespace:simlib3	signature:(double mi, double sigma)
simlib3::OptStep	intg.cc	/^const double &OptStep=SIMLIB_OptStep;        \/\/!< optimal integration step$/;"	m	namespace:simlib3	file:
simlib3::Optimize_gradient	optimize.h	/^double Optimize_gradient(opt_function_t f, ParameterVector & p,$/;"	p	namespace:simlib3	signature:(opt_function_t f, ParameterVector & p, double MAXITER)
simlib3::Optimize_hooke	opt-hooke.cc	/^double Optimize_hooke(opt_function_t f, ParameterVector & parameter,$/;"	f	namespace:simlib3	signature:(opt_function_t f, ParameterVector & parameter, double rho, double epsilon, int itermax)
simlib3::Optimize_hooke	optimize.h	/^double Optimize_hooke(opt_function_t f, ParameterVector & p,$/;"	p	namespace:simlib3	signature:(opt_function_t f, ParameterVector & p, double rho, double epsilon, int itermax)
simlib3::Optimize_simann	opt-simann.cc	/^double Optimize_simann(double (*f) (const ParameterVector & p),$/;"	f	namespace:simlib3	signature:(double (*f) (const ParameterVector & p), ParameterVector & p, int MAXT)
simlib3::Optimize_simann	optimize.h	/^double Optimize_simann(opt_function_t f, ParameterVector & p, int MAXT);$/;"	p	namespace:simlib3	signature:(opt_function_t f, ParameterVector & p, int MAXT)
simlib3::OutFile	print.cc	/^} OutFile;$/;"	m	namespace:simlib3	typeref:class:simlib3::_FileWrap	file:
simlib3::P_Context	process.cc	/^static P_Context_t *volatile P_Context = 0;      \/\/ temporary - process state$/;"	m	namespace:simlib3	file:
simlib3::P_Context_t	process.cc	/^struct P_Context_t {$/;"	s	namespace:simlib3	file:
simlib3::P_Context_t::size	process.cc	/^    size_t size;        \/\/ size of following array (allocated on heap)$/;"	m	struct:simlib3::P_Context_t	file:	access:public
simlib3::P_Context_t::stack	process.cc	/^    char stack[1];      \/\/ stack contents saved$/;"	m	struct:simlib3::P_Context_t	file:	access:public
simlib3::P_Context_t::status	process.cc	/^    jmp_buf status;     \/\/ stored SP, IP, and other registers$/;"	m	struct:simlib3::P_Context_t	file:	access:public
simlib3::Param	optimize.h	/^class Param$/;"	c	namespace:simlib3
simlib3::Param::Max	optimize.h	/^    double Max() const { return max; }$/;"	f	class:simlib3::Param	access:public	signature:() const
simlib3::Param::Min	optimize.h	/^    double Min() const { return min; }$/;"	f	class:simlib3::Param	access:public	signature:() const
simlib3::Param::Name	optimize.h	/^    const char *Name() const { return name; }$/;"	f	class:simlib3::Param	access:public	signature:() const
simlib3::Param::Param	optimize.h	/^    Param (const char *n, double a, double b):$/;"	f	class:simlib3::Param	access:public	signature:(const char *n, double a, double b)
simlib3::Param::Param	optimize.h	/^    Param():$/;"	f	class:simlib3::Param	access:public	signature:()
simlib3::Param::Print	opt-param.cc	/^void Param::Print() const$/;"	f	class:simlib3::Param	signature:() const
simlib3::Param::Print	optimize.h	/^    void Print() const;$/;"	p	class:simlib3::Param	access:public	signature:() const
simlib3::Param::Range	optimize.h	/^    double Range() const { return max - min; }$/;"	f	class:simlib3::Param	access:public	signature:() const
simlib3::Param::Value	optimize.h	/^    double Value() const { return value; }$/;"	f	class:simlib3::Param	access:public	signature:() const
simlib3::Param::limit	optimize.h	/^    void limit(double &x)$/;"	f	class:simlib3::Param	access:private	signature:(double &x)
simlib3::Param::max	optimize.h	/^    double max;$/;"	m	class:simlib3::Param	access:private
simlib3::Param::min	optimize.h	/^    double min;$/;"	m	class:simlib3::Param	access:private
simlib3::Param::name	optimize.h	/^    const char *name;           \/\/ name of parameter  c-string$/;"	m	class:simlib3::Param	access:private
simlib3::Param::operator =	optimize.h	/^    Param & operator = (double x) {$/;"	f	class:simlib3::Param	access:public	signature:(double x)
simlib3::Param::operator double	optimize.h	/^    operator double () const { return value; }$/;"	f	class:simlib3::Param	access:public	signature:() const
simlib3::Param::value	optimize.h	/^    double value;$/;"	m	class:simlib3::Param	access:private
simlib3::Parameter	simlib.h	/^class Parameter : public aContiBlock {$/;"	c	namespace:simlib3	inherits:aContiBlock
simlib3::Parameter2D	simlib2D.h	/^class Parameter2D : public Variable2D {$/;"	c	namespace:simlib3	inherits:Variable2D
simlib3::Parameter2D::Parameter2D	simlib2D.h	/^  explicit Parameter2D(Value2D x=Value2D(0,0)) : Variable2D(x) {}$/;"	f	class:simlib3::Parameter2D	access:public	signature:(Value2D x=Value2D(0,0))
simlib3::Parameter2D::operator =	simlib2D.cc	/^Parameter2D &Parameter2D::operator= (const Value2D &x)    {$/;"	f	class:simlib3::Parameter2D	signature:(const Value2D &x)
simlib3::Parameter2D::operator =	simlib2D.h	/^  Parameter2D &operator= (const Value2D &x);$/;"	p	class:simlib3::Parameter2D	access:public	signature:(const Value2D &x)
simlib3::Parameter3D	simlib3D.h	/^class Parameter3D : public Variable3D {$/;"	c	namespace:simlib3	inherits:Variable3D
simlib3::Parameter3D::Parameter3D	simlib3D.h	/^  explicit Parameter3D(Value3D x=Value3D(0,0,0)) : Variable3D(x) {}$/;"	f	class:simlib3::Parameter3D	access:public	signature:(Value3D x=Value3D(0,0,0))
simlib3::Parameter3D::operator =	simlib3D.cc	/^Parameter3D &Parameter3D::operator= (const Value3D &x)    {$/;"	f	class:simlib3::Parameter3D	signature:(const Value3D &x)
simlib3::Parameter3D::operator =	simlib3D.h	/^  Parameter3D &operator= (const Value3D &x);$/;"	p	class:simlib3::Parameter3D	access:public	signature:(const Value3D &x)
simlib3::Parameter::Parameter	simlib.h	/^  Parameter(double x) : value(x) {}$/;"	f	class:simlib3::Parameter	access:public	signature:(double x)
simlib3::Parameter::Value	simlib.h	/^  virtual double Value ()         { return value; }$/;"	f	class:simlib3::Parameter	access:public	signature:()
simlib3::Parameter::operator =	simlib.h	/^  Parameter &operator= (double x) { value = x; return *this; }$/;"	f	class:simlib3::Parameter	access:public	signature:(double x)
simlib3::Parameter::value	simlib.h	/^  double value;$/;"	m	class:simlib3::Parameter	access:private
simlib3::ParameterVector	optimize.h	/^class ParameterVector$/;"	c	namespace:simlib3
simlib3::ParameterVector::ParameterVector	opt-param.cc	/^ParameterVector::ParameterVector(const ParameterVector & a):n(a.n),$/;"	f	class:simlib3::ParameterVector	signature:(const ParameterVector & a)
simlib3::ParameterVector::ParameterVector	opt-param.cc	/^ParameterVector::ParameterVector(int sz, Param * a):$/;"	f	class:simlib3::ParameterVector	signature:(int sz, Param * a)
simlib3::ParameterVector::ParameterVector	optimize.h	/^    ParameterVector(const ParameterVector & a);$/;"	p	class:simlib3::ParameterVector	access:public	signature:(const ParameterVector & a)
simlib3::ParameterVector::ParameterVector	optimize.h	/^    ParameterVector(int sz, Param * a); \/\/ initialize by array$/;"	p	class:simlib3::ParameterVector	access:public	signature:(int sz, Param * a)
simlib3::ParameterVector::Print	opt-param.cc	/^void ParameterVector::Print() const$/;"	f	class:simlib3::ParameterVector	signature:() const
simlib3::ParameterVector::Print	optimize.h	/^    void Print() const;$/;"	p	class:simlib3::ParameterVector	access:public	signature:() const
simlib3::ParameterVector::PrintValues	opt-param.cc	/^void ParameterVector::PrintValues() const$/;"	f	class:simlib3::ParameterVector	signature:() const
simlib3::ParameterVector::PrintValues	optimize.h	/^    void PrintValues() const;$/;"	p	class:simlib3::ParameterVector	access:public	signature:() const
simlib3::ParameterVector::n	optimize.h	/^    int n;$/;"	m	class:simlib3::ParameterVector	access:private
simlib3::ParameterVector::operator =	opt-param.cc	/^ParameterVector & ParameterVector::operator = (const ParameterVector & a) {$/;"	f	class:simlib3::ParameterVector	signature:(const ParameterVector & a)
simlib3::ParameterVector::operator =	optimize.h	/^    ParameterVector & operator = (const ParameterVector & a);$/;"	p	class:simlib3::ParameterVector	access:public	signature:(const ParameterVector & a)
simlib3::ParameterVector::operator ==	optimize.h	/^    friend bool operator == (const ParameterVector & p1,$/;"	p	class:simlib3::ParameterVector	access:friend	signature:(const ParameterVector & p1, const ParameterVector & p2)
simlib3::ParameterVector::operator []	optimize.h	/^    Param & operator[] (int i) { return p[i]; }$/;"	f	class:simlib3::ParameterVector	access:public	signature:(int i)
simlib3::ParameterVector::operator []	optimize.h	/^    Param & operator[](const char *name) {$/;"	f	class:simlib3::ParameterVector	access:public	signature:(const char *name)
simlib3::ParameterVector::operator []	optimize.h	/^    const Param & operator[] (int i) const { return p[i]; }$/;"	f	class:simlib3::ParameterVector	access:public	signature:(int i) const
simlib3::ParameterVector::p	optimize.h	/^    Param *p;$/;"	m	class:simlib3::ParameterVector	access:private
simlib3::ParameterVector::search	opt-param.cc	/^int ParameterVector::search(const char *name)$/;"	f	class:simlib3::ParameterVector	signature:(const char *name)
simlib3::ParameterVector::search	optimize.h	/^    int search(const char *name);$/;"	p	class:simlib3::ParameterVector	access:private	signature:(const char *name)
simlib3::ParameterVector::size	optimize.h	/^    int size() const { return n; }$/;"	f	class:simlib3::ParameterVector	access:public	signature:() const
simlib3::ParameterVector::~ParameterVector	opt-param.cc	/^ParameterVector::~ParameterVector()$/;"	f	class:simlib3::ParameterVector	signature:()
simlib3::ParameterVector::~ParameterVector	optimize.h	/^   ~ParameterVector();$/;"	p	class:simlib3::ParameterVector	access:public	signature:()
simlib3::Passivate	simlib.h	/^inline void Passivate(Entity *e) { e->Passivate(); }  \/\/!< passivate entity e$/;"	f	namespace:simlib3	signature:(Entity *e)
simlib3::Phase	run.cc	/^const SIMLIB_Phase_t & Phase = SIMLIB_Phase;    \/\/ read-only reference$/;"	m	namespace:simlib3	file:
simlib3::Poisson	random2.cc	/^int Poisson(double lambda)$/;"	f	namespace:simlib3	signature:(double lambda)
simlib3::Poisson	simlib.h	/^int    Poisson(double lambda);$/;"	p	namespace:simlib3	signature:(double lambda)
simlib3::Pow	fun.cc	/^Input Pow(Input x, Input y)     { return new Function2(x, y, pow); }$/;"	f	namespace:simlib3	signature:(Input x, Input y)
simlib3::Pow	simlib.h	/^Input Pow(Input x, Input y);    \/\/ pow(x,y)   x ** y$/;"	p	namespace:simlib3	signature:(Input x, Input y)
simlib3::Print	print.cc	/^int Print(const char *fmt, ...)$/;"	f	namespace:simlib3	signature:(const char *fmt, ...)
simlib3::Print	print.cc	/^int Print(const double x)$/;"	f	namespace:simlib3	signature:(const double x)
simlib3::Print	print.cc	/^int Print(const double x, const double y)$/;"	f	namespace:simlib3	signature:(const double x, const double y)
simlib3::Print	print.cc	/^int Print(const double x, const double y, const double z)$/;"	f	namespace:simlib3	signature:(const double x, const double y, const double z)
simlib3::Print	simlib.h	/^int  Print(const char *fmt, ...);$/;"	p	namespace:simlib3	signature:(const char *fmt, ...)
simlib3::Print	simlib.h	/^int  Print(const double x);$/;"	p	namespace:simlib3	signature:(const double x)
simlib3::Print	simlib.h	/^int  Print(const double x, const double y);$/;"	p	namespace:simlib3	signature:(const double x, const double y)
simlib3::Print	simlib.h	/^int  Print(const double x, const double y, const double z);$/;"	p	namespace:simlib3	signature:(const double x, const double y, const double z)
simlib3::Print	simlib2D.h	/^inline void Print(Value2D a) { a.Print(); }$/;"	f	namespace:simlib3	signature:(Value2D a)
simlib3::Print	simlib3D.h	/^inline void Print(Value3D a) { a.Print(); }$/;"	f	namespace:simlib3	signature:(Value3D a)
simlib3::Process	simlib.h	/^class Process : public Entity {$/;"	c	namespace:simlib3	inherits:Entity
simlib3::Process::Activate	process.cc	/^void Process::Activate(double t)$/;"	f	class:simlib3::Process	signature:(double t)
simlib3::Process::Activate	simlib.h	/^  virtual void Activate(double t);      \/\/!< activate at time t (schedule)$/;"	p	class:simlib3::Process	access:public	signature:(double t)
simlib3::Process::Behavior	simlib.h	/^  virtual void Behavior() = 0;          \/\/!< behavior description$/;"	p	class:simlib3::Process	access:public	signature:()
simlib3::Process::Enter	process.cc	/^void Process::Enter(Store & s, unsigned long cap)$/;"	f	class:simlib3::Process	signature:(Store & s, unsigned long cap)
simlib3::Process::Enter	simlib.h	/^  void Enter(Store &s, unsigned long ReqCap=1); \/\/!< acquire some capacity$/;"	p	class:simlib3::Process	access:public	signature:(Store &s, unsigned long ReqCap=1)
simlib3::Process::Interrupt	process.cc	/^void Process::Interrupt()$/;"	f	class:simlib3::Process	signature:()
simlib3::Process::Interrupt	simlib.h	/^  void Interrupt(); \/\/!< test of WaitUntil list, allow running others$/;"	p	class:simlib3::Process	access:public	signature:()
simlib3::Process::Into	process.cc	/^void Process::Into(Queue & q)$/;"	f	class:simlib3::Process	signature:(Queue & q)
simlib3::Process::Into	simlib.h	/^  virtual void Into(Queue &q);          \/\/!< insert process into queue$/;"	p	class:simlib3::Process	access:public	signature:(Queue &q)
simlib3::Process::Leave	process.cc	/^void Process::Leave(Store & s, unsigned long cap)$/;"	f	class:simlib3::Process	signature:(Store & s, unsigned long cap)
simlib3::Process::Leave	simlib.h	/^  void Leave(Store &s, unsigned long ReqCap=1); \/\/!< return some capacity$/;"	p	class:simlib3::Process	access:public	signature:(Store &s, unsigned long ReqCap=1)
simlib3::Process::Name	process.cc	/^const char *Process::Name() const$/;"	f	class:simlib3::Process	signature:() const
simlib3::Process::Name	simlib.h	/^  virtual const char *Name() const;     \/\/!< name of object$/;"	p	class:simlib3::Process	access:public	signature:() const
simlib3::Process::Output	output2.cc	/^void Process::Output() const$/;"	f	class:simlib3::Process	signature:() const
simlib3::Process::Output	simlib.h	/^  virtual void Output() const;          \/\/!< print object to default output$/;"	p	class:simlib3::Process	access:public	signature:() const
simlib3::Process::Passivate	process.cc	/^void Process::Passivate()$/;"	f	class:simlib3::Process	signature:()
simlib3::Process::Passivate	simlib.h	/^  virtual void Passivate();             \/\/!< process deactivation (sleep)$/;"	p	class:simlib3::Process	access:public	signature:()
simlib3::Process::Process	process.cc	/^Process::Process(Priority_t p) : Entity(p) {$/;"	f	class:simlib3::Process	signature:(Priority_t p)
simlib3::Process::Process	simlib.h	/^  Process(Priority_t p=DEFAULT_PRIORITY);$/;"	p	class:simlib3::Process	access:public	signature:(Priority_t p=DEFAULT_PRIORITY)
simlib3::Process::Process	simlib.h	/^  Process(const Process&);              \/\/ disable copying$/;"	p	class:simlib3::Process	access:private	signature:(const Process&)
simlib3::Process::ProcessStatus_t	simlib.h	/^  enum ProcessStatus_t {$/;"	g	class:simlib3::Process	access:private
simlib3::Process::Release	process.cc	/^void Process::Release(Facility & f)$/;"	f	class:simlib3::Process	signature:(Facility & f)
simlib3::Process::Release	simlib.h	/^  void Release(Facility &f);                        \/\/!< release facility$/;"	p	class:simlib3::Process	access:public	signature:(Facility &f)
simlib3::Process::Seize	process.cc	/^void Process::Seize(Facility & f, ServicePriority_t sp \/* = 0 *\/ )$/;"	f	class:simlib3::Process	signature:(Facility & f, ServicePriority_t sp )
simlib3::Process::Seize	simlib.h	/^  void Seize(Facility &f, ServicePriority_t sp=0);  \/\/!< seize facility$/;"	p	class:simlib3::Process	access:public	signature:(Facility &f, ServicePriority_t sp=0)
simlib3::Process::Terminate	process.cc	/^void Process::Terminate()$/;"	f	class:simlib3::Process	signature:()
simlib3::Process::Terminate	simlib.h	/^  virtual void Terminate();             \/\/!< kill process$/;"	p	class:simlib3::Process	access:public	signature:()
simlib3::Process::Wait	process.cc	/^void Process::Wait(double dtime)$/;"	f	class:simlib3::Process	signature:(double dtime)
simlib3::Process::Wait	simlib.h	/^  virtual void Wait(double dtime);      \/\/!< wait for dtime interval$/;"	p	class:simlib3::Process	access:public	signature:(double dtime)
simlib3::Process::_INTERRUPTED	simlib.h	/^      _PREPARED=1, _RUNNING, _INTERRUPTED, _TERMINATED$/;"	e	enum:simlib3::Process::ProcessStatus_t
simlib3::Process::_PREPARED	simlib.h	/^      _PREPARED=1, _RUNNING, _INTERRUPTED, _TERMINATED$/;"	e	enum:simlib3::Process::ProcessStatus_t
simlib3::Process::_RUNNING	simlib.h	/^      _PREPARED=1, _RUNNING, _INTERRUPTED, _TERMINATED$/;"	e	enum:simlib3::Process::ProcessStatus_t
simlib3::Process::_Run	process.cc	/^void Process::_Run() throw() \/\/ no exceptions$/;"	f	class:simlib3::Process	signature:()
simlib3::Process::_Run	simlib.h	/^  virtual void _Run() throw();          \/\/ internal point of activation$/;"	p	class:simlib3::Process	access:private	signature:()
simlib3::Process::_TERMINATED	simlib.h	/^      _PREPARED=1, _RUNNING, _INTERRUPTED, _TERMINATED$/;"	e	enum:simlib3::Process::ProcessStatus_t
simlib3::Process::_WaitUntil	simlib.h	/^  bool  _WaitUntil(bool test);          \/\/!< wait for condition (slow!)$/;"	p	class:simlib3::Process	access:public	signature:(bool test)
simlib3::Process::_WaitUntil	waitunti.cc	/^bool Process::_WaitUntil(bool test)$/;"	f	class:simlib3::Process	signature:(bool test)
simlib3::Process::_WaitUntilRemove	simlib.h	/^  void _WaitUntilRemove();$/;"	p	class:simlib3::Process	access:private	signature:()
simlib3::Process::_WaitUntilRemove	waitunti.cc	/^void Process::_WaitUntilRemove() {$/;"	f	class:simlib3::Process	signature:()
simlib3::Process::_context	simlib.h	/^  void * _context;                      \/\/!< process context pointer$/;"	m	class:simlib3::Process	access:private
simlib3::Process::_status	simlib.h	/^  } _status;$/;"	m	class:simlib3::Process	typeref:enum:simlib3::Process::ProcessStatus_t	access:private
simlib3::Process::_wait_until	simlib.h	/^  bool _wait_until;                     \/\/ waiting for condition$/;"	m	class:simlib3::Process	access:private
simlib3::Process::isCurrent	simlib.h	/^  bool isCurrent() const    { return (_status==_RUNNING);     } \/\/ Behavior() runs$/;"	f	class:simlib3::Process	access:private	signature:() const
simlib3::Process::isInterrupted	simlib.h	/^  bool isInterrupted() const{ return (_status==_INTERRUPTED); } \/\/ can continue$/;"	f	class:simlib3::Process	access:private	signature:() const
simlib3::Process::isPrepared	simlib.h	/^  bool isPrepared() const   { return (_status==_PREPARED);    } \/\/ before start$/;"	f	class:simlib3::Process	access:private	signature:() const
simlib3::Process::isTerminated	simlib.h	/^  bool isTerminated() const { return (_status==_TERMINATED);  } \/\/ zombie$/;"	f	class:simlib3::Process	access:private	signature:() const
simlib3::Process::operator =	simlib.h	/^  Process&operator=(const Process&);    \/\/ disable copying$/;"	p	class:simlib3::Process	access:private	signature:(const Process&)
simlib3::Process::~Process	process.cc	/^Process::~Process()$/;"	f	class:simlib3::Process	signature:()
simlib3::Process::~Process	simlib.h	/^  virtual ~Process();$/;"	p	class:simlib3::Process	access:public	signature:()
simlib3::Qntzr	simlib.h	/^class Qntzr : public aContiBlock1 {$/;"	c	namespace:simlib3	inherits:aContiBlock1
simlib3::Qntzr::Name	simlib.h	/^  virtual const char *Name() const;$/;"	p	class:simlib3::Qntzr	access:public	signature:() const
simlib3::Qntzr::Name	stdblock.cc	/^const char *Qntzr::Name() const$/;"	f	class:simlib3::Qntzr	signature:() const
simlib3::Qntzr::Qntzr	simlib.h	/^  Qntzr(Input in, double qstep=1.0);$/;"	p	class:simlib3::Qntzr	access:public	signature:(Input in, double qstep=1.0)
simlib3::Qntzr::Qntzr	stdblock.cc	/^Qntzr::Qntzr(Input in, double p) \/\/ p = quantiz. step$/;"	f	class:simlib3::Qntzr	signature:(Input in, double p)
simlib3::Qntzr::Value	simlib.h	/^  virtual double Value();         \/\/ returned value$/;"	p	class:simlib3::Qntzr	access:public	signature:()
simlib3::Qntzr::Value	stdblock.cc	/^double Qntzr::Value()$/;"	f	class:simlib3::Qntzr	signature:()
simlib3::Qntzr::_Eval	simlib.h	/^  virtual void _Eval();           \/\/ evaluation with loop check$/;"	p	class:simlib3::Qntzr	access:public	signature:()
simlib3::Qntzr::_Eval	stdblock.cc	/^void Qntzr::_Eval()$/;"	f	class:simlib3::Qntzr	signature:()
simlib3::Qntzr::step	simlib.h	/^  double step;                    \/\/ quantum$/;"	m	class:simlib3::Qntzr	access:protected
simlib3::Quantizer	simlib.h	/^typedef Qntzr Quantizer;$/;"	t	namespace:simlib3
simlib3::Queue	simlib.h	/^class Queue : public List { \/\/ don't inherit interface for now$/;"	c	namespace:simlib3	inherits:List
simlib3::Queue::Clear	simlib.h	/^    void Clear()  { clear(); }$/;"	f	class:simlib3::Queue	access:public	signature:()
simlib3::Queue::Empty	simlib.h	/^    bool Empty()  { return empty(); }$/;"	f	class:simlib3::Queue	access:public	signature:()
simlib3::Queue::Get	queue.cc	/^Entity *Queue::Get(iterator pos)$/;"	f	class:simlib3::Queue	signature:(iterator pos)
simlib3::Queue::Get	simlib.h	/^    virtual Entity *Get(iterator pos);           \/\/ remove entity$/;"	p	class:simlib3::Queue	access:public	signature:(iterator pos)
simlib3::Queue::GetFirst	queue.cc	/^Entity *Queue::GetFirst()$/;"	f	class:simlib3::Queue	signature:()
simlib3::Queue::GetFirst	simlib.h	/^    Entity *GetFirst();$/;"	p	class:simlib3::Queue	access:public	signature:()
simlib3::Queue::GetLast	queue.cc	/^Entity *Queue::GetLast()$/;"	f	class:simlib3::Queue	signature:()
simlib3::Queue::GetLast	simlib.h	/^    Entity *GetLast();$/;"	p	class:simlib3::Queue	access:public	signature:()
simlib3::Queue::InsFirst	queue.cc	/^void Queue::InsFirst(Entity *ent)$/;"	f	class:simlib3::Queue	signature:(Entity *ent)
simlib3::Queue::InsFirst	simlib.h	/^    void InsFirst(Entity *e);$/;"	p	class:simlib3::Queue	access:public	signature:(Entity *e)
simlib3::Queue::InsLast	queue.cc	/^void Queue::InsLast(Entity *ent)$/;"	f	class:simlib3::Queue	signature:(Entity *ent)
simlib3::Queue::InsLast	simlib.h	/^    void InsLast (Entity *e);$/;"	p	class:simlib3::Queue	access:public	signature:(Entity *e)
simlib3::Queue::Insert	queue.cc	/^void Queue::Insert(Entity *ent)$/;"	f	class:simlib3::Queue	signature:(Entity *ent)
simlib3::Queue::Insert	simlib.h	/^    virtual void Insert  (Entity *e);            \/\/ priority insert$/;"	p	class:simlib3::Queue	access:public	signature:(Entity *e)
simlib3::Queue::Length	simlib.h	/^    unsigned Length() { return size(); }$/;"	f	class:simlib3::Queue	access:public	signature:()
simlib3::Queue::Name	queue.cc	/^const char *Queue::Name() const$/;"	f	class:simlib3::Queue	signature:() const
simlib3::Queue::Name	simlib.h	/^    virtual const char *Name() const;$/;"	p	class:simlib3::Queue	access:public	signature:() const
simlib3::Queue::Output	output2.cc	/^void Queue::Output() const$/;"	f	class:simlib3::Queue	signature:() const
simlib3::Queue::Output	simlib.h	/^    virtual void Output() const;         \/\/!< print statistics$/;"	p	class:simlib3::Queue	access:public	signature:() const
simlib3::Queue::PostIns	queue.cc	/^void Queue::PostIns(Entity *ent, iterator pos)$/;"	f	class:simlib3::Queue	signature:(Entity *ent, iterator pos)
simlib3::Queue::PostIns	simlib.h	/^    void PostIns (Entity *e, iterator pos);$/;"	p	class:simlib3::Queue	access:public	signature:(Entity *e, iterator pos)
simlib3::Queue::PredIns	queue.cc	/^void Queue::PredIns(Entity *ent, iterator pos)$/;"	f	class:simlib3::Queue	signature:(Entity *ent, iterator pos)
simlib3::Queue::PredIns	simlib.h	/^    void PredIns (Entity *e, iterator pos); \/\/ insert at position$/;"	p	class:simlib3::Queue	access:public	signature:(Entity *e, iterator pos)
simlib3::Queue::Queue	queue.cc	/^Queue::Queue()$/;"	f	class:simlib3::Queue	signature:()
simlib3::Queue::Queue	queue.cc	/^Queue::Queue(const char *name)$/;"	f	class:simlib3::Queue	signature:(const char *name)
simlib3::Queue::Queue	simlib.h	/^    Queue();$/;"	p	class:simlib3::Queue	access:public	signature:()
simlib3::Queue::Queue	simlib.h	/^    Queue(const char *_name);$/;"	p	class:simlib3::Queue	access:public	signature:(const char *_name)
simlib3::Queue::StatDT	simlib.h	/^    Stat  StatDT;                        \/\/ statistics$/;"	m	class:simlib3::Queue	access:public
simlib3::Queue::StatN	simlib.h	/^    TStat StatN;$/;"	m	class:simlib3::Queue	access:public
simlib3::Queue::back	simlib.h	/^    Entity *back()     { return (Entity*)List::back(); }$/;"	f	class:simlib3::Queue	access:public	signature:()
simlib3::Queue::begin	simlib.h	/^    iterator begin()   { return List::begin(); }$/;"	f	class:simlib3::Queue	access:public	signature:()
simlib3::Queue::clear	queue.cc	/^void Queue::clear()$/;"	f	class:simlib3::Queue	signature:()
simlib3::Queue::clear	simlib.h	/^    void clear();                       \/\/!< initialize$/;"	p	class:simlib3::Queue	access:public	signature:()
simlib3::Queue::end	simlib.h	/^    iterator end()     { return List::end(); }$/;"	f	class:simlib3::Queue	access:public	signature:()
simlib3::Queue::front	simlib.h	/^    Entity *front()    { return (Entity*)List::front(); }$/;"	f	class:simlib3::Queue	access:public	signature:()
simlib3::Queue::iterator	simlib.h	/^    typedef List::iterator iterator;$/;"	t	class:simlib3::Queue	access:public
simlib3::Queue::operator Queue*	simlib.h	/^    operator Queue* () { return this; }  \/\/ allows Queue instead Queue*$/;"	f	class:simlib3::Queue	access:public	signature:()
simlib3::Queue::~Queue	queue.cc	/^Queue::~Queue() {$/;"	f	class:simlib3::Queue	signature:()
simlib3::Queue::~Queue	simlib.h	/^    ~Queue();$/;"	p	class:simlib3::Queue	access:public	signature:()
simlib3::RKE	ni_rke.h	/^class RKE : public StatusMethod {$/;"	c	namespace:simlib3	inherits:StatusMethod
simlib3::RKE::A1	ni_rke.h	/^  Memory A1, A2, A3, A4, A5, A6, A7;  \/\/ auxiliary memories$/;"	m	class:simlib3::RKE	access:private
simlib3::RKE::A2	ni_rke.h	/^  Memory A1, A2, A3, A4, A5, A6, A7;  \/\/ auxiliary memories$/;"	m	class:simlib3::RKE	access:private
simlib3::RKE::A3	ni_rke.h	/^  Memory A1, A2, A3, A4, A5, A6, A7;  \/\/ auxiliary memories$/;"	m	class:simlib3::RKE	access:private
simlib3::RKE::A4	ni_rke.h	/^  Memory A1, A2, A3, A4, A5, A6, A7;  \/\/ auxiliary memories$/;"	m	class:simlib3::RKE	access:private
simlib3::RKE::A5	ni_rke.h	/^  Memory A1, A2, A3, A4, A5, A6, A7;  \/\/ auxiliary memories$/;"	m	class:simlib3::RKE	access:private
simlib3::RKE::A6	ni_rke.h	/^  Memory A1, A2, A3, A4, A5, A6, A7;  \/\/ auxiliary memories$/;"	m	class:simlib3::RKE	access:private
simlib3::RKE::A7	ni_rke.h	/^  Memory A1, A2, A3, A4, A5, A6, A7;  \/\/ auxiliary memories$/;"	m	class:simlib3::RKE	access:private
simlib3::RKE::Integrate	ni_rke.cc	/^void RKE::Integrate(void)$/;"	f	class:simlib3::RKE	signature:(void)
simlib3::RKE::Integrate	ni_rke.h	/^  virtual void Integrate(void);  \/\/ integration method$/;"	p	class:simlib3::RKE	access:public	signature:(void)
simlib3::RKE::RKE	ni_rke.h	/^  RKE(const char* name) :  \/\/ registrate method and name it$/;"	f	class:simlib3::RKE	access:public	signature:(const char* name)
simlib3::RKE::di	ni_rke.h	/^  Memory si, di;$/;"	m	class:simlib3::RKE	access:private
simlib3::RKE::si	ni_rke.h	/^  Memory si, di;$/;"	m	class:simlib3::RKE	access:private
simlib3::RKE::xi	ni_rke.h	/^  StatusMemory xi;$/;"	m	class:simlib3::RKE	access:private
simlib3::RKE::~RKE	ni_rke.h	/^  virtual ~RKE()  \/\/ destructor$/;"	f	class:simlib3::RKE	access:public	signature:()
simlib3::RKF3	ni_rkf3.h	/^class RKF3 : public SingleStepMethod {$/;"	c	namespace:simlib3	inherits:SingleStepMethod
simlib3::RKF3::A1	ni_rkf3.h	/^  Memory A1, A2, A3;  \/\/ auxiliary memories$/;"	m	class:simlib3::RKF3	access:private
simlib3::RKF3::A2	ni_rkf3.h	/^  Memory A1, A2, A3;  \/\/ auxiliary memories$/;"	m	class:simlib3::RKF3	access:private
simlib3::RKF3::A3	ni_rkf3.h	/^  Memory A1, A2, A3;  \/\/ auxiliary memories$/;"	m	class:simlib3::RKF3	access:private
simlib3::RKF3::Integrate	ni_rkf3.cc	/^void RKF3::Integrate(void)$/;"	f	class:simlib3::RKF3	signature:(void)
simlib3::RKF3::Integrate	ni_rkf3.h	/^  virtual void Integrate(void);  \/\/ integration method$/;"	p	class:simlib3::RKF3	access:public	signature:(void)
simlib3::RKF3::RKF3	ni_rkf3.h	/^  RKF3(const char* name) :  \/\/ registrate method and name it$/;"	f	class:simlib3::RKF3	access:public	signature:(const char* name)
simlib3::RKF3::~RKF3	ni_rkf3.h	/^  virtual ~RKF3()  \/\/ destructor$/;"	f	class:simlib3::RKF3	access:public	signature:()
simlib3::RKF5	ni_rkf5.h	/^class RKF5 : public SingleStepMethod {$/;"	c	namespace:simlib3	inherits:SingleStepMethod
simlib3::RKF5::A1	ni_rkf5.h	/^  Memory A1, A2, A3, A4, A5, A6;  \/\/ auxiliary memories$/;"	m	class:simlib3::RKF5	access:private
simlib3::RKF5::A2	ni_rkf5.h	/^  Memory A1, A2, A3, A4, A5, A6;  \/\/ auxiliary memories$/;"	m	class:simlib3::RKF5	access:private
simlib3::RKF5::A3	ni_rkf5.h	/^  Memory A1, A2, A3, A4, A5, A6;  \/\/ auxiliary memories$/;"	m	class:simlib3::RKF5	access:private
simlib3::RKF5::A4	ni_rkf5.h	/^  Memory A1, A2, A3, A4, A5, A6;  \/\/ auxiliary memories$/;"	m	class:simlib3::RKF5	access:private
simlib3::RKF5::A5	ni_rkf5.h	/^  Memory A1, A2, A3, A4, A5, A6;  \/\/ auxiliary memories$/;"	m	class:simlib3::RKF5	access:private
simlib3::RKF5::A6	ni_rkf5.h	/^  Memory A1, A2, A3, A4, A5, A6;  \/\/ auxiliary memories$/;"	m	class:simlib3::RKF5	access:private
simlib3::RKF5::Integrate	ni_rkf5.cc	/^void RKF5::Integrate(void)$/;"	f	class:simlib3::RKF5	signature:(void)
simlib3::RKF5::Integrate	ni_rkf5.h	/^  virtual void Integrate(void);  \/\/ integration method$/;"	p	class:simlib3::RKF5	access:public	signature:(void)
simlib3::RKF5::RKF5	ni_rkf5.h	/^  RKF5(const char* name) :  \/\/ registrate method and name it$/;"	f	class:simlib3::RKF5	access:public	signature:(const char* name)
simlib3::RKF5::~RKF5	ni_rkf5.h	/^  virtual ~RKF5()  \/\/ destructor$/;"	f	class:simlib3::RKF5	access:public	signature:()
simlib3::RKF8	ni_rkf8.h	/^class RKF8 : public SingleStepMethod {$/;"	c	namespace:simlib3	inherits:SingleStepMethod
simlib3::RKF8::A1	ni_rkf8.h	/^  Memory A1, A2, A3,  A4,  A5,  A6, A7;  \/\/ auxiliary memories$/;"	m	class:simlib3::RKF8	access:private
simlib3::RKF8::A10	ni_rkf8.h	/^  Memory A8, A9, A10, A11, A12, A13;$/;"	m	class:simlib3::RKF8	access:private
simlib3::RKF8::A11	ni_rkf8.h	/^  Memory A8, A9, A10, A11, A12, A13;$/;"	m	class:simlib3::RKF8	access:private
simlib3::RKF8::A12	ni_rkf8.h	/^  Memory A8, A9, A10, A11, A12, A13;$/;"	m	class:simlib3::RKF8	access:private
simlib3::RKF8::A13	ni_rkf8.h	/^  Memory A8, A9, A10, A11, A12, A13;$/;"	m	class:simlib3::RKF8	access:private
simlib3::RKF8::A2	ni_rkf8.h	/^  Memory A1, A2, A3,  A4,  A5,  A6, A7;  \/\/ auxiliary memories$/;"	m	class:simlib3::RKF8	access:private
simlib3::RKF8::A3	ni_rkf8.h	/^  Memory A1, A2, A3,  A4,  A5,  A6, A7;  \/\/ auxiliary memories$/;"	m	class:simlib3::RKF8	access:private
simlib3::RKF8::A4	ni_rkf8.h	/^  Memory A1, A2, A3,  A4,  A5,  A6, A7;  \/\/ auxiliary memories$/;"	m	class:simlib3::RKF8	access:private
simlib3::RKF8::A5	ni_rkf8.h	/^  Memory A1, A2, A3,  A4,  A5,  A6, A7;  \/\/ auxiliary memories$/;"	m	class:simlib3::RKF8	access:private
simlib3::RKF8::A6	ni_rkf8.h	/^  Memory A1, A2, A3,  A4,  A5,  A6, A7;  \/\/ auxiliary memories$/;"	m	class:simlib3::RKF8	access:private
simlib3::RKF8::A7	ni_rkf8.h	/^  Memory A1, A2, A3,  A4,  A5,  A6, A7;  \/\/ auxiliary memories$/;"	m	class:simlib3::RKF8	access:private
simlib3::RKF8::A8	ni_rkf8.h	/^  Memory A8, A9, A10, A11, A12, A13;$/;"	m	class:simlib3::RKF8	access:private
simlib3::RKF8::A9	ni_rkf8.h	/^  Memory A8, A9, A10, A11, A12, A13;$/;"	m	class:simlib3::RKF8	access:private
simlib3::RKF8::Integrate	ni_rkf8.cc	/^void RKF8::Integrate(void)$/;"	f	class:simlib3::RKF8	signature:(void)
simlib3::RKF8::Integrate	ni_rkf8.h	/^  virtual void Integrate(void);  \/\/ integration method$/;"	p	class:simlib3::RKF8	access:public	signature:(void)
simlib3::RKF8::RKF8	ni_rkf8.h	/^  RKF8(const char* name) :  \/\/ registrate method and name it$/;"	f	class:simlib3::RKF8	access:public	signature:(const char* name)
simlib3::RKF8::~RKF8	ni_rkf8.h	/^  virtual ~RKF8()  \/\/ destructor$/;"	f	class:simlib3::RKF8	access:public	signature:()
simlib3::Random	random1.cc	/^double Random()$/;"	f	namespace:simlib3	signature:()
simlib3::Random	random1.cc	/^double Random();                  \/\/ base uniform generator 0-0.999999...$/;"	p	namespace:simlib3	file:	signature:()
simlib3::Random	simlib.h	/^double Random();$/;"	p	namespace:simlib3	signature:()
simlib3::RandomSeed	random1.cc	/^void   RandomSeed(long seed);     \/\/ initialize random number seed$/;"	p	namespace:simlib3	file:	signature:(long seed)
simlib3::RandomSeed	random1.cc	/^void RandomSeed(long seed)$/;"	f	namespace:simlib3	signature:(long seed)
simlib3::RandomSeed	simlib.h	/^void   RandomSeed(long seed);$/;"	p	namespace:simlib3	signature:(long seed)
simlib3::Rayle	random2.cc	/^double Rayle(double delta)$/;"	f	namespace:simlib3	signature:(double delta)
simlib3::Rayle	simlib.h	/^double Rayle(double delta);$/;"	p	namespace:simlib3	signature:(double delta)
simlib3::RegulaFalsi	simlib.h	/^class RegulaFalsi : public AlgLoop {$/;"	c	namespace:simlib3	inherits:AlgLoop
simlib3::RegulaFalsi::RegulaFalsi	simlib.h	/^  RegulaFalsi(Input i, double eps, unsigned long max_it,$/;"	f	class:simlib3::RegulaFalsi	access:public	signature:(Input i, double eps, unsigned long max_it, double t_min, double t_max)
simlib3::RegulaFalsi::Value	algloop.cc	/^double RegulaFalsi::Value()$/;"	f	class:simlib3::RegulaFalsi	signature:()
simlib3::RegulaFalsi::Value	simlib.h	/^  virtual double Value(); \/\/ returned value$/;"	p	class:simlib3::RegulaFalsi	access:public	signature:()
simlib3::RegulaFalsi::eps_root	simlib.h	/^  double eps_root; \/\/ root for force precision test$/;"	m	class:simlib3::RegulaFalsi	access:private
simlib3::RelativeError	intg.cc	/^const double &RelativeError=SIMLIB_RelativeError; \/\/!< max. rel. error$/;"	m	namespace:simlib3	file:
simlib3::Relay	simlib.h	/^class Relay : public Status {   \/\/ general relay block$/;"	c	namespace:simlib3	inherits:Status
simlib3::Relay::Eval	simlib.h	/^  virtual void Eval();          \/\/!< block evaluation$/;"	p	class:simlib3::Relay	access:public	signature:()
simlib3::Relay::Eval	stdblock.cc	/^void Relay::Eval()$/;"	f	class:simlib3::Relay	signature:()
simlib3::Relay::Name	simlib.h	/^  virtual const char *Name() const;$/;"	p	class:simlib3::Relay	access:public	signature:() const
simlib3::Relay::Name	stdblock.cc	/^const char *Relay::Name() const$/;"	f	class:simlib3::Relay	signature:() const
simlib3::Relay::Relay	simlib.h	/^  Relay(Input i, double p1, double p2, double p3, double p4,$/;"	p	class:simlib3::Relay	access:public	signature:(Input i, double p1, double p2, double p3, double p4, double y1, double y2)
simlib3::Relay::Relay	stdblock.cc	/^Relay::Relay(Input i, double _p1, double _p2, double _p3, double _p4, double _y1, double _y2)$/;"	f	class:simlib3::Relay	signature:(Input i, double _p1, double _p2, double _p3, double _p4, double _y1, double _y2)
simlib3::Relay::p1	simlib.h	/^  double p1,p2,p3,p4;           \/\/ points on x-axis$/;"	m	class:simlib3::Relay	access:protected
simlib3::Relay::p2	simlib.h	/^  double p1,p2,p3,p4;           \/\/ points on x-axis$/;"	m	class:simlib3::Relay	access:protected
simlib3::Relay::p3	simlib.h	/^  double p1,p2,p3,p4;           \/\/ points on x-axis$/;"	m	class:simlib3::Relay	access:protected
simlib3::Relay::p4	simlib.h	/^  double p1,p2,p3,p4;           \/\/ points on x-axis$/;"	m	class:simlib3::Relay	access:protected
simlib3::Relay::y1	simlib.h	/^  double y1,y2;                 \/\/ points on y-axis$/;"	m	class:simlib3::Relay	access:protected
simlib3::Relay::y2	simlib.h	/^  double y1,y2;                 \/\/ points on y-axis$/;"	m	class:simlib3::Relay	access:protected
simlib3::RemoveName	name.cc	/^void RemoveName(SimObject & o)$/;"	f	namespace:simlib3	signature:(SimObject & o)
simlib3::RemoveName	name.cc	/^void RemoveName(SimObject * o)$/;"	f	namespace:simlib3	signature:(SimObject * o)
simlib3::RemoveName	simlib.h	/^void RemoveName(SimObject &o);$/;"	p	namespace:simlib3	signature:(SimObject &o)
simlib3::RemoveName	simlib.h	/^void RemoveName(SimObject *o);$/;"	p	namespace:simlib3	signature:(SimObject *o)
simlib3::Rline	simlib.h	/^class Rline : public aContiBlock1 {$/;"	c	namespace:simlib3	inherits:aContiBlock1
simlib3::Rline::Name	simlib.h	/^  virtual const char *Name() const;$/;"	p	class:simlib3::Rline	access:public	signature:() const
simlib3::Rline::Name	stdblock.cc	/^const char *Rline::Name() const$/;"	f	class:simlib3::Rline	signature:() const
simlib3::Rline::Rline	simlib.h	/^    Rline(const Rline&); \/\/ ## disable$/;"	p	class:simlib3::Rline	access:private	signature:(const Rline&)
simlib3::Rline::Rline	simlib.h	/^  Rline(Input in, int num, double *X, double *Y);$/;"	p	class:simlib3::Rline	access:public	signature:(Input in, int num, double *X, double *Y)
simlib3::Rline::Rline	stdblock.cc	/^Rline::Rline(Input in, int num, double *X, double *Y)$/;"	f	class:simlib3::Rline	signature:(Input in, int num, double *X, double *Y)
simlib3::Rline::Value	simlib.h	/^  virtual double Value();         \/\/ returned value$/;"	p	class:simlib3::Rline	access:public	signature:()
simlib3::Rline::Value	stdblock.cc	/^double Rline::Value()$/;"	f	class:simlib3::Rline	signature:()
simlib3::Rline::_Eval	simlib.h	/^  virtual void _Eval();           \/\/ evaluation with loop check$/;"	p	class:simlib3::Rline	access:public	signature:()
simlib3::Rline::_Eval	stdblock.cc	/^void Rline::_Eval()$/;"	f	class:simlib3::Rline	signature:()
simlib3::Rline::n	simlib.h	/^  int n;                          \/\/ table item number$/;"	m	class:simlib3::Rline	access:protected
simlib3::Rline::operator =	simlib.h	/^    Rline&operator=(const Rline&); \/\/ ## disable$/;"	p	class:simlib3::Rline	access:private	signature:(const Rline&)
simlib3::Rline::tableX	simlib.h	/^  double *tableX;                 \/\/ tabulka X$/;"	m	class:simlib3::Rline	access:protected
simlib3::Rline::tableY	simlib.h	/^  double *tableY;                 \/\/ tabulka Y$/;"	m	class:simlib3::Rline	access:protected
simlib3::Rline::~Rline	simlib.h	/^  ~Rline();$/;"	p	class:simlib3::Rline	access:public	signature:()
simlib3::Rline::~Rline	stdblock.cc	/^Rline::~Rline()$/;"	f	class:simlib3::Rline	signature:()
simlib3::Run	run.cc	/^void Run() {$/;"	f	namespace:simlib3	signature:()
simlib3::Run	simlib.h	/^void Run();$/;"	p	namespace:simlib3	signature:()
simlib3::SIGNBIT	random1.cc	/^const myint32 SIGNBIT    = 0x80000000UL;$/;"	m	namespace:simlib3	file:
simlib3::SIMLIB_AbsoluteError	intg.cc	/^double SIMLIB_AbsoluteError=0;       \/\/!< absolute error$/;"	m	namespace:simlib3	file:
simlib3::SIMLIB_ConditionFlag	cond.cc	/^bool SIMLIB_ConditionFlag = false;       \/\/ condition vector changed$/;"	m	namespace:simlib3	file:
simlib3::SIMLIB_ContinueInit	internal.h	/^void SIMLIB_ContinueInit();          \/\/ initialize variables$/;"	p	namespace:simlib3	signature:()
simlib3::SIMLIB_ContinueInit	intg.cc	/^void SIMLIB_ContinueInit()$/;"	f	namespace:simlib3	signature:()
simlib3::SIMLIB_ContractStep	intg.cc	/^double  SIMLIB_ContractStep = SIMLIB_MAXTIME;    \/\/!< requested step size$/;"	m	namespace:simlib3	file:
simlib3::SIMLIB_ContractStepFlag	intg.cc	/^bool SIMLIB_ContractStepFlag = false;     \/\/!< requests shorter step$/;"	m	namespace:simlib3	file:
simlib3::SIMLIB_Current	run.cc	/^Entity *SIMLIB_Current = NULL;$/;"	m	namespace:simlib3	file:
simlib3::SIMLIB_Delay	delay.cc	/^class SIMLIB_Delay {$/;"	c	namespace:simlib3	file:
simlib3::SIMLIB_Delay::Destroy	delay.cc	/^    static void Destroy() {     \/\/!< should be called by ExitSimulation()? ###???$/;"	f	class:simlib3::SIMLIB_Delay	file:	access:private	signature:()
simlib3::SIMLIB_Delay::InitAll	delay.cc	/^    static void InitAll() {     \/\/ called at Init()$/;"	f	class:simlib3::SIMLIB_Delay	file:	access:private	signature:()
simlib3::SIMLIB_Delay::Initialize	delay.cc	/^    static void Initialize() {          \/\/!< initialize delay subsystem$/;"	f	class:simlib3::SIMLIB_Delay	file:	access:private	signature:()
simlib3::SIMLIB_Delay::Register	delay.cc	/^    static void Register(Delay *p) {    \/\/!< must be called by Delay ctr$/;"	f	class:simlib3::SIMLIB_Delay	access:public	signature:(Delay *p)
simlib3::SIMLIB_Delay::SampleAll	delay.cc	/^    static void SampleAll() {   \/\/ called each continuous step (and more)$/;"	f	class:simlib3::SIMLIB_Delay	file:	access:private	signature:()
simlib3::SIMLIB_Delay::UnRegister	delay.cc	/^      static void UnRegister(Delay *p) {\/\/!< must be called from Delay destructor$/;"	f	class:simlib3::SIMLIB_Delay	access:public	signature:(Delay *p)
simlib3::SIMLIB_Delay::listptr	delay.cc	/^    static std::list<Delay *> *listptr; \/\/!< list of delay objects -- singleton$/;"	m	class:simlib3::SIMLIB_Delay	file:	access:private
simlib3::SIMLIB_Delay::listptr	delay.cc	/^std::list<Delay *> *SIMLIB_Delay::listptr = 0;$/;"	m	class:simlib3::SIMLIB_Delay	file:
simlib3::SIMLIB_DelayBuffer	delay.cc	/^class SIMLIB_DelayBuffer : public Delay::Buffer { \/\/ memory for delayed signal$/;"	c	namespace:simlib3	file:	inherits:Delay::Buffer
simlib3::SIMLIB_DelayBuffer::Pair	delay.cc	/^    struct Pair {$/;"	s	class:simlib3::SIMLIB_DelayBuffer	file:	access:private
simlib3::SIMLIB_DelayBuffer::Pair::Pair	delay.cc	/^        Pair(double t, double v) : time(t), value(v) {}$/;"	f	struct:simlib3::SIMLIB_DelayBuffer::Pair	access:public	signature:(double t, double v)
simlib3::SIMLIB_DelayBuffer::Pair::operator ==	delay.cc	/^        bool operator == (Pair &p) { return p.time==time && p.value==value; }$/;"	f	struct:simlib3::SIMLIB_DelayBuffer::Pair	access:public	signature:(Pair &p)
simlib3::SIMLIB_DelayBuffer::Pair::time	delay.cc	/^        double time;    \/\/<! sample time$/;"	m	struct:simlib3::SIMLIB_DelayBuffer::Pair	file:	access:public
simlib3::SIMLIB_DelayBuffer::Pair::value	delay.cc	/^        double value;   \/\/<! sampled value$/;"	m	struct:simlib3::SIMLIB_DelayBuffer::Pair	file:	access:public
simlib3::SIMLIB_DelayBuffer::SIMLIB_DelayBuffer	delay.cc	/^    SIMLIB_DelayBuffer(): buf(), last_insert(-2,0) { \/*empty*\/ }$/;"	f	class:simlib3::SIMLIB_DelayBuffer	access:public	signature:()
simlib3::SIMLIB_DelayBuffer::buf	delay.cc	/^    std::deque<Pair> buf;       \/\/!< storage for samples$/;"	m	class:simlib3::SIMLIB_DelayBuffer	file:	access:private
simlib3::SIMLIB_DelayBuffer::clear	delay.cc	/^    virtual void clear() {$/;"	f	class:simlib3::SIMLIB_DelayBuffer	access:public	signature:()
simlib3::SIMLIB_DelayBuffer::get	delay.cc	/^    virtual double get(double time) \/\/ get delayed value (with interpolation)$/;"	f	class:simlib3::SIMLIB_DelayBuffer	access:public	signature:(double time)
simlib3::SIMLIB_DelayBuffer::last_insert	delay.cc	/^    Pair last_insert;           \/\/!< last inserted value (for optimization)$/;"	m	class:simlib3::SIMLIB_DelayBuffer	file:	access:private
simlib3::SIMLIB_DelayBuffer::put	delay.cc	/^    virtual void put(double value, double time) {$/;"	f	class:simlib3::SIMLIB_DelayBuffer	access:public	signature:(double value, double time)
simlib3::SIMLIB_DeltaTime	intg.cc	/^double SIMLIB_DeltaTime;             \/\/!< Time-SIMLIB_StepStartTime$/;"	m	namespace:simlib3	file:
simlib3::SIMLIB_DoActions	internal.h	/^void SIMLIB_DoActions();             \/\/ dispatch events and processes$/;"	p	namespace:simlib3	signature:()
simlib3::SIMLIB_DoActions	run.cc	/^void SIMLIB_DoActions()$/;"	f	namespace:simlib3	signature:()
simlib3::SIMLIB_DoConditions	cond.cc	/^void SIMLIB_DoConditions()$/;"	f	namespace:simlib3	signature:()
simlib3::SIMLIB_DoConditions	internal.h	/^void SIMLIB_DoConditions();          \/\/ perform state events$/;"	p	namespace:simlib3	signature:()
simlib3::SIMLIB_Dynamic	continuous.cc	/^void SIMLIB_Dynamic() \/\/ called each step$/;"	f	namespace:simlib3	signature:()
simlib3::SIMLIB_Dynamic	internal.h	/^void SIMLIB_Dynamic();               \/\/ optimize!$/;"	p	namespace:simlib3	signature:()
simlib3::SIMLIB_DynamicFlag	intg.cc	/^bool SIMLIB_DynamicFlag = false;          \/\/!< in dynamic section$/;"	m	namespace:simlib3	file:
simlib3::SIMLIB_ERRNO	intg.cc	/^int SIMLIB_ERRNO=0;$/;"	m	namespace:simlib3	file:
simlib3::SIMLIB_EndTime	run.cc	/^double SIMLIB_EndTime;         \/\/ time of simulation end$/;"	m	namespace:simlib3	file:
simlib3::SIMLIB_Entity_Count	entity.cc	/^static unsigned long SIMLIB_Entity_Count = 0L; \/\/ # of entities in model$/;"	m	namespace:simlib3	file:
simlib3::SIMLIB_IMPLEMENTATION	algloop.cc	/^SIMLIB_IMPLEMENTATION;$/;"	m	namespace:simlib3	file:
simlib3::SIMLIB_IMPLEMENTATION	atexit.cc	/^SIMLIB_IMPLEMENTATION;$/;"	m	namespace:simlib3	file:
simlib3::SIMLIB_IMPLEMENTATION	barrier.cc	/^SIMLIB_IMPLEMENTATION;$/;"	m	namespace:simlib3	file:
simlib3::SIMLIB_IMPLEMENTATION	calendar.cc	/^SIMLIB_IMPLEMENTATION;$/;"	m	namespace:simlib3	file:
simlib3::SIMLIB_IMPLEMENTATION	cond.cc	/^SIMLIB_IMPLEMENTATION;$/;"	m	namespace:simlib3	file:
simlib3::SIMLIB_IMPLEMENTATION	continuous.cc	/^SIMLIB_IMPLEMENTATION;$/;"	m	namespace:simlib3	file:
simlib3::SIMLIB_IMPLEMENTATION	debug.cc	/^SIMLIB_IMPLEMENTATION;$/;"	m	namespace:simlib3	file:
simlib3::SIMLIB_IMPLEMENTATION	delay.cc	/^SIMLIB_IMPLEMENTATION;$/;"	m	namespace:simlib3	file:
simlib3::SIMLIB_IMPLEMENTATION	entity.cc	/^SIMLIB_IMPLEMENTATION;$/;"	m	namespace:simlib3	file:
simlib3::SIMLIB_IMPLEMENTATION	error.cc	/^SIMLIB_IMPLEMENTATION;$/;"	m	namespace:simlib3	file:
simlib3::SIMLIB_IMPLEMENTATION	event.cc	/^SIMLIB_IMPLEMENTATION;$/;"	m	namespace:simlib3	file:
simlib3::SIMLIB_IMPLEMENTATION	facility.cc	/^SIMLIB_IMPLEMENTATION;$/;"	m	namespace:simlib3	file:
simlib3::SIMLIB_IMPLEMENTATION	fun.cc	/^SIMLIB_IMPLEMENTATION;$/;"	m	namespace:simlib3	file:
simlib3::SIMLIB_IMPLEMENTATION	graph.cc	/^SIMLIB_IMPLEMENTATION;$/;"	m	namespace:simlib3	file:
simlib3::SIMLIB_IMPLEMENTATION	histo.cc	/^SIMLIB_IMPLEMENTATION;$/;"	m	namespace:simlib3	file:
simlib3::SIMLIB_IMPLEMENTATION	intg.cc	/^SIMLIB_IMPLEMENTATION;$/;"	m	namespace:simlib3	file:
simlib3::SIMLIB_IMPLEMENTATION	link.cc	/^SIMLIB_IMPLEMENTATION;$/;"	m	namespace:simlib3	file:
simlib3::SIMLIB_IMPLEMENTATION	list.cc	/^SIMLIB_IMPLEMENTATION;$/;"	m	namespace:simlib3	file:
simlib3::SIMLIB_IMPLEMENTATION	name.cc	/^SIMLIB_IMPLEMENTATION;$/;"	m	namespace:simlib3	file:
simlib3::SIMLIB_IMPLEMENTATION	ni_abm4.cc	/^SIMLIB_IMPLEMENTATION;$/;"	m	namespace:simlib3	file:
simlib3::SIMLIB_IMPLEMENTATION	ni_euler.cc	/^SIMLIB_IMPLEMENTATION;$/;"	m	namespace:simlib3	file:
simlib3::SIMLIB_IMPLEMENTATION	ni_fw.cc	/^SIMLIB_IMPLEMENTATION;$/;"	m	namespace:simlib3	file:
simlib3::SIMLIB_IMPLEMENTATION	ni_rke.cc	/^SIMLIB_IMPLEMENTATION;$/;"	m	namespace:simlib3	file:
simlib3::SIMLIB_IMPLEMENTATION	ni_rkf3.cc	/^SIMLIB_IMPLEMENTATION;$/;"	m	namespace:simlib3	file:
simlib3::SIMLIB_IMPLEMENTATION	ni_rkf5.cc	/^SIMLIB_IMPLEMENTATION;$/;"	m	namespace:simlib3	file:
simlib3::SIMLIB_IMPLEMENTATION	ni_rkf8.cc	/^SIMLIB_IMPLEMENTATION;$/;"	m	namespace:simlib3	file:
simlib3::SIMLIB_IMPLEMENTATION	numint.cc	/^SIMLIB_IMPLEMENTATION;$/;"	m	namespace:simlib3	file:
simlib3::SIMLIB_IMPLEMENTATION	object.cc	/^SIMLIB_IMPLEMENTATION;$/;"	m	namespace:simlib3	file:
simlib3::SIMLIB_IMPLEMENTATION	opt-hooke.cc	/^SIMLIB_IMPLEMENTATION;$/;"	m	namespace:simlib3	file:
simlib3::SIMLIB_IMPLEMENTATION	opt-param.cc	/^SIMLIB_IMPLEMENTATION;$/;"	m	namespace:simlib3	file:
simlib3::SIMLIB_IMPLEMENTATION	opt-simann.cc	/^SIMLIB_IMPLEMENTATION;$/;"	m	namespace:simlib3	file:
simlib3::SIMLIB_IMPLEMENTATION	output1.cc	/^SIMLIB_IMPLEMENTATION;$/;"	m	namespace:simlib3	file:
simlib3::SIMLIB_IMPLEMENTATION	output2.cc	/^SIMLIB_IMPLEMENTATION;$/;"	m	namespace:simlib3	file:
simlib3::SIMLIB_IMPLEMENTATION	print.cc	/^SIMLIB_IMPLEMENTATION;$/;"	m	namespace:simlib3	file:
simlib3::SIMLIB_IMPLEMENTATION	process.cc	/^SIMLIB_IMPLEMENTATION;$/;"	m	namespace:simlib3	file:
simlib3::SIMLIB_IMPLEMENTATION	queue.cc	/^SIMLIB_IMPLEMENTATION;$/;"	m	namespace:simlib3	file:
simlib3::SIMLIB_IMPLEMENTATION	random1.cc	/^SIMLIB_IMPLEMENTATION;$/;"	m	namespace:simlib3	file:
simlib3::SIMLIB_IMPLEMENTATION	random2.cc	/^SIMLIB_IMPLEMENTATION;$/;"	m	namespace:simlib3	file:
simlib3::SIMLIB_IMPLEMENTATION	run.cc	/^SIMLIB_IMPLEMENTATION;$/;"	m	namespace:simlib3	file:
simlib3::SIMLIB_IMPLEMENTATION	sampler.cc	/^SIMLIB_IMPLEMENTATION;$/;"	m	namespace:simlib3	file:
simlib3::SIMLIB_IMPLEMENTATION	semaphor.cc	/^SIMLIB_IMPLEMENTATION;$/;"	m	namespace:simlib3	file:
simlib3::SIMLIB_IMPLEMENTATION	simlib2D.cc	/^SIMLIB_IMPLEMENTATION;$/;"	m	namespace:simlib3	file:
simlib3::SIMLIB_IMPLEMENTATION	simlib3D.cc	/^SIMLIB_IMPLEMENTATION;$/;"	m	namespace:simlib3	file:
simlib3::SIMLIB_IMPLEMENTATION	stat.cc	/^SIMLIB_IMPLEMENTATION;$/;"	m	namespace:simlib3	file:
simlib3::SIMLIB_IMPLEMENTATION	stdblock.cc	/^SIMLIB_IMPLEMENTATION;$/;"	m	namespace:simlib3	file:
simlib3::SIMLIB_IMPLEMENTATION	store.cc	/^SIMLIB_IMPLEMENTATION;$/;"	m	namespace:simlib3	file:
simlib3::SIMLIB_IMPLEMENTATION	tstat.cc	/^SIMLIB_IMPLEMENTATION;$/;"	m	namespace:simlib3	file:
simlib3::SIMLIB_IMPLEMENTATION	version.cc	/^SIMLIB_IMPLEMENTATION;$/;"	m	namespace:simlib3	file:
simlib3::SIMLIB_IMPLEMENTATION	waitunti.cc	/^SIMLIB_IMPLEMENTATION;$/;"	m	namespace:simlib3	file:
simlib3::SIMLIB_IMPLEMENTATION	zdelay.cc	/^SIMLIB_IMPLEMENTATION;$/;"	m	namespace:simlib3	file:
simlib3::SIMLIB_Init	run.cc	/^void SIMLIB_Init(double T0, double T1, unsigned version)$/;"	f	namespace:simlib3	signature:(double T0, double T1, unsigned version)
simlib3::SIMLIB_MAXTIME	simlib.h	/^const double SIMLIB_MAXTIME = 1.0e30; \/\/!< maximum time (1e30 works for float, too)$/;"	m	namespace:simlib3
simlib3::SIMLIB_MINTIME	simlib.h	/^const double SIMLIB_MINTIME = 0.0;    \/\/!< minimal time value$/;"	m	namespace:simlib3
simlib3::SIMLIB_MaxStep	intg.cc	/^double SIMLIB_MaxStep=1;             \/\/!< max. step$/;"	m	namespace:simlib3	file:
simlib3::SIMLIB_MinStep	intg.cc	/^double SIMLIB_MinStep=1e-10;         \/\/!< minimal step$/;"	m	namespace:simlib3	file:
simlib3::SIMLIB_NextTime	run.cc	/^double SIMLIB_NextTime;        \/\/ next-event time$/;"	m	namespace:simlib3	file:
simlib3::SIMLIB_OptStep	intg.cc	/^double SIMLIB_OptStep;               \/\/!< optimal step$/;"	m	namespace:simlib3	file:
simlib3::SIMLIB_Phase	run.cc	/^SIMLIB_Phase_t SIMLIB_Phase = START;$/;"	m	namespace:simlib3	file:
simlib3::SIMLIB_Phase_t	internal.h	/^enum SIMLIB_Phase_t {$/;"	g	namespace:simlib3
simlib3::SIMLIB_RandomBase	random1.cc	/^double SIMLIB_RandomBase()  \/\/ range <0..1)$/;"	f	namespace:simlib3	signature:()
simlib3::SIMLIB_RandomBasePtr	random1.cc	/^static double (*SIMLIB_RandomBasePtr)() = SIMLIB_RandomBase;$/;"	m	namespace:simlib3	file:
simlib3::SIMLIB_RandomSeed	random1.cc	/^static myint32 SIMLIB_RandomSeed = INICONST ;$/;"	m	namespace:simlib3	file:
simlib3::SIMLIB_RelativeError	intg.cc	/^double SIMLIB_RelativeError=0.001;   \/\/!< relative error$/;"	m	namespace:simlib3	file:
simlib3::SIMLIB_ResetStatus	intg.cc	/^bool SIMLIB_ResetStatus = false;$/;"	m	namespace:simlib3	file:
simlib3::SIMLIB_StartTime	run.cc	/^double SIMLIB_StartTime;       \/\/ time of simulation start$/;"	m	namespace:simlib3	file:
simlib3::SIMLIB_StepSize	intg.cc	/^double SIMLIB_StepSize;              \/\/!< actual step$/;"	m	namespace:simlib3	file:
simlib3::SIMLIB_StepStartTime	intg.cc	/^double SIMLIB_StepStartTime;         \/\/!< last step time$/;"	m	namespace:simlib3	file:
simlib3::SIMLIB_Time	run.cc	/^double SIMLIB_Time;            \/\/ simulation time$/;"	m	namespace:simlib3	file:
simlib3::SIMLIB_WUClear	internal.h	/^void SIMLIB_WUClear();               \/\/ clear WUList$/;"	p	namespace:simlib3	signature:()
simlib3::SIMLIB_WUClear	run.cc	/^void SIMLIB_WUClear() \/\/ should be removed -- ise CALL_HOOK instead$/;"	f	namespace:simlib3	signature:()
simlib3::SIMLIB_ZDelayTimer	zdelay.cc	/^class SIMLIB_ZDelayTimer {$/;"	c	namespace:simlib3	file:
simlib3::SIMLIB_ZDelayTimer::Destroy	zdelay.cc	/^    static void Destroy() {     \/\/ should be called by ExitSimulation()? ###???$/;"	f	class:simlib3::SIMLIB_ZDelayTimer	file:	access:private	signature:()
simlib3::SIMLIB_ZDelayTimer::InitAll	zdelay.cc	/^    static void InitAll() {     \/\/ called at Init()$/;"	f	class:simlib3::SIMLIB_ZDelayTimer	file:	access:private	signature:()
simlib3::SIMLIB_ZDelayTimer::Initialize	zdelay.cc	/^    static void Initialize() {          \/\/ initialize delay subsystem$/;"	f	class:simlib3::SIMLIB_ZDelayTimer	file:	access:private	signature:()
simlib3::SIMLIB_ZDelayTimer::Register	zdelay.cc	/^    static void Register(ZDelayTimer *p) { \/\/ called from ZDelayTimer constructor$/;"	f	class:simlib3::SIMLIB_ZDelayTimer	access:public	signature:(ZDelayTimer *p)
simlib3::SIMLIB_ZDelayTimer::UnRegister	zdelay.cc	/^    static void UnRegister(ZDelayTimer *p) { \/\/ called from ZDelayTimer destructor$/;"	f	class:simlib3::SIMLIB_ZDelayTimer	access:public	signature:(ZDelayTimer *p)
simlib3::SIMLIB_ZDelayTimer::container	zdelay.cc	/^    static container_t *container;      \/\/ list of delay objects -- singleton$/;"	m	class:simlib3::SIMLIB_ZDelayTimer	file:	access:private
simlib3::SIMLIB_ZDelayTimer::container	zdelay.cc	/^SIMLIB_ZDelayTimer::container_t * SIMLIB_ZDelayTimer::container = 0;$/;"	m	class:simlib3::SIMLIB_ZDelayTimer	file:
simlib3::SIMLIB_ZDelayTimer::container_t	zdelay.cc	/^    typedef std::list<ZDelayTimer *> container_t; \/\/ type of container we use$/;"	t	class:simlib3::SIMLIB_ZDelayTimer	file:	access:private
simlib3::SIMLIB_atexit	atexit.cc	/^void SIMLIB_atexit(SIMLIB_atexit_function_t p) {$/;"	f	namespace:simlib3	signature:(SIMLIB_atexit_function_t p)
simlib3::SIMLIB_atexit	internal.h	/^void SIMLIB_atexit(SIMLIB_atexit_function_t p);$/;"	p	namespace:simlib3	signature:(SIMLIB_atexit_function_t p)
simlib3::SIMLIB_atexit_call	atexit.cc	/^static void SIMLIB_atexit_call() {$/;"	f	namespace:simlib3	signature:()
simlib3::SIMLIB_atexit_function_t	internal.h	/^typedef void (*SIMLIB_atexit_function_t)();$/;"	t	namespace:simlib3
simlib3::SIMLIB_create_tmp_name	internal.h	/^const char *SIMLIB_create_tmp_name(const char *fmt, ...);$/;"	p	namespace:simlib3	signature:(const char *fmt, ...)
simlib3::SIMLIB_create_tmp_name	name.cc	/^const char *SIMLIB_create_tmp_name(const char *fmt, ...)$/;"	f	namespace:simlib3	signature:(const char *fmt, ...)
simlib3::SIMLIB_debug_flag	debug.cc	/^unsigned long SIMLIB_debug_flag = 0UL; \/\/ default = no debugging$/;"	m	namespace:simlib3	file:
simlib3::SIMLIB_error	error.cc	/^void SIMLIB_error(const char *fmt, ... )$/;"	f	namespace:simlib3	signature:(const char *fmt, ... )
simlib3::SIMLIB_error	error.cc	/^void SIMLIB_error(const char*filename, const int linenum)$/;"	f	namespace:simlib3	signature:(const char*filename, const int linenum)
simlib3::SIMLIB_error	error.cc	/^void SIMLIB_error(const enum _ErrEnum N)$/;"	f	namespace:simlib3	signature:(const enum _ErrEnum N)
simlib3::SIMLIB_error	internal.h	/^void SIMLIB_error(const char *file, const int line);$/;"	p	namespace:simlib3	signature:(const char *file, const int line)
simlib3::SIMLIB_error	internal.h	/^void SIMLIB_error(const char *fmt, ... );$/;"	p	namespace:simlib3	signature:(const char *fmt, ... )
simlib3::SIMLIB_error	internal.h	/^void SIMLIB_error(const enum _ErrEnum ErrMsgNum);$/;"	p	namespace:simlib3	signature:(const enum _ErrEnum ErrMsgNum)
simlib3::SIMLIB_experiment_no	run.cc	/^unsigned long SIMLIB_experiment_no = 0;$/;"	m	namespace:simlib3	file:
simlib3::SIMLIB_module	internal.h	/^class SIMLIB_module { \/\/ internal class for SIMLIB cleanup (atexit)$/;"	c	namespace:simlib3
simlib3::SIMLIB_module::Init	atexit.cc	/^int SIMLIB_module::Init(const char *s) {$/;"	f	class:simlib3::SIMLIB_module	signature:(const char *s)
simlib3::SIMLIB_module::Init	internal.h	/^  int Init(const char *s);$/;"	p	class:simlib3::SIMLIB_module	access:public	signature:(const char *s)
simlib3::SIMLIB_module::SIMLIB_module	atexit.cc	/^SIMLIB_module::SIMLIB_module():$/;"	f	class:simlib3::SIMLIB_module	signature:()
simlib3::SIMLIB_module::SIMLIB_module	internal.h	/^  SIMLIB_module();$/;"	p	class:simlib3::SIMLIB_module	access:public	signature:()
simlib3::SIMLIB_module::SIMLIB_module	internal.h	/^  SIMLIB_module(const SIMLIB_module&); \/\/ disable copy-ctr$/;"	p	class:simlib3::SIMLIB_module	access:private	signature:(const SIMLIB_module&)
simlib3::SIMLIB_module::operator =	internal.h	/^  SIMLIB_module &operator= (const SIMLIB_module&); \/\/ disable =$/;"	p	class:simlib3::SIMLIB_module	access:private	signature:(const SIMLIB_module&)
simlib3::SIMLIB_module::string	internal.h	/^  const char *string; \/\/ module identification string$/;"	m	class:simlib3::SIMLIB_module	access:private
simlib3::SIMLIB_module::~SIMLIB_module	atexit.cc	/^SIMLIB_module::~SIMLIB_module() {$/;"	f	class:simlib3::SIMLIB_module	signature:()
simlib3::SIMLIB_module::~SIMLIB_module	internal.h	/^  ~SIMLIB_module(); \/\/ last can do ATEXIT ?$/;"	p	class:simlib3::SIMLIB_module	access:public	signature:()
simlib3::SIMLIB_module_id	internal.h	/^static SIMLIB_module SIMLIB_module_id;$/;"	m	namespace:simlib3
simlib3::SIMLIB_old_debug_flags	simlib.h	/^static unsigned long SIMLIB_old_debug_flags = Debug(SIMLIB_DEBUG);$/;"	m	namespace:simlib3
simlib3::SIMLIB_run_statistics	run.cc	/^static SIMLIB_statistics_t SIMLIB_run_statistics;$/;"	m	namespace:simlib3	file:
simlib3::SIMLIB_statistics	run.cc	/^const SIMLIB_statistics_t &SIMLIB_statistics = SIMLIB_run_statistics;$/;"	m	namespace:simlib3	file:
simlib3::SIMLIB_statistics_t	simlib.h	/^struct SIMLIB_statistics_t {$/;"	s	namespace:simlib3
simlib3::SIMLIB_statistics_t::EndTime	simlib.h	/^  double EndTime;$/;"	m	struct:simlib3::SIMLIB_statistics_t	access:public
simlib3::SIMLIB_statistics_t::EventCount	simlib.h	/^  long   EventCount;    \/\/ for discrete simulation$/;"	m	struct:simlib3::SIMLIB_statistics_t	access:public
simlib3::SIMLIB_statistics_t::Init	run.cc	/^void SIMLIB_statistics_t::Init() {$/;"	f	class:simlib3::SIMLIB_statistics_t	signature:()
simlib3::SIMLIB_statistics_t::Init	simlib.h	/^  void Init();$/;"	p	struct:simlib3::SIMLIB_statistics_t	access:public	signature:()
simlib3::SIMLIB_statistics_t::MaxStep	simlib.h	/^  double MaxStep;$/;"	m	struct:simlib3::SIMLIB_statistics_t	access:public
simlib3::SIMLIB_statistics_t::MinStep	simlib.h	/^  double MinStep;$/;"	m	struct:simlib3::SIMLIB_statistics_t	access:public
simlib3::SIMLIB_statistics_t::Output	output1.cc	/^void SIMLIB_statistics_t::Output() const$/;"	f	class:simlib3::SIMLIB_statistics_t	signature:() const
simlib3::SIMLIB_statistics_t::Output	simlib.h	/^  void Output() const;$/;"	p	struct:simlib3::SIMLIB_statistics_t	access:public	signature:() const
simlib3::SIMLIB_statistics_t::SIMLIB_statistics_t	run.cc	/^SIMLIB_statistics_t::SIMLIB_statistics_t() {$/;"	f	class:simlib3::SIMLIB_statistics_t	signature:()
simlib3::SIMLIB_statistics_t::SIMLIB_statistics_t	simlib.h	/^  SIMLIB_statistics_t();$/;"	p	struct:simlib3::SIMLIB_statistics_t	access:public	signature:()
simlib3::SIMLIB_statistics_t::StartTime	simlib.h	/^  double StartTime;$/;"	m	struct:simlib3::SIMLIB_statistics_t	access:public
simlib3::SIMLIB_statistics_t::StepCount	simlib.h	/^  long   StepCount;     \/\/ for continuous simulation$/;"	m	struct:simlib3::SIMLIB_statistics_t	access:public
simlib3::SIMLIB_version	version.cc	/^const unsigned SIMLIB_version = __SIMLIB__;  \/\/!< library version$/;"	m	namespace:simlib3	file:
simlib3::SIMLIB_version_string	simlib.h	/^const char *SIMLIB_version_string();    \/\/ get SIMLIB version string$/;"	p	namespace:simlib3	signature:()
simlib3::SIMLIB_version_string	version.cc	/^const char *SIMLIB_version_string() {$/;"	f	namespace:simlib3	signature:()
simlib3::SIMLIB_warning	error.cc	/^void SIMLIB_warning( const enum _ErrEnum N )$/;"	f	namespace:simlib3	signature:( const enum _ErrEnum N )
simlib3::SIMLIB_warning	error.cc	/^void SIMLIB_warning(const char *fmt, ... )$/;"	f	namespace:simlib3	signature:(const char *fmt, ... )
simlib3::SIMLIB_warning	internal.h	/^void SIMLIB_warning(const char *fmt, ... );$/;"	p	namespace:simlib3	signature:(const char *fmt, ... )
simlib3::SIMLIB_warning	internal.h	/^void SIMLIB_warning(const enum _ErrEnum ErrMsgNum);$/;"	p	namespace:simlib3	signature:(const enum _ErrEnum ErrMsgNum)
simlib3::SIMULATION	internal.h	/^    SIMULATION,     \/\/ inside Run() call$/;"	e	enum:simlib3::SIMLIB_Phase_t
simlib3::SQS	internal.h	/^namespace SQS {$/;"	n	namespace:simlib3
simlib3::SQS::Clear	calendar.cc	/^void SQS::Clear() {                       \/\/ remove all$/;"	f	class:simlib3::SQS	signature:()
simlib3::SQS::Clear	internal.h	/^    void Clear();                        \/\/ remove all items$/;"	p	namespace:simlib3::SQS	signature:()
simlib3::SQS::Empty	calendar.cc	/^bool SQS::Empty() {                       \/\/ used by Run() only$/;"	f	class:simlib3::SQS	signature:()
simlib3::SQS::Empty	internal.h	/^    bool Empty();                        \/\/ ?empty calendar$/;"	p	namespace:simlib3::SQS	signature:()
simlib3::SQS::Get	calendar.cc	/^void SQS::Get(Entity *e) {             \/\/ used by Run() only$/;"	f	class:simlib3::SQS	signature:(Entity *e)
simlib3::SQS::Get	internal.h	/^    void Get(Entity *e);                 \/\/ remove entity e$/;"	p	namespace:simlib3::SQS	signature:(Entity *e)
simlib3::SQS::GetFirst	calendar.cc	/^Entity *SQS::GetFirst() {                  \/\/ used by Run()$/;"	f	class:simlib3::SQS	signature:()
simlib3::SQS::GetFirst	internal.h	/^    Entity *GetFirst();                  \/\/ remove first item$/;"	p	namespace:simlib3::SQS	signature:()
simlib3::SQS::ScheduleAt	calendar.cc	/^void SQS::ScheduleAt(Entity *e, double t) { \/\/ used by scheduling operations$/;"	f	class:simlib3::SQS	signature:(Entity *e, double t)
simlib3::SQS::ScheduleAt	internal.h	/^    void ScheduleAt(Entity *e, double t);\/\/ time t$/;"	p	namespace:simlib3::SQS	signature:(Entity *e, double t)
simlib3::SQS::debug_print	calendar.cc	/^int SQS::debug_print() {                 \/\/ for debugging only$/;"	f	class:simlib3::SQS	signature:()
simlib3::SQS::debug_print	internal.h	/^    int debug_print();$/;"	p	namespace:simlib3::SQS	signature:()
simlib3::START	internal.h	/^    START,          \/\/ before first Init() call$/;"	e	enum:simlib3::SIMLIB_Phase_t
simlib3::SampleDelays	run.cc	/^void SampleDelays() { \/\/ used at step-wise changes !!!###$/;"	f	namespace:simlib3	signature:()
simlib3::Sampler	simlib.h	/^class Sampler: public Event {$/;"	c	namespace:simlib3	inherits:Event
simlib3::Sampler::ActivateAll	sampler.cc	/^void Sampler::ActivateAll()$/;"	f	class:simlib3::Sampler	signature:()
simlib3::Sampler::ActivateAll	simlib.h	/^    static void ActivateAll();      \/\/!< start all samplers (Run)$/;"	p	class:simlib3::Sampler	access:private	signature:()
simlib3::Sampler::Behavior	sampler.cc	/^void Sampler::Behavior() {$/;"	f	class:simlib3::Sampler	signature:()
simlib3::Sampler::Behavior	simlib.h	/^    virtual void Behavior(); \/\/!< behavior description$/;"	p	class:simlib3::Sampler	access:protected	signature:()
simlib3::Sampler::First	sampler.cc	/^Sampler *Sampler::First = 0;$/;"	m	class:simlib3::Sampler	file:
simlib3::Sampler::First	simlib.h	/^    static Sampler *First;              \/\/ list of objects TODO: use container$/;"	m	class:simlib3::Sampler	access:private
simlib3::Sampler::GetStep	simlib.h	/^    double GetStep() const { return step; } \/\/!< get current step$/;"	f	class:simlib3::Sampler	access:public	signature:() const
simlib3::Sampler::InitAll	sampler.cc	/^void Sampler::InitAll() {$/;"	f	class:simlib3::Sampler	signature:()
simlib3::Sampler::InitAll	simlib.h	/^    static void InitAll();          \/\/!< initialize all samplers (Init)$/;"	p	class:simlib3::Sampler	access:private	signature:()
simlib3::Sampler::Next	simlib.h	/^    Sampler *Next;                      \/\/ next object$/;"	m	class:simlib3::Sampler	access:private
simlib3::Sampler::Output	sampler.cc	/^void Sampler::Output() const$/;"	f	class:simlib3::Sampler	signature:() const
simlib3::Sampler::Output	simlib.h	/^    virtual void Output() const;          \/\/!< print object to default output$/;"	p	class:simlib3::Sampler	access:public	signature:() const
simlib3::Sampler::Sample	sampler.cc	/^void Sampler::Sample()$/;"	f	class:simlib3::Sampler	signature:()
simlib3::Sampler::Sample	simlib.h	/^    void Sample();                  \/\/!< performs sample (function call)$/;"	p	class:simlib3::Sampler	access:public	signature:()
simlib3::Sampler::Sampler	sampler.cc	/^Sampler::Sampler(void(*pf)(), double dt) :$/;"	f	class:simlib3::Sampler	signature:(void(*pf)(), double dt)
simlib3::Sampler::Sampler	simlib.h	/^    Sampler(const Sampler&);            \/\/## disable$/;"	p	class:simlib3::Sampler	access:private	signature:(const Sampler&)
simlib3::Sampler::Sampler	simlib.h	/^    Sampler(void (*pf)(), double dt=0.0);$/;"	p	class:simlib3::Sampler	access:public	signature:(void (*pf)(), double dt=0.0)
simlib3::Sampler::SetStep	sampler.cc	/^double Sampler::SetStep(double dt)$/;"	f	class:simlib3::Sampler	signature:(double dt)
simlib3::Sampler::SetStep	simlib.h	/^    double SetStep(double dt=0.0);  \/\/!< change step$/;"	p	class:simlib3::Sampler	access:public	signature:(double dt=0.0)
simlib3::Sampler::Start	sampler.cc	/^void Sampler::Start()$/;"	f	class:simlib3::Sampler	signature:()
simlib3::Sampler::Start	simlib.h	/^    void Start();                   \/\/!< start + sample$/;"	p	class:simlib3::Sampler	access:public	signature:()
simlib3::Sampler::Stop	sampler.cc	/^void Sampler::Stop()$/;"	f	class:simlib3::Sampler	signature:()
simlib3::Sampler::Stop	simlib.h	/^    void Stop();                    \/\/!< sample + stop$/;"	p	class:simlib3::Sampler	access:public	signature:()
simlib3::Sampler::function	simlib.h	/^    void (*function)(); \/\/!< function to call periodically$/;"	m	class:simlib3::Sampler	access:protected
simlib3::Sampler::last	simlib.h	/^    double last;        \/\/!< last sample time -- prevents sample duplication$/;"	m	class:simlib3::Sampler	access:protected
simlib3::Sampler::on	simlib.h	/^    bool on;            \/\/!< switch on\/off$/;"	m	class:simlib3::Sampler	access:protected
simlib3::Sampler::operator =	simlib.h	/^    Sampler&operator=(const Sampler&);  \/\/## disable$/;"	p	class:simlib3::Sampler	access:private	signature:(const Sampler&)
simlib3::Sampler::step	simlib.h	/^    double step;        \/\/!< step of sampling$/;"	m	class:simlib3::Sampler	access:protected
simlib3::Sampler::~Sampler	sampler.cc	/^Sampler::~Sampler()$/;"	f	class:simlib3::Sampler	signature:()
simlib3::Sampler::~Sampler	simlib.h	/^    virtual ~Sampler();$/;"	p	class:simlib3::Sampler	access:public	signature:()
simlib3::ScalarProduct	simlib2D.cc	/^Input ScalarProduct(Input2D x, Input2D y) { return new _ScalarProduct2D(x,y); }$/;"	f	namespace:simlib3	signature:(Input2D x, Input2D y)
simlib3::ScalarProduct	simlib2D.h	/^Input ScalarProduct(Input2D x, Input2D y);$/;"	p	namespace:simlib3	signature:(Input2D x, Input2D y)
simlib3::ScalarProduct	simlib3D.cc	/^Input ScalarProduct(Input3D x, Input3D y) { return new _ScalarProduct3D(x,y); }$/;"	f	namespace:simlib3	signature:(Input3D x, Input3D y)
simlib3::ScalarProduct	simlib3D.h	/^Input   ScalarProduct(Input3D x, Input3D y);$/;"	p	namespace:simlib3	signature:(Input3D x, Input3D y)
simlib3::Semaphore	simlib.h	/^class Semaphore : public SimObject {$/;"	c	namespace:simlib3	inherits:SimObject
simlib3::Semaphore::Clear	semaphor.cc	/^void Semaphore::Clear() {$/;"	f	class:simlib3::Semaphore	signature:()
simlib3::Semaphore::Clear	simlib.h	/^  virtual void Clear();                         \/\/!< initialization$/;"	p	class:simlib3::Semaphore	access:public	signature:()
simlib3::Semaphore::Output	semaphor.cc	/^void Semaphore::Output() const {$/;"	f	class:simlib3::Semaphore	signature:() const
simlib3::Semaphore::Output	simlib.h	/^  virtual void Output() const;$/;"	p	class:simlib3::Semaphore	access:public	signature:() const
simlib3::Semaphore::P	semaphor.cc	/^void Semaphore::P()$/;"	f	class:simlib3::Semaphore	signature:()
simlib3::Semaphore::P	simlib.h	/^  virtual void P();                             \/\/!< P operation$/;"	p	class:simlib3::Semaphore	access:public	signature:()
simlib3::Semaphore::Q	simlib.h	/^  Queue Q;                                      \/\/!< internal quqeue$/;"	m	class:simlib3::Semaphore	access:public
simlib3::Semaphore::Semaphore	semaphor.cc	/^Semaphore::Semaphore()$/;"	f	class:simlib3::Semaphore	signature:()
simlib3::Semaphore::Semaphore	semaphor.cc	/^Semaphore::Semaphore(const char *name)$/;"	f	class:simlib3::Semaphore	signature:(const char *name)
simlib3::Semaphore::Semaphore	simlib.h	/^  Semaphore();                                  \/\/ constructor$/;"	p	class:simlib3::Semaphore	access:public	signature:()
simlib3::Semaphore::Semaphore	simlib.h	/^  Semaphore(const char *_name);                 \/\/ with associated name$/;"	p	class:simlib3::Semaphore	access:public	signature:(const char *_name)
simlib3::Semaphore::V	semaphor.cc	/^void Semaphore::V()$/;"	f	class:simlib3::Semaphore	signature:()
simlib3::Semaphore::V	simlib.h	/^  virtual void V();                             \/\/!< V operation$/;"	p	class:simlib3::Semaphore	access:public	signature:()
simlib3::Semaphore::n	simlib.h	/^  int n;$/;"	m	class:simlib3::Semaphore	access:protected
simlib3::Semaphore::operator Semaphore*	simlib.h	/^  operator Semaphore* () { return this; }$/;"	f	class:simlib3::Semaphore	access:public	signature:()
simlib3::Semaphore::~Semaphore	semaphor.cc	/^Semaphore::~Semaphore()$/;"	f	class:simlib3::Semaphore	signature:()
simlib3::Semaphore::~Semaphore	simlib.h	/^  virtual ~Semaphore();$/;"	p	class:simlib3::Semaphore	access:public	signature:()
simlib3::ServicePriority_t	simlib.h	/^typedef unsigned char ServicePriority_t;$/;"	t	namespace:simlib3
simlib3::SetAccuracy	intg.cc	/^void SetAccuracy(double _abserr, double _relerr)$/;"	f	namespace:simlib3	signature:(double _abserr, double _relerr)
simlib3::SetAccuracy	intg.cc	/^void SetAccuracy(double relerr)$/;"	f	namespace:simlib3	signature:(double relerr)
simlib3::SetAccuracy	simlib.h	/^void SetAccuracy(double abserr, double relerr);$/;"	p	namespace:simlib3	signature:(double abserr, double relerr)
simlib3::SetAccuracy	simlib.h	/^void SetAccuracy(double relerr);$/;"	p	namespace:simlib3	signature:(double relerr)
simlib3::SetBaseRandomGenerator	random1.cc	/^void   SetBaseRandomGenerator(double (*new_gen)()); \/\/ change base gen.$/;"	p	namespace:simlib3	file:	signature:(double (*new_gen)())
simlib3::SetBaseRandomGenerator	random1.cc	/^void SetBaseRandomGenerator(double (*new_gen)())$/;"	f	namespace:simlib3	signature:(double (*new_gen)())
simlib3::SetBaseRandomGenerator	simlib.h	/^void   SetBaseRandomGenerator(double (*new_gen)());$/;"	p	namespace:simlib3	signature:(double (*new_gen)())
simlib3::SetCalendar	calendar.cc	/^void SetCalendar(const char *name) {$/;"	f	namespace:simlib3	signature:(const char *name)
simlib3::SetCalendar	simlib.h	/^void SetCalendar(const char *name);$/;"	p	namespace:simlib3	signature:(const char *name)
simlib3::SetMethod	simlib.h	/^inline void SetMethod(const char* name)$/;"	f	namespace:simlib3	signature:(const char* name)
simlib3::SetName	name.cc	/^void SetName(SimObject & o, const char *name)$/;"	f	namespace:simlib3	signature:(SimObject & o, const char *name)
simlib3::SetName	name.cc	/^void SetName(SimObject * o, const char *name)$/;"	f	namespace:simlib3	signature:(SimObject * o, const char *name)
simlib3::SetName	simlib.h	/^void SetName(SimObject &o, const char *name);$/;"	p	namespace:simlib3	signature:(SimObject &o, const char *name)
simlib3::SetName	simlib.h	/^void SetName(SimObject *o, const char *name);$/;"	p	namespace:simlib3	signature:(SimObject *o, const char *name)
simlib3::SetOutput	print.cc	/^void SetOutput(const char *name)$/;"	f	namespace:simlib3	signature:(const char *name)
simlib3::SetOutput	simlib.h	/^void SetOutput(const char *name);$/;"	p	namespace:simlib3	signature:(const char *name)
simlib3::SetStarter	simlib.h	/^inline void SetStarter(const char* name, const char* slave_name)$/;"	f	namespace:simlib3	signature:(const char* name, const char* slave_name)
simlib3::SetStarter	simlib.h	/^inline void SetStarter(const char* slave_name)$/;"	f	namespace:simlib3	signature:(const char* slave_name)
simlib3::SetStep	intg.cc	/^void SetStep(double _dtmin, double _dtmax)$/;"	f	namespace:simlib3	signature:(double _dtmin, double _dtmax)
simlib3::SetStep	simlib.h	/^inline void SetStep(double dt) { SetStep(dt,dt); }$/;"	f	namespace:simlib3	signature:(double dt)
simlib3::SetStep	simlib.h	/^void SetStep(double dtmin, double dtmax);$/;"	p	namespace:simlib3	signature:(double dtmin, double dtmax)
simlib3::Sign	fun.cc	/^Input Sign(Input x)             { return new Function1(x, sign); }$/;"	f	namespace:simlib3	signature:(Input x)
simlib3::Sign	simlib.h	/^Input Sign(Input x);            \/\/ signum  ###warning-steps-not-detected$/;"	p	namespace:simlib3	signature:(Input x)
simlib3::SimObject	simlib.h	/^class SimObject {$/;"	c	namespace:simlib3
simlib3::SimObject::HasName	simlib.h	/^  bool HasName() const { return _name !=0; }$/;"	f	class:simlib3::SimObject	access:public	signature:() const
simlib3::SimObject::Name	object.cc	/^const char *SimObject::Name() const$/;"	f	class:simlib3::SimObject	signature:() const
simlib3::SimObject::Name	simlib.h	/^  virtual const char *Name() const;    \/\/!< get object name$/;"	p	class:simlib3::SimObject	access:public	signature:() const
simlib3::SimObject::Output	object.cc	/^void SimObject::Output() const$/;"	f	class:simlib3::SimObject	signature:() const
simlib3::SimObject::Output	simlib.h	/^  virtual void Output() const;         \/\/!< print object to default output$/;"	p	class:simlib3::SimObject	access:public	signature:() const
simlib3::SimObject::SetName	object.cc	/^void SimObject::SetName(const char *name)$/;"	f	class:simlib3::SimObject	signature:(const char *name)
simlib3::SimObject::SetName	simlib.h	/^  void SetName(const char *name);      \/\/!< assign the name$/;"	p	class:simlib3::SimObject	access:public	signature:(const char *name)
simlib3::SimObject::SimObject	object.cc	/^SimObject::SimObject() :$/;"	f	class:simlib3::SimObject	signature:()
simlib3::SimObject::SimObject	simlib.h	/^  SimObject();$/;"	p	class:simlib3::SimObject	access:public	signature:()
simlib3::SimObject::SimObject	simlib.h	/^  SimObject(SimObject&);               \/\/!< disabled operation$/;"	p	class:simlib3::SimObject	access:private	signature:(SimObject&)
simlib3::SimObject::TestAndSetFlag	internal.h	/^inline bool SimObject::TestAndSetFlag(bool new_value, unsigned n) {$/;"	f	class:simlib3::SimObject	signature:(bool new_value, unsigned n)
simlib3::SimObject::TestAndSetFlag	simlib.h	/^  bool TestAndSetFlag(bool new_value, unsigned n);$/;"	p	class:simlib3::SimObject	access:public	signature:(bool new_value, unsigned n)
simlib3::SimObject::_ALLOCATED_FLAG	simlib.h	/^  enum _Flags { _ALLOCATED_FLAG = 1, _EVAL_FLAG = 2 }; \/\/!< internal flags$/;"	e	enum:simlib3::SimObject::_Flags
simlib3::SimObject::_EVAL_FLAG	simlib.h	/^  enum _Flags { _ALLOCATED_FLAG = 1, _EVAL_FLAG = 2 }; \/\/!< internal flags$/;"	e	enum:simlib3::SimObject::_Flags
simlib3::SimObject::_Flags	simlib.h	/^  enum _Flags { _ALLOCATED_FLAG = 1, _EVAL_FLAG = 2 }; \/\/!< internal flags$/;"	g	class:simlib3::SimObject	access:public
simlib3::SimObject::_flags	simlib.h	/^  unsigned     _flags;$/;"	m	class:simlib3::SimObject	access:protected
simlib3::SimObject::_name	simlib.h	/^  const char * _name;$/;"	m	class:simlib3::SimObject	access:protected
simlib3::SimObject::isAllocated	simlib.h	/^  bool isAllocated() const { return (_flags >> _ALLOCATED_FLAG)&1; }$/;"	f	class:simlib3::SimObject	access:public	signature:() const
simlib3::SimObject::operator =	simlib.h	/^  void operator= (SimObject&);         \/\/!< disabled operation$/;"	p	class:simlib3::SimObject	access:private	signature:(SimObject&)
simlib3::SimObject::operator delete	object.cc	/^void SimObject::operator delete(void *ptr) {$/;"	f	class:simlib3::SimObject	signature:(void *ptr)
simlib3::SimObject::operator delete	simlib.h	/^  void operator delete(void *ptr);     \/\/!< deallocate object$/;"	p	class:simlib3::SimObject	access:public	signature:(void *ptr)
simlib3::SimObject::operator new	object.cc	/^void *SimObject::operator new(size_t size) {$/;"	f	class:simlib3::SimObject	signature:(size_t size)
simlib3::SimObject::operator new	simlib.h	/^  void *operator new(size_t size);     \/\/!< allocate object, set _flags$/;"	p	class:simlib3::SimObject	access:public	signature:(size_t size)
simlib3::SimObject::~SimObject	object.cc	/^SimObject::~SimObject()$/;"	f	class:simlib3::SimObject	signature:()
simlib3::SimObject::~SimObject	simlib.h	/^  virtual ~SimObject();$/;"	p	class:simlib3::SimObject	access:public	signature:()
simlib3::SimObject_allocated	object.cc	/^static bool SimObject_allocated = false;$/;"	m	namespace:simlib3	file:
simlib3::Sin	fun.cc	/^Input Sin(Input x)              { return new Function1(x, sin); }$/;"	f	namespace:simlib3	signature:(Input x)
simlib3::Sin	simlib.h	/^Input Sin(Input x);             \/\/ sin(x)$/;"	p	namespace:simlib3	signature:(Input x)
simlib3::SingleStepMethod	simlib.h	/^class SingleStepMethod : public IntegrationMethod {$/;"	c	namespace:simlib3	inherits:IntegrationMethod
simlib3::SingleStepMethod::Integrate	simlib.h	/^  virtual void Integrate(void) = 0;  \/\/ the method does integration$/;"	p	class:simlib3::SingleStepMethod	access:public	signature:(void)
simlib3::SingleStepMethod::IsSingleStep	simlib.h	/^  virtual bool IsSingleStep(void) {  \/\/ it's a single-step method$/;"	f	class:simlib3::SingleStepMethod	access:public	signature:(void)
simlib3::SingleStepMethod::IsStartMode	simlib.h	/^  bool IsStartMode(void) {  \/\/ is method used to start multi-step method?$/;"	f	class:simlib3::SingleStepMethod	access:public	signature:(void)
simlib3::SingleStepMethod::SetStartMode	simlib.h	/^  void SetStartMode(bool start_mode) {  \/\/ set flag on\/off$/;"	f	class:simlib3::SingleStepMethod	access:public	signature:(bool start_mode)
simlib3::SingleStepMethod::SingleStepMethod	simlib.h	/^  SingleStepMethod(const char* name) :  \/\/ initialize method and registrate it$/;"	f	class:simlib3::SingleStepMethod	access:public	signature:(const char* name)
simlib3::SingleStepMethod::StartMode	simlib.h	/^  bool StartMode;$/;"	m	class:simlib3::SingleStepMethod	access:private
simlib3::Sqr	continuous.cc	/^Input Sqr(Input x) { return new _Mul(x,x); }$/;"	f	namespace:simlib3	signature:(Input x)
simlib3::Sqr	simlib.h	/^Input Sqr(Input x);             \/\/ square     x * x$/;"	p	namespace:simlib3	signature:(Input x)
simlib3::Sqrt	fun.cc	/^Input Sqrt(Input x)             { return new Function1(x, sqrt); }$/;"	f	namespace:simlib3	signature:(Input x)
simlib3::Sqrt	simlib.h	/^Input Sqrt(Input x);            \/\/ square root$/;"	p	namespace:simlib3	signature:(Input x)
simlib3::StartTime	run.cc	/^const double & StartTime = SIMLIB_StartTime;    \/\/ time of simulation start$/;"	m	namespace:simlib3	file:
simlib3::Stat	simlib.h	/^class Stat : public SimObject {$/;"	c	namespace:simlib3	inherits:SimObject
simlib3::Stat::Clear	simlib.h	/^  virtual void Clear();         \/\/!< initialize$/;"	p	class:simlib3::Stat	access:public	signature:()
simlib3::Stat::Clear	stat.cc	/^void Stat::Clear()$/;"	f	class:simlib3::Stat	signature:()
simlib3::Stat::Max	simlib.h	/^  double Max() const           { \/* test n==0 *\/ return max; }$/;"	f	class:simlib3::Stat	access:public	signature:() const
simlib3::Stat::MeanValue	simlib.h	/^  double MeanValue() const;$/;"	p	class:simlib3::Stat	access:public	signature:() const
simlib3::Stat::MeanValue	stat.cc	/^double Stat::MeanValue() const$/;"	f	class:simlib3::Stat	signature:() const
simlib3::Stat::Min	simlib.h	/^  double Min() const           { \/* TODO: test n==0 *\/ return min; }$/;"	f	class:simlib3::Stat	access:public	signature:() const
simlib3::Stat::Number	simlib.h	/^  unsigned long Number() const { return n; }$/;"	f	class:simlib3::Stat	access:public	signature:() const
simlib3::Stat::Output	output2.cc	/^void Stat::Output() const$/;"	f	class:simlib3::Stat	signature:() const
simlib3::Stat::Output	simlib.h	/^  virtual void Output() const;  \/\/!< print statistics$/;"	p	class:simlib3::Stat	access:public	signature:() const
simlib3::Stat::Stat	simlib.h	/^  Stat();$/;"	p	class:simlib3::Stat	access:public	signature:()
simlib3::Stat::Stat	simlib.h	/^  Stat(const char *name);$/;"	p	class:simlib3::Stat	access:public	signature:(const char *name)
simlib3::Stat::Stat	stat.cc	/^Stat::Stat() :$/;"	f	class:simlib3::Stat	signature:()
simlib3::Stat::Stat	stat.cc	/^Stat::Stat(const char *name) :$/;"	f	class:simlib3::Stat	signature:(const char *name)
simlib3::Stat::StdDev	simlib.h	/^  double StdDev() const;$/;"	p	class:simlib3::Stat	access:public	signature:() const
simlib3::Stat::StdDev	stat.cc	/^double Stat::StdDev() const$/;"	f	class:simlib3::Stat	signature:() const
simlib3::Stat::Sum	simlib.h	/^  double Sum() const           { return sx; }$/;"	f	class:simlib3::Stat	access:public	signature:() const
simlib3::Stat::SumSquare	simlib.h	/^  double SumSquare() const     { return sx2; }$/;"	f	class:simlib3::Stat	access:public	signature:() const
simlib3::Stat::max	simlib.h	/^  double max;                   \/\/ max value$/;"	m	class:simlib3::Stat	access:protected
simlib3::Stat::min	simlib.h	/^  double min;                   \/\/ min value$/;"	m	class:simlib3::Stat	access:protected
simlib3::Stat::n	simlib.h	/^  unsigned long n;              \/\/ number of values recorded$/;"	m	class:simlib3::Stat	access:protected
simlib3::Stat::operator ()	simlib.h	/^  void operator () (double x);  \/\/!< record the value$/;"	p	class:simlib3::Stat	access:public	signature:(double x)
simlib3::Stat::operator ()	stat.cc	/^void Stat::operator () (double x)$/;"	f	class:simlib3::Stat	signature:(double x)
simlib3::Stat::sx	simlib.h	/^  double sx;                    \/\/ sum of values$/;"	m	class:simlib3::Stat	access:protected
simlib3::Stat::sx2	simlib.h	/^  double sx2;                   \/\/ sum of value square$/;"	m	class:simlib3::Stat	access:protected
simlib3::Stat::~Stat	simlib.h	/^  ~Stat();$/;"	p	class:simlib3::Stat	access:public	signature:()
simlib3::Stat::~Stat	stat.cc	/^Stat::~Stat()$/;"	f	class:simlib3::Stat	signature:()
simlib3::Status	simlib.h	/^class Status : public aContiBlock1 {   \/\/ state-variables$/;"	c	namespace:simlib3	inherits:aContiBlock1
simlib3::Status::CtrInit	intg.cc	/^void Status::CtrInit() {$/;"	f	class:simlib3::Status	signature:()
simlib3::Status::CtrInit	simlib.h	/^  void CtrInit();$/;"	p	class:simlib3::Status	access:protected	signature:()
simlib3::Status::Eval	intg.cc	/^void Status::Eval()$/;"	f	class:simlib3::Status	signature:()
simlib3::Status::Eval	simlib.h	/^  virtual void Eval();                 \/\/ block evaluation$/;"	p	class:simlib3::Status	access:public	signature:()
simlib3::Status::GetOldState	simlib.h	/^  double GetOldState(void) { return stl; }$/;"	f	class:simlib3::Status	access:public	signature:(void)
simlib3::Status::GetState	simlib.h	/^  double GetState(void) { return st; }$/;"	f	class:simlib3::Status	access:public	signature:(void)
simlib3::Status::Init	intg.cc	/^void Status::Init(double initvalue)$/;"	f	class:simlib3::Status	signature:(double initvalue)
simlib3::Status::Init	simlib.h	/^  void Init() { Init(initval); }$/;"	f	class:simlib3::Status	access:public	signature:()
simlib3::Status::Init	simlib.h	/^  void Init(double initvalue);         \/\/ value initialization$/;"	p	class:simlib3::Status	access:public	signature:(double initvalue)
simlib3::Status::Name	intg.cc	/^const char *Status::Name() const$/;"	f	class:simlib3::Status	signature:() const
simlib3::Status::Name	simlib.h	/^  virtual const char *Name() const;$/;"	p	class:simlib3::Status	access:public	signature:() const
simlib3::Status::Restore	intg.cc	/^void Status::Restore()$/;"	f	class:simlib3::Status	signature:()
simlib3::Status::Restore	simlib.h	/^  void Restore();                      \/\/ restore saved status$/;"	p	class:simlib3::Status	access:public	signature:()
simlib3::Status::Save	simlib.h	/^  void Save() { stl = st; }            \/\/ save status$/;"	f	class:simlib3::Status	access:public	signature:()
simlib3::Status::Set	intg.cc	/^void Status::Set(double value)$/;"	f	class:simlib3::Status	signature:(double value)
simlib3::Status::Set	simlib.h	/^  void Set(double value);              \/\/ set status of block$/;"	p	class:simlib3::Status	access:public	signature:(double value)
simlib3::Status::SetOldState	simlib.h	/^  void SetOldState(double s) { stl=s; }$/;"	f	class:simlib3::Status	access:public	signature:(double s)
simlib3::Status::SetState	simlib.h	/^  void SetState(double s) { st=s; }$/;"	f	class:simlib3::Status	access:public	signature:(double s)
simlib3::Status::SetValid	simlib.h	/^  void SetValid(bool flag) { ValueOK = flag; } \/\/ set valid flag$/;"	f	class:simlib3::Status	access:public	signature:(bool flag)
simlib3::Status::Status	intg.cc	/^Status::Status(Input i, double initvalue): aContiBlock1(i)$/;"	f	class:simlib3::Status	signature:(Input i, double initvalue)
simlib3::Status::Status	simlib.h	/^  Status(Input i, double initvalue=0);$/;"	p	class:simlib3::Status	access:public	signature:(Input i, double initvalue=0)
simlib3::Status::Status	simlib.h	/^  Status(Status&);                     \/\/ disable copy ctor$/;"	p	class:simlib3::Status	access:private	signature:(Status&)
simlib3::Status::Value	intg.cc	/^double Status::Value()$/;"	f	class:simlib3::Status	signature:()
simlib3::Status::Value	simlib.h	/^  virtual double Value();              \/\/ block status$/;"	p	class:simlib3::Status	access:public	signature:()
simlib3::Status::ValueOK	simlib.h	/^  bool ValueOK;                        \/\/ valid-flag ###$/;"	m	class:simlib3::Status	access:protected
simlib3::Status::initval	simlib.h	/^  double initval;                      \/\/!< initial value$/;"	m	class:simlib3::Status	access:protected
simlib3::Status::it_list	simlib.h	/^  StatusContainer::iterator it_list;   \/\/!< position in list of status variables$/;"	m	class:simlib3::Status	access:protected
simlib3::Status::operator =	simlib.h	/^  void operator= (Status&);            \/\/ disable assignment$/;"	p	class:simlib3::Status	access:private	signature:(Status&)
simlib3::Status::st	simlib.h	/^  double st;                           \/\/!< status$/;"	m	class:simlib3::Status	access:public
simlib3::Status::stl	simlib.h	/^  double stl;                          \/\/!< status from previous step$/;"	m	class:simlib3::Status	access:public
simlib3::Status::~Status	intg.cc	/^Status::~Status() {$/;"	f	class:simlib3::Status	signature:()
simlib3::Status::~Status	simlib.h	/^  ~Status();$/;"	p	class:simlib3::Status	access:public	signature:()
simlib3::StatusContainer	simlib.h	/^class StatusContainer {$/;"	c	namespace:simlib3
simlib3::StatusContainer::Begin	simlib.h	/^  static iterator Begin(void) {$/;"	f	class:simlib3::StatusContainer	access:public	signature:(void)
simlib3::StatusContainer::ClearAllValueOK	intg.cc	/^void StatusContainer::ClearAllValueOK()$/;"	f	class:simlib3::StatusContainer	signature:()
simlib3::StatusContainer::ClearAllValueOK	simlib.h	/^  static void ClearAllValueOK();   \/\/ invalidate values of all items$/;"	p	class:simlib3::StatusContainer	access:public	signature:()
simlib3::StatusContainer::End	simlib.h	/^  static iterator End(void) {$/;"	f	class:simlib3::StatusContainer	access:public	signature:(void)
simlib3::StatusContainer::Erase	intg.cc	/^void StatusContainer::Erase(StatusContainer::iterator it)$/;"	f	class:simlib3::StatusContainer	signature:(StatusContainer::iterator it)
simlib3::StatusContainer::Erase	simlib.h	/^  static void Erase(iterator it);  \/\/ exclude element$/;"	p	class:simlib3::StatusContainer	access:public	signature:(iterator it)
simlib3::StatusContainer::EvaluateAll	intg.cc	/^void StatusContainer::EvaluateAll()$/;"	f	class:simlib3::StatusContainer	signature:()
simlib3::StatusContainer::EvaluateAll	simlib.h	/^  static void EvaluateAll();       \/\/ evaluate all integrators$/;"	p	class:simlib3::StatusContainer	access:public	signature:()
simlib3::StatusContainer::InitAll	intg.cc	/^void StatusContainer::InitAll()$/;"	f	class:simlib3::StatusContainer	signature:()
simlib3::StatusContainer::InitAll	simlib.h	/^  static void InitAll();           \/\/ initialize all$/;"	p	class:simlib3::StatusContainer	access:public	signature:()
simlib3::StatusContainer::Insert	intg.cc	/^StatusContainer::iterator StatusContainer::Insert(Status* ptr)$/;"	f	class:simlib3::StatusContainer	signature:(Status* ptr)
simlib3::StatusContainer::Insert	simlib.h	/^  static iterator Insert(Status* ptr);  \/\/ insert element into container$/;"	p	class:simlib3::StatusContainer	access:public	signature:(Status* ptr)
simlib3::StatusContainer::Instance	intg.cc	/^std::list<Status*>* StatusContainer::Instance(void)$/;"	f	class:simlib3::StatusContainer	signature:(void)
simlib3::StatusContainer::Instance	simlib.h	/^  static std::list<Status*>* Instance(void);  \/\/ return list (& create)$/;"	p	class:simlib3::StatusContainer	access:private	signature:(void)
simlib3::StatusContainer::ListPtr	intg.cc	/^std::list<Status*>* StatusContainer::ListPtr=NULL;$/;"	m	class:simlib3::StatusContainer	file:
simlib3::StatusContainer::ListPtr	simlib.h	/^  static std::list<Status*>* ListPtr;  \/\/ list of integrators$/;"	m	class:simlib3::StatusContainer	access:private
simlib3::StatusContainer::LtoN	intg.cc	/^void StatusContainer::LtoN()$/;"	f	class:simlib3::StatusContainer	signature:()
simlib3::StatusContainer::LtoN	simlib.h	/^  static void LtoN();              \/\/ last -> now$/;"	p	class:simlib3::StatusContainer	access:public	signature:()
simlib3::StatusContainer::NtoL	intg.cc	/^void StatusContainer::NtoL()$/;"	f	class:simlib3::StatusContainer	signature:()
simlib3::StatusContainer::NtoL	simlib.h	/^  static void NtoL();              \/\/ now -> last$/;"	p	class:simlib3::StatusContainer	access:public	signature:()
simlib3::StatusContainer::Size	simlib.h	/^  static size_t Size(void) {$/;"	f	class:simlib3::StatusContainer	access:public	signature:(void)
simlib3::StatusContainer::StatusContainer	simlib.h	/^  StatusContainer();  \/\/ forbid constructor$/;"	p	class:simlib3::StatusContainer	access:private	signature:()
simlib3::StatusContainer::isAny	simlib.h	/^  static bool isAny(void) {$/;"	f	class:simlib3::StatusContainer	access:public	signature:(void)
simlib3::StatusContainer::iterator	simlib.h	/^  typedef std::list<Status*>::iterator iterator;$/;"	t	class:simlib3::StatusContainer	access:public
simlib3::StatusMethod	simlib.h	/^class StatusMethod : public SingleStepMethod {$/;"	c	namespace:simlib3	inherits:SingleStepMethod
simlib3::StatusMethod::FirstStatus	simlib.h	/^  static StatusIterator FirstStatus(void) {  \/\/ it. to first status in list$/;"	f	class:simlib3::StatusMethod	access:protected	signature:(void)
simlib3::StatusMethod::GoToState	numint.cc	/^void StatusMethod::GoToState(Memory& di, Memory& si, StatusMemory& xi)$/;"	f	class:simlib3::StatusMethod	signature:(Memory& di, Memory& si, StatusMemory& xi)
simlib3::StatusMethod::GoToState	simlib.h	/^  static void GoToState(Memory& di, Memory& si, StatusMemory& xi);$/;"	p	class:simlib3::StatusMethod	access:protected	signature:(Memory& di, Memory& si, StatusMemory& xi)
simlib3::StatusMethod::Integrate	simlib.h	/^  virtual void Integrate(void) = 0;  \/\/ the method does integration$/;"	p	class:simlib3::StatusMethod	access:public	signature:(void)
simlib3::StatusMethod::LastStatus	simlib.h	/^  static StatusIterator LastStatus(void) {  \/\/ it. to last status in list$/;"	f	class:simlib3::StatusMethod	access:protected	signature:(void)
simlib3::StatusMethod::PrepareStep	numint.cc	/^bool StatusMethod::PrepareStep(void)$/;"	f	class:simlib3::StatusMethod	signature:(void)
simlib3::StatusMethod::PrepareStep	simlib.h	/^  virtual bool PrepareStep(void);  \/\/ prepare integration step$/;"	p	class:simlib3::StatusMethod	access:public	signature:(void)
simlib3::StatusMethod::PrevStatusNum	simlib.h	/^  size_t PrevStatusNum;  \/\/ # of status variables in previous step$/;"	m	class:simlib3::StatusMethod	access:private
simlib3::StatusMethod::PtrStatusMList	numint.cc	/^std::list<IntegrationMethod::Memory*>* StatusMethod::PtrStatusMList;$/;"	m	class:simlib3::StatusMethod	file:
simlib3::StatusMethod::PtrStatusMList	simlib.h	/^  static std::list<Memory*>* PtrStatusMList;  \/\/ pointer to list being filled$/;"	m	class:simlib3::StatusMethod	access:private
simlib3::StatusMethod::RestoreState	numint.cc	/^void StatusMethod::RestoreState(double dthlf, Memory& di, Memory& si,$/;"	f	class:simlib3::StatusMethod	signature:(double dthlf, Memory& di, Memory& si, StatusMemory& xi)
simlib3::StatusMethod::RestoreState	simlib.h	/^  static void RestoreState(double dthlf, Memory& di,$/;"	p	class:simlib3::StatusMethod	access:protected	signature:(double dthlf, Memory& di, Memory& si, StatusMemory& xi)
simlib3::StatusMethod::StatusIterator	simlib.h	/^  typedef StatusContainer::iterator StatusIterator;  \/\/ iterator of intg. list$/;"	t	class:simlib3::StatusMethod	access:protected
simlib3::StatusMethod::StatusMList	simlib.h	/^  std::list<Memory*> StatusMList;  \/\/ list of auxiliary memories$/;"	m	class:simlib3::StatusMethod	access:private
simlib3::StatusMethod::StatusMemory	simlib.h	/^  class StatusMemory : public Memory {$/;"	c	class:simlib3::StatusMethod	inherits:Memory	access:protected
simlib3::StatusMethod::StatusMemory::StatusMemory	simlib.h	/^    StatusMemory(StatusMemory&);  \/\/ forbid copy constructor$/;"	p	class:simlib3::StatusMethod::StatusMemory	access:private	signature:(StatusMemory&)
simlib3::StatusMethod::StatusMemory::StatusMemory	simlib.h	/^    StatusMemory(std::list<Memory*>* PtrList=PtrStatusMList) : Memory(PtrList) { }$/;"	f	class:simlib3::StatusMethod::StatusMemory	access:public	signature:(std::list<Memory*>* PtrList=PtrStatusMList)
simlib3::StatusMethod::StatusMemory::operator =	simlib.h	/^    void operator= (StatusMemory&);  \/\/ disable the operation$/;"	p	class:simlib3::StatusMethod::StatusMemory	access:private	signature:(StatusMemory&)
simlib3::StatusMethod::StatusMemory::~StatusMemory	simlib.h	/^    virtual ~StatusMemory() { }$/;"	f	class:simlib3::StatusMethod::StatusMemory	access:public	signature:()
simlib3::StatusMethod::StatusMethod	numint.cc	/^StatusMethod::StatusMethod(const char* name):$/;"	f	class:simlib3::StatusMethod	signature:(const char* name)
simlib3::StatusMethod::StatusMethod	simlib.h	/^  StatusMethod();  \/\/ forbid implicit constructor$/;"	p	class:simlib3::StatusMethod	access:private	signature:()
simlib3::StatusMethod::StatusMethod	simlib.h	/^  StatusMethod(StatusMethod&);  \/\/ forbid implicit copy-constructor$/;"	p	class:simlib3::StatusMethod	access:private	signature:(StatusMethod&)
simlib3::StatusMethod::StatusMethod	simlib.h	/^  StatusMethod(const char* name);  \/\/ initailization$/;"	p	class:simlib3::StatusMethod	access:public	signature:(const char* name)
simlib3::StatusMethod::StatusResize	numint.cc	/^void StatusMethod::StatusResize(size_t size)$/;"	f	class:simlib3::StatusMethod	signature:(size_t size)
simlib3::StatusMethod::StatusResize	simlib.h	/^  virtual void StatusResize(size_t size);  \/\/ resize status memories$/;"	p	class:simlib3::StatusMethod	access:public	signature:(size_t size)
simlib3::StatusMethod::StoreState	numint.cc	/^void StatusMethod::StoreState(Memory& di, Memory& si, StatusMemory& xi)$/;"	f	class:simlib3::StatusMethod	signature:(Memory& di, Memory& si, StatusMemory& xi)
simlib3::StatusMethod::StoreState	simlib.h	/^  static void StoreState(Memory& di, Memory& si, StatusMemory& xi);$/;"	p	class:simlib3::StatusMethod	access:protected	signature:(Memory& di, Memory& si, StatusMemory& xi)
simlib3::StatusMethod::TurnOff	numint.cc	/^void StatusMethod::TurnOff(void)$/;"	f	class:simlib3::StatusMethod	signature:(void)
simlib3::StatusMethod::TurnOff	simlib.h	/^  virtual void TurnOff(void);  \/\/ turn off integration method$/;"	p	class:simlib3::StatusMethod	access:public	signature:(void)
simlib3::StatusMethod::~StatusMethod	simlib.h	/^  virtual ~StatusMethod() { } \/\/ free dynamic datas$/;"	f	class:simlib3::StatusMethod	access:public	signature:()
simlib3::StepSize	intg.cc	/^const double &StepSize=SIMLIB_StepSize;      \/\/!< actual integration step$/;"	m	namespace:simlib3	file:
simlib3::Stop	run.cc	/^void Stop()$/;"	f	namespace:simlib3	signature:()
simlib3::Stop	simlib.h	/^void Stop();$/;"	p	namespace:simlib3	signature:()
simlib3::StopFlag	run.cc	/^static bool StopFlag = false;           \/\/ if set, stop simulation run$/;"	m	namespace:simlib3	file:
simlib3::Store	simlib.h	/^class Store : public SimObject {$/;"	c	namespace:simlib3	inherits:SimObject
simlib3::Store::Capacity	simlib.h	/^  unsigned long Capacity() const { return capacity; }   \/\/!< max capacity$/;"	f	class:simlib3::Store	access:public	signature:() const
simlib3::Store::Clear	simlib.h	/^  virtual void Clear();                                 \/\/!< initialize$/;"	p	class:simlib3::Store	access:public	signature:()
simlib3::Store::Clear	store.cc	/^void Store::Clear()$/;"	f	class:simlib3::Store	signature:()
simlib3::Store::Empty	simlib.h	/^  bool Empty() const  { return Used() == 0; }           \/\/!< store is empty$/;"	f	class:simlib3::Store	access:public	signature:() const
simlib3::Store::Enter	simlib.h	/^  virtual void Enter(Entity *e, unsigned long rcap);    \/\/!< allocate capacity$/;"	p	class:simlib3::Store	access:public	signature:(Entity *e, unsigned long rcap)
simlib3::Store::Enter	store.cc	/^void Store::Enter(Entity *e, unsigned long rcap)$/;"	f	class:simlib3::Store	signature:(Entity *e, unsigned long rcap)
simlib3::Store::Free	simlib.h	/^  unsigned long Free() const { return capacity - used; }\/\/!< free capacity$/;"	f	class:simlib3::Store	access:public	signature:() const
simlib3::Store::Full	simlib.h	/^  bool Full() const   { return Free() == 0; }           \/\/!< store is full$/;"	f	class:simlib3::Store	access:public	signature:() const
simlib3::Store::Leave	simlib.h	/^  virtual void Leave(unsigned long rcap);               \/\/!< deallocate capacity$/;"	p	class:simlib3::Store	access:public	signature:(unsigned long rcap)
simlib3::Store::Leave	store.cc	/^void Store::Leave(unsigned long rcap)$/;"	f	class:simlib3::Store	signature:(unsigned long rcap)
simlib3::Store::Output	output2.cc	/^void Store::Output() const$/;"	f	class:simlib3::Store	signature:() const
simlib3::Store::Output	simlib.h	/^  virtual void Output() const;                          \/\/!< print statistics$/;"	p	class:simlib3::Store	access:public	signature:() const
simlib3::Store::OwnQueue	simlib.h	/^  bool OwnQueue() const;$/;"	p	class:simlib3::Store	access:public	signature:() const
simlib3::Store::OwnQueue	store.cc	/^bool Store::OwnQueue() const$/;"	f	class:simlib3::Store	signature:() const
simlib3::Store::Q	simlib.h	/^  Queue *Q;                     \/\/!< input queue$/;"	m	class:simlib3::Store	access:public
simlib3::Store::QueueIn	simlib.h	/^  virtual void QueueIn(Entity *e, unsigned long c);     \/\/!< insert entity into queue$/;"	p	class:simlib3::Store	access:public	signature:(Entity *e, unsigned long c)
simlib3::Store::QueueIn	store.cc	/^void Store::QueueIn(Entity *e, unsigned long c)$/;"	f	class:simlib3::Store	signature:(Entity *e, unsigned long c)
simlib3::Store::QueueLen	simlib.h	/^  unsigned QueueLen() const { return Q->size(); }$/;"	f	class:simlib3::Store	access:public	signature:() const
simlib3::Store::SetCapacity	simlib.h	/^  void SetCapacity(unsigned long _capacity);            \/\/!< change the capacity$/;"	p	class:simlib3::Store	access:public	signature:(unsigned long _capacity)
simlib3::Store::SetCapacity	store.cc	/^void Store::SetCapacity(unsigned long newcapacity)$/;"	f	class:simlib3::Store	signature:(unsigned long newcapacity)
simlib3::Store::SetQueue	simlib.h	/^  void SetQueue(Queue *queue);                          \/\/!< change input queue$/;"	p	class:simlib3::Store	access:public	signature:(Queue *queue)
simlib3::Store::SetQueue	store.cc	/^void Store::SetQueue(Queue *queue)$/;"	f	class:simlib3::Store	signature:(Queue *queue)
simlib3::Store::Store	simlib.h	/^    Store(const Store&);              \/\/ disable$/;"	p	class:simlib3::Store	access:private	signature:(const Store&)
simlib3::Store::Store	simlib.h	/^  Store();$/;"	p	class:simlib3::Store	access:public	signature:()
simlib3::Store::Store	simlib.h	/^  Store(const char *_name, unsigned long _capacity);$/;"	p	class:simlib3::Store	access:public	signature:(const char *_name, unsigned long _capacity)
simlib3::Store::Store	simlib.h	/^  Store(const char *_name, unsigned long _capacity, Queue *queue);$/;"	p	class:simlib3::Store	access:public	signature:(const char *_name, unsigned long _capacity, Queue *queue)
simlib3::Store::Store	simlib.h	/^  Store(unsigned long _capacity);$/;"	p	class:simlib3::Store	access:public	signature:(unsigned long _capacity)
simlib3::Store::Store	simlib.h	/^  Store(unsigned long _capacity, Queue *queue);$/;"	p	class:simlib3::Store	access:public	signature:(unsigned long _capacity, Queue *queue)
simlib3::Store::Store	store.cc	/^Store::Store() :$/;"	f	class:simlib3::Store	signature:()
simlib3::Store::Store	store.cc	/^Store::Store(const char * name, unsigned long _capacity) :$/;"	f	class:simlib3::Store	signature:(const char * name, unsigned long _capacity)
simlib3::Store::Store	store.cc	/^Store::Store(const char *name, unsigned long _capacity, Queue *queue) :$/;"	f	class:simlib3::Store	signature:(const char *name, unsigned long _capacity, Queue *queue)
simlib3::Store::Store	store.cc	/^Store::Store(unsigned long _capacity) :$/;"	f	class:simlib3::Store	signature:(unsigned long _capacity)
simlib3::Store::Store	store.cc	/^Store::Store(unsigned long _capacity, Queue *queue) :$/;"	f	class:simlib3::Store	signature:(unsigned long _capacity, Queue *queue)
simlib3::Store::Used	simlib.h	/^  unsigned long Used() const { return used; }           \/\/!< used capacity$/;"	f	class:simlib3::Store	access:public	signature:() const
simlib3::Store::_Qflag	simlib.h	/^  unsigned char _Qflag;$/;"	m	class:simlib3::Store	access:private
simlib3::Store::capacity	simlib.h	/^  unsigned long capacity;        \/\/ capacity of store$/;"	m	class:simlib3::Store	access:private
simlib3::Store::operator =	simlib.h	/^    Store&operator=(const Store&);    \/\/ disable$/;"	p	class:simlib3::Store	access:private	signature:(const Store&)
simlib3::Store::operator Store*	simlib.h	/^  operator Store* () { return this; }$/;"	f	class:simlib3::Store	access:public	signature:()
simlib3::Store::tstat	simlib.h	/^  TStat tstat;                  \/\/!< usage statistics$/;"	m	class:simlib3::Store	access:public
simlib3::Store::used	simlib.h	/^  unsigned long used;            \/\/ used capacity$/;"	m	class:simlib3::Store	access:private
simlib3::Store::~Store	simlib.h	/^  virtual ~Store();$/;"	p	class:simlib3::Store	access:public	signature:()
simlib3::Store::~Store	store.cc	/^Store::~Store()$/;"	f	class:simlib3::Store	signature:()
simlib3::T	continuous.cc	/^aContiBlock & T = _T;   \/\/ TODO try Input$/;"	m	namespace:simlib3	file:
simlib3::TERMINATION	internal.h	/^    TERMINATION,    \/\/ after Run() call$/;"	e	enum:simlib3::SIMLIB_Phase_t
simlib3::THREAD_INTERRUPT_f	process.cc	/^static void THREAD_INTERRUPT_f()$/;"	f	namespace:simlib3	signature:()
simlib3::THREAD_INTERRUPT_f	process.cc	/^static void THREAD_INTERRUPT_f();       \/\/ special function$/;"	p	namespace:simlib3	file:	signature:()
simlib3::TStat	simlib.h	/^class TStat : public SimObject {$/;"	c	namespace:simlib3	inherits:SimObject
simlib3::TStat::Clear	simlib.h	/^  virtual void Clear(double initval=0.0);        \/\/!< initialize$/;"	p	class:simlib3::TStat	access:public	signature:(double initval=0.0)
simlib3::TStat::Clear	tstat.cc	/^void TStat::Clear(double initval)$/;"	f	class:simlib3::TStat	signature:(double initval)
simlib3::TStat::LastTime	simlib.h	/^  double LastTime() const      { return tl; }$/;"	f	class:simlib3::TStat	access:public	signature:() const
simlib3::TStat::LastValue	simlib.h	/^  double LastValue() const     { return xl; }$/;"	f	class:simlib3::TStat	access:public	signature:() const
simlib3::TStat::Max	simlib.h	/^  double Max() const           { return max; }$/;"	f	class:simlib3::TStat	access:public	signature:() const
simlib3::TStat::MeanValue	simlib.h	/^  double MeanValue() const;$/;"	p	class:simlib3::TStat	access:public	signature:() const
simlib3::TStat::MeanValue	tstat.cc	/^double TStat::MeanValue() const$/;"	f	class:simlib3::TStat	signature:() const
simlib3::TStat::Min	simlib.h	/^  double Min() const           { \/*TODO: only if(n>0)*\/ return min; }$/;"	f	class:simlib3::TStat	access:public	signature:() const
simlib3::TStat::Number	simlib.h	/^  unsigned long Number() const { return n; }$/;"	f	class:simlib3::TStat	access:public	signature:() const
simlib3::TStat::Output	output2.cc	/^void TStat::Output() const$/;"	f	class:simlib3::TStat	signature:() const
simlib3::TStat::Output	simlib.h	/^  virtual void Output() const;          \/\/!< print object to default output$/;"	p	class:simlib3::TStat	access:public	signature:() const
simlib3::TStat::StartTime	simlib.h	/^  double StartTime() const     { return t0; }$/;"	f	class:simlib3::TStat	access:public	signature:() const
simlib3::TStat::Sum	simlib.h	/^  double Sum() const           { return sxt; }$/;"	f	class:simlib3::TStat	access:public	signature:() const
simlib3::TStat::SumSquare	simlib.h	/^  double SumSquare() const     { return sx2t; }$/;"	f	class:simlib3::TStat	access:public	signature:() const
simlib3::TStat::TStat	simlib.h	/^  TStat(const char *name, double initval=0.0);$/;"	p	class:simlib3::TStat	access:public	signature:(const char *name, double initval=0.0)
simlib3::TStat::TStat	simlib.h	/^  TStat(double initval=0.0);$/;"	p	class:simlib3::TStat	access:public	signature:(double initval=0.0)
simlib3::TStat::TStat	tstat.cc	/^TStat::TStat(const char *name, double initval) :$/;"	f	class:simlib3::TStat	signature:(const char *name, double initval)
simlib3::TStat::TStat	tstat.cc	/^TStat::TStat(double initval):$/;"	f	class:simlib3::TStat	signature:(double initval)
simlib3::TStat::max	simlib.h	/^  double max;                   \/\/ max value x$/;"	m	class:simlib3::TStat	access:protected
simlib3::TStat::min	simlib.h	/^  double min;                   \/\/ min value x$/;"	m	class:simlib3::TStat	access:protected
simlib3::TStat::n	simlib.h	/^  unsigned long n;              \/\/ number of records$/;"	m	class:simlib3::TStat	access:protected
simlib3::TStat::operator ()	simlib.h	/^  virtual void operator () (double x);           \/\/!< record the value$/;"	p	class:simlib3::TStat	access:public	signature:(double x)
simlib3::TStat::operator ()	tstat.cc	/^void TStat::operator () (double x)$/;"	f	class:simlib3::TStat	signature:(double x)
simlib3::TStat::sx2t	simlib.h	/^  double sx2t;                  \/\/ sum of squares$/;"	m	class:simlib3::TStat	access:protected
simlib3::TStat::sxt	simlib.h	/^  double sxt;                   \/\/ sum of x*time$/;"	m	class:simlib3::TStat	access:protected
simlib3::TStat::t0	simlib.h	/^  double t0;                    \/\/ time of initialization$/;"	m	class:simlib3::TStat	access:protected
simlib3::TStat::tl	simlib.h	/^  double tl;                    \/\/ last record time$/;"	m	class:simlib3::TStat	access:protected
simlib3::TStat::xl	simlib.h	/^  double xl;                    \/\/ last recorded value x$/;"	m	class:simlib3::TStat	access:protected
simlib3::TStat::~TStat	simlib.h	/^  ~TStat();$/;"	p	class:simlib3::TStat	access:public	signature:()
simlib3::TStat::~TStat	tstat.cc	/^TStat::~TStat()$/;"	f	class:simlib3::TStat	signature:()
simlib3::Tan	fun.cc	/^Input Tan(Input x)              { return new Function1(x, tan); }$/;"	f	namespace:simlib3	signature:(Input x)
simlib3::Tan	simlib.h	/^Input Tan(Input x);             \/\/ tan(x)$/;"	p	namespace:simlib3	signature:(Input x)
simlib3::Time	run.cc	/^const double & Time      = SIMLIB_Time;         \/\/ simulation time$/;"	m	namespace:simlib3	file:
simlib3::Triag	random2.cc	/^double Triag(double mod, double min, double max)$/;"	f	namespace:simlib3	signature:(double mod, double min, double max)
simlib3::Triag	simlib.h	/^double Triag(double mod, double min, double max);$/;"	p	namespace:simlib3	signature:(double mod, double min, double max)
simlib3::Uniform	random2.cc	/^double Uniform(double l, double h)$/;"	f	namespace:simlib3	signature:(double l, double h)
simlib3::Uniform	simlib.h	/^double Uniform(double l, double h);$/;"	p	namespace:simlib3	signature:(double l, double h)
simlib3::UnitVector	simlib2D.cc	/^Input2D UnitVector(Input2D x) { return new _Norm2D(x); }$/;"	f	namespace:simlib3	signature:(Input2D x)
simlib3::UnitVector	simlib2D.h	/^Input2D UnitVector(Input2D v);$/;"	p	namespace:simlib3	signature:(Input2D v)
simlib3::UnitVector	simlib3D.cc	/^Input3D UnitVector(Input3D x) { return new _Norm3D(x); }$/;"	f	namespace:simlib3	signature:(Input3D x)
simlib3::UnitVector	simlib3D.h	/^Input3D UnitVector(Input3D x);$/;"	p	namespace:simlib3	signature:(Input3D x)
simlib3::Value2D	simlib2D.h	/^class Value2D {$/;"	c	namespace:simlib3
simlib3::Value2D::Print	simlib2D.h	/^  void Print() { ::Print(" %g %g ", _x, _y); }$/;"	f	class:simlib3::Value2D	access:public	signature:()
simlib3::Value2D::Value2D	simlib2D.h	/^  Value2D(double x, double y) : _x(x), _y(y) {}$/;"	f	class:simlib3::Value2D	access:public	signature:(double x, double y)
simlib3::Value2D::_x	simlib2D.h	/^  double _x, _y;$/;"	m	class:simlib3::Value2D	access:private
simlib3::Value2D::_y	simlib2D.h	/^  double _x, _y;$/;"	m	class:simlib3::Value2D	access:private
simlib3::Value2D::abs	simlib2D.h	/^  friend double abs(const Value2D &a);$/;"	p	class:simlib3::Value2D	access:friend	signature:(const Value2D &a)
simlib3::Value2D::operator *	simlib2D.h	/^  friend Value2D operator *(const Value2D& a, const double b);$/;"	p	class:simlib3::Value2D	access:friend	signature:(const Value2D& a, const double b)
simlib3::Value2D::operator *	simlib2D.h	/^  friend Value2D operator *(const double a, const Value2D& b);$/;"	p	class:simlib3::Value2D	access:friend	signature:(const double a, const Value2D& b)
simlib3::Value2D::operator +	simlib2D.h	/^  Value2D operator + (Value2D b) { return Value2D(_x+b._x, _y+b._y); }$/;"	f	class:simlib3::Value2D	access:public	signature:(Value2D b)
simlib3::Value2D::operator +	simlib2D.h	/^  friend Value2D operator +(const Value2D& a, const Value2D &b);$/;"	p	class:simlib3::Value2D	access:friend	signature:(const Value2D& a, const Value2D &b)
simlib3::Value2D::operator -	simlib2D.h	/^  Value2D operator - (Value2D b) { return Value2D(_x-b._x, _y-b._y); }$/;"	f	class:simlib3::Value2D	access:public	signature:(Value2D b)
simlib3::Value2D::operator -	simlib2D.h	/^  friend Value2D operator -(const Value2D& a);$/;"	p	class:simlib3::Value2D	access:friend	signature:(const Value2D& a)
simlib3::Value2D::operator -	simlib2D.h	/^  friend Value2D operator -(const Value2D& a, const Value2D &b);$/;"	p	class:simlib3::Value2D	access:friend	signature:(const Value2D& a, const Value2D &b)
simlib3::Value2D::operator /	simlib2D.h	/^  friend Value2D operator \/(const Value2D& a, const double b);$/;"	p	class:simlib3::Value2D	access:friend	signature:(const Value2D& a, const double b)
simlib3::Value2D::scalar_product	simlib2D.h	/^  friend double scalar_product(const Value2D& a, const Value2D &b);$/;"	p	class:simlib3::Value2D	access:friend	signature:(const Value2D& a, const Value2D &b)
simlib3::Value2D::x	simlib2D.h	/^  double x() const { return _x; }$/;"	f	class:simlib3::Value2D	access:public	signature:() const
simlib3::Value2D::y	simlib2D.h	/^  double y() const { return _y; }$/;"	f	class:simlib3::Value2D	access:public	signature:() const
simlib3::Value3D	simlib3D.h	/^class Value3D {$/;"	c	namespace:simlib3
simlib3::Value3D::Print	simlib3D.h	/^  void Print() { ::Print(" %g %g %g ", _x, _y, _z); }$/;"	f	class:simlib3::Value3D	access:public	signature:()
simlib3::Value3D::Value3D	simlib3D.h	/^  Value3D(double x, double y, double z) : _x(x), _y(y), _z(z) {}$/;"	f	class:simlib3::Value3D	access:public	signature:(double x, double y, double z)
simlib3::Value3D::_x	simlib3D.h	/^  double _x, _y, _z;$/;"	m	class:simlib3::Value3D	access:private
simlib3::Value3D::_y	simlib3D.h	/^  double _x, _y, _z;$/;"	m	class:simlib3::Value3D	access:private
simlib3::Value3D::_z	simlib3D.h	/^  double _x, _y, _z;$/;"	m	class:simlib3::Value3D	access:private
simlib3::Value3D::abs	simlib3D.h	/^  friend double abs(const Value3D &a);$/;"	p	class:simlib3::Value3D	access:friend	signature:(const Value3D &a)
simlib3::Value3D::operator *	simlib3D.h	/^  friend Value3D operator *(const Value3D& a, const Value3D &b);$/;"	p	class:simlib3::Value3D	access:friend	signature:(const Value3D& a, const Value3D &b)
simlib3::Value3D::operator *	simlib3D.h	/^  friend Value3D operator *(const Value3D& a, const double b);$/;"	p	class:simlib3::Value3D	access:friend	signature:(const Value3D& a, const double b)
simlib3::Value3D::operator *	simlib3D.h	/^  friend Value3D operator *(const double a, const Value3D& b);$/;"	p	class:simlib3::Value3D	access:friend	signature:(const double a, const Value3D& b)
simlib3::Value3D::operator +	simlib3D.h	/^  Value3D operator + (Value3D b) { return Value3D(_x+b._x, _y+b._y, _z+b._z); }$/;"	f	class:simlib3::Value3D	access:public	signature:(Value3D b)
simlib3::Value3D::operator +	simlib3D.h	/^  friend Value3D operator +(const Value3D& a, const Value3D &b);$/;"	p	class:simlib3::Value3D	access:friend	signature:(const Value3D& a, const Value3D &b)
simlib3::Value3D::operator -	simlib3D.h	/^  Value3D operator - (Value3D b) { return Value3D(_x-b._x, _y-b._y, _z-b._z); }$/;"	f	class:simlib3::Value3D	access:public	signature:(Value3D b)
simlib3::Value3D::operator -	simlib3D.h	/^  friend Value3D operator -(const Value3D& a);$/;"	p	class:simlib3::Value3D	access:friend	signature:(const Value3D& a)
simlib3::Value3D::operator -	simlib3D.h	/^  friend Value3D operator -(const Value3D& a, const Value3D &b);$/;"	p	class:simlib3::Value3D	access:friend	signature:(const Value3D& a, const Value3D &b)
simlib3::Value3D::operator /	simlib3D.h	/^  friend Value3D operator \/(const Value3D& a, const double b);$/;"	p	class:simlib3::Value3D	access:friend	signature:(const Value3D& a, const double b)
simlib3::Value3D::scalar_product	simlib3D.h	/^  friend double scalar_product(const Value3D& a, const Value3D &b);$/;"	p	class:simlib3::Value3D	access:friend	signature:(const Value3D& a, const Value3D &b)
simlib3::Value3D::x	simlib3D.h	/^  double x() const { return _x; }$/;"	f	class:simlib3::Value3D	access:public	signature:() const
simlib3::Value3D::y	simlib3D.h	/^  double y() const { return _y; }$/;"	f	class:simlib3::Value3D	access:public	signature:() const
simlib3::Value3D::z	simlib3D.h	/^  double z() const { return _z; }$/;"	f	class:simlib3::Value3D	access:public	signature:() const
simlib3::Variable	simlib.h	/^class Variable : public aContiBlock {$/;"	c	namespace:simlib3	inherits:aContiBlock
simlib3::Variable2D	simlib2D.h	/^class Variable2D : public aContiBlock2D {$/;"	c	namespace:simlib3	inherits:aContiBlock2D
simlib3::Variable2D::Value	simlib2D.h	/^  virtual Value2D Value()            { return value; }$/;"	f	class:simlib3::Variable2D	access:public	signature:()
simlib3::Variable2D::Variable2D	simlib2D.h	/^  explicit Variable2D(Value2D x=Value2D(0,0)) : value(x) {}$/;"	f	class:simlib3::Variable2D	access:public	signature:(Value2D x=Value2D(0,0))
simlib3::Variable2D::operator =	simlib2D.h	/^  Variable2D &operator= (Value2D x)  { value = x; return *this; }$/;"	f	class:simlib3::Variable2D	access:public	signature:(Value2D x)
simlib3::Variable2D::value	simlib2D.h	/^  Value2D value;$/;"	m	class:simlib3::Variable2D	access:protected
simlib3::Variable3D	simlib3D.h	/^class Variable3D : public aContiBlock3D {$/;"	c	namespace:simlib3	inherits:aContiBlock3D
simlib3::Variable3D::Value	simlib3D.h	/^  virtual Value3D Value ()          { return value; }$/;"	f	class:simlib3::Variable3D	access:public	signature:()
simlib3::Variable3D::Variable3D	simlib3D.h	/^  explicit Variable3D(Value3D x=Value3D(0,0,0)) : value(x) {}$/;"	f	class:simlib3::Variable3D	access:public	signature:(Value3D x=Value3D(0,0,0))
simlib3::Variable3D::operator =	simlib3D.h	/^  Variable3D &operator= (Value3D x) { value = x; return *this; }$/;"	f	class:simlib3::Variable3D	access:public	signature:(Value3D x)
simlib3::Variable3D::value	simlib3D.h	/^  Value3D value;$/;"	m	class:simlib3::Variable3D	access:protected
simlib3::Variable::Value	simlib.h	/^  virtual double Value ()         { return value; }$/;"	f	class:simlib3::Variable	access:public	signature:()
simlib3::Variable::Variable	simlib.h	/^  Variable(double x=0) : value(x) {}$/;"	f	class:simlib3::Variable	access:public	signature:(double x=0)
simlib3::Variable::operator =	simlib.h	/^  Variable &operator= (double x)  { value = x; return *this; }$/;"	f	class:simlib3::Variable	access:public	signature:(double x)
simlib3::Variable::value	simlib.h	/^  double value;$/;"	m	class:simlib3::Variable	access:private
simlib3::VoidFunctionPtr	internal.h	/^typedef void (*VoidFunctionPtr)(); \/\/ ptr to void function$/;"	t	namespace:simlib3
simlib3::WU_print	waitunti.cc	/^    void WU_print() {$/;"	f	namespace:simlib3	signature:()
simlib3::WaitUntilList	waitunti.cc	/^class WaitUntilList {$/;"	c	namespace:simlib3	file:
simlib3::WaitUntilList::GetCurrent	waitunti.cc	/^    static void GetCurrent();        \/\/ get current process$/;"	p	class:simlib3::WaitUntilList	file:	access:public	signature:()
simlib3::WaitUntilList::GetCurrent	waitunti.cc	/^void WaitUntilList::GetCurrent()$/;"	f	class:simlib3::WaitUntilList	signature:()
simlib3::WaitUntilList::InsertCurrent	waitunti.cc	/^    static void InsertCurrent();     \/\/ insert current process into list$/;"	p	class:simlib3::WaitUntilList	file:	access:public	signature:()
simlib3::WaitUntilList::InsertCurrent	waitunti.cc	/^void WaitUntilList::InsertCurrent()$/;"	f	class:simlib3::WaitUntilList	signature:()
simlib3::WaitUntilList::Remove	waitunti.cc	/^    static void Remove(Process *p) { \/\/ find and remove p$/;"	f	class:simlib3::WaitUntilList	access:public	signature:(Process *p)
simlib3::WaitUntilList::WU_hook	waitunti.cc	/^    static void WU_hook(); \/\/ active: next process in WUlist or 0$/;"	p	class:simlib3::WaitUntilList	file:	access:public	signature:()
simlib3::WaitUntilList::WU_hook	waitunti.cc	/^void WaitUntilList::WU_hook() { \/\/ get ptr to next process in WUlist or 0$/;"	f	class:simlib3::WaitUntilList	signature:()
simlib3::WaitUntilList::WU_print	waitunti.cc	/^    friend void WU_print();$/;"	p	class:simlib3::WaitUntilList	file:	access:friend	signature:()
simlib3::WaitUntilList::WaitUntilList	waitunti.cc	/^    WaitUntilList() { Dprintf(("WaitUntilList::WaitUntilList()")); }$/;"	f	class:simlib3::WaitUntilList	file:	access:private	signature:()
simlib3::WaitUntilList::begin	waitunti.cc	/^    static iterator begin() { return instance->l.begin(); }$/;"	f	class:simlib3::WaitUntilList	access:public	signature:()
simlib3::WaitUntilList::clear	waitunti.cc	/^    static void clear();    \/\/ empty$/;"	p	class:simlib3::WaitUntilList	file:	access:public	signature:()
simlib3::WaitUntilList::clear	waitunti.cc	/^void WaitUntilList::clear()$/;"	f	class:simlib3::WaitUntilList	signature:()
simlib3::WaitUntilList::container_t	waitunti.cc	/^    typedef std::list<Process *> container_t;$/;"	t	class:simlib3::WaitUntilList	file:	access:private
simlib3::WaitUntilList::create	waitunti.cc	/^    static void create() {  \/\/ create single instance$/;"	f	class:simlib3::WaitUntilList	access:public	signature:()
simlib3::WaitUntilList::current	waitunti.cc	/^    static iterator current;$/;"	m	class:simlib3::WaitUntilList	file:	access:private
simlib3::WaitUntilList::current	waitunti.cc	/^WaitUntilList::iterator WaitUntilList::current; \/\/ static$/;"	m	class:simlib3::WaitUntilList	file:
simlib3::WaitUntilList::destroy	waitunti.cc	/^    static void destroy() {  \/\/ destroy single instance$/;"	f	class:simlib3::WaitUntilList	access:public	signature:()
simlib3::WaitUntilList::empty	waitunti.cc	/^    static bool empty() { return instance->l.empty(); }$/;"	f	class:simlib3::WaitUntilList	access:public	signature:()
simlib3::WaitUntilList::end	waitunti.cc	/^    static iterator end() { return instance->l.end(); }$/;"	f	class:simlib3::WaitUntilList	access:public	signature:()
simlib3::WaitUntilList::instance	waitunti.cc	/^    static WaitUntilList *instance;   \/\/ unique list$/;"	m	class:simlib3::WaitUntilList	file:	access:private
simlib3::WaitUntilList::instance	waitunti.cc	/^WaitUntilList *WaitUntilList::instance = 0; \/\/ static$/;"	m	class:simlib3::WaitUntilList	file:
simlib3::WaitUntilList::iterator	waitunti.cc	/^    typedef container_t::iterator iterator;$/;"	t	class:simlib3::WaitUntilList	file:	access:public
simlib3::WaitUntilList::l	waitunti.cc	/^    container_t l;$/;"	m	class:simlib3::WaitUntilList	file:	access:private
simlib3::WaitUntilList::~WaitUntilList	waitunti.cc	/^    ~WaitUntilList() { Dprintf(("WaitUntilList::~WaitUntilList()")); }$/;"	f	class:simlib3::WaitUntilList	file:	access:private	signature:()
simlib3::Weibul	random2.cc	/^double Weibul(double lambda, double alfa)$/;"	f	namespace:simlib3	signature:(double lambda, double alfa)
simlib3::Weibul	simlib.h	/^double Weibul(double lambda, double alfa);$/;"	p	namespace:simlib3	signature:(double lambda, double alfa)
simlib3::Xpart	simlib2D.cc	/^Input Xpart(Input2D a) { return new _XYpart(a, _XYpart::x); }$/;"	f	namespace:simlib3	signature:(Input2D a)
simlib3::Xpart	simlib2D.h	/^Input Xpart(Input2D a);$/;"	p	namespace:simlib3	signature:(Input2D a)
simlib3::Xpart	simlib3D.cc	/^Input Xpart(Input3D a) { return new _XYZpart(a, _XYZpart::x); }$/;"	f	namespace:simlib3	signature:(Input3D a)
simlib3::Xpart	simlib3D.h	/^Input Xpart(Input3D a);$/;"	p	namespace:simlib3	signature:(Input3D a)
simlib3::Ypart	simlib2D.cc	/^Input Ypart(Input2D a) { return new _XYpart(a, _XYpart::y); }$/;"	f	namespace:simlib3	signature:(Input2D a)
simlib3::Ypart	simlib2D.h	/^Input Ypart(Input2D a);$/;"	p	namespace:simlib3	signature:(Input2D a)
simlib3::Ypart	simlib3D.cc	/^Input Ypart(Input3D a) { return new _XYZpart(a, _XYZpart::y); }$/;"	f	namespace:simlib3	signature:(Input3D a)
simlib3::Ypart	simlib3D.h	/^Input Ypart(Input3D a);$/;"	p	namespace:simlib3	signature:(Input3D a)
simlib3::ZDelay	zdelay.h	/^class ZDelay : public aContiBlock1 {$/;"	c	namespace:simlib3	inherits:aContiBlock1
simlib3::ZDelay::Init	zdelay.cc	/^void ZDelay::Init() {$/;"	f	class:simlib3::ZDelay	signature:()
simlib3::ZDelay::Init	zdelay.cc	/^void ZDelay::Init(double iv) { \/\/ set initial value of ZDelay block$/;"	f	class:simlib3::ZDelay	signature:(double iv)
simlib3::ZDelay::Init	zdelay.h	/^    virtual void Init();        \/\/ initialize ZDelay block$/;"	p	class:simlib3::ZDelay	access:public	signature:()
simlib3::ZDelay::Init	zdelay.h	/^    void Init(double iv);       \/\/ set initial value of ZDelay block$/;"	p	class:simlib3::ZDelay	access:public	signature:(double iv)
simlib3::ZDelay::SampleIn	zdelay.cc	/^void ZDelay::SampleIn()$/;"	f	class:simlib3::ZDelay	signature:()
simlib3::ZDelay::SampleIn	zdelay.h	/^    virtual void SampleIn();    \/\/ sample input (called automatically by ZDelayTimer)$/;"	p	class:simlib3::ZDelay	access:protected	signature:()
simlib3::ZDelay::SampleOut	zdelay.cc	/^void ZDelay::SampleOut()$/;"	f	class:simlib3::ZDelay	signature:()
simlib3::ZDelay::SampleOut	zdelay.h	/^    virtual void SampleOut();   \/\/ sample output (called automatically)$/;"	p	class:simlib3::ZDelay	access:protected	signature:()
simlib3::ZDelay::Value	zdelay.cc	/^double ZDelay::Value()$/;"	f	class:simlib3::ZDelay	signature:()
simlib3::ZDelay::Value	zdelay.h	/^    virtual double Value();     \/\/ output of ZDelay block$/;"	p	class:simlib3::ZDelay	access:public	signature:()
simlib3::ZDelay::ZDelay	zdelay.cc	/^ZDelay::ZDelay( Input i, double ival ) :$/;"	f	class:simlib3::ZDelay	signature:( Input i, double ival )
simlib3::ZDelay::ZDelay	zdelay.cc	/^ZDelay::ZDelay(Input i, ZDelayTimer *p, double ival) :$/;"	f	class:simlib3::ZDelay	signature:(Input i, ZDelayTimer *p, double ival)
simlib3::ZDelay::ZDelay	zdelay.h	/^    ZDelay( Input i, ZDelayTimer * clock = default_clock, double initvalue = 0 );$/;"	p	class:simlib3::ZDelay	access:public	signature:( Input i, ZDelayTimer * clock = default_clock, double initvalue = 0 )
simlib3::ZDelay::ZDelay	zdelay.h	/^    ZDelay( Input i, double initvalue );$/;"	p	class:simlib3::ZDelay	access:public	signature:( Input i, double initvalue )
simlib3::ZDelay::ZDelay	zdelay.h	/^    ZDelay(const ZDelay&);              \/\/ disable copy ctor$/;"	p	class:simlib3::ZDelay	access:private	signature:(const ZDelay&)
simlib3::ZDelay::clock	zdelay.h	/^    ZDelayTimer *clock;                 \/\/ timer-event for this block$/;"	m	class:simlib3::ZDelay	access:private
simlib3::ZDelay::default_clock	zdelay.cc	/^ZDelayTimer * ZDelay::default_clock = 0;$/;"	m	class:simlib3::ZDelay	file:
simlib3::ZDelay::default_clock	zdelay.h	/^    static ZDelayTimer * default_clock;$/;"	m	class:simlib3::ZDelay	access:protected
simlib3::ZDelay::initval	zdelay.h	/^    double initval;     \/\/ initial output value$/;"	m	class:simlib3::ZDelay	access:protected
simlib3::ZDelay::input_value	zdelay.h	/^    double input_value;                 \/\/ temporary$/;"	m	class:simlib3::ZDelay	access:private
simlib3::ZDelay::new_value	zdelay.h	/^    double new_value;   \/\/ stored input value$/;"	m	class:simlib3::ZDelay	access:protected
simlib3::ZDelay::old_value	zdelay.h	/^    double old_value;   \/\/ output value (delayed signal)$/;"	m	class:simlib3::ZDelay	access:protected
simlib3::ZDelay::operator =	zdelay.h	/^    void operator= (const ZDelay&);     \/\/ disable assignment$/;"	p	class:simlib3::ZDelay	access:private	signature:(const ZDelay&)
simlib3::ZDelay::~ZDelay	zdelay.cc	/^ZDelay::~ZDelay()$/;"	f	class:simlib3::ZDelay	signature:()
simlib3::ZDelay::~ZDelay	zdelay.h	/^    ~ZDelay();$/;"	p	class:simlib3::ZDelay	access:public	signature:()
simlib3::ZDelayTimer	zdelay.h	/^class ZDelayTimer : public Event {$/;"	c	namespace:simlib3	inherits:Event
simlib3::ZDelayTimer::Behavior	zdelay.cc	/^void ZDelayTimer::Behavior()$/;"	f	class:simlib3::ZDelayTimer	signature:()
simlib3::ZDelayTimer::Behavior	zdelay.h	/^    void Behavior();$/;"	p	class:simlib3::ZDelayTimer	access:public	signature:()
simlib3::ZDelayTimer::Default	zdelay.h	/^    static const bool Default = true;$/;"	m	class:simlib3::ZDelayTimer	access:public
simlib3::ZDelayTimer::Init	zdelay.cc	/^void ZDelayTimer::Init()  \/\/ called each Run()$/;"	f	class:simlib3::ZDelayTimer	signature:()
simlib3::ZDelayTimer::Init	zdelay.h	/^    void Init();  \/\/ called each Run()$/;"	p	class:simlib3::ZDelayTimer	access:public	signature:()
simlib3::ZDelayTimer::Register	zdelay.cc	/^void ZDelayTimer::Register(ZDelay*p)$/;"	f	class:simlib3::ZDelayTimer	signature:(ZDelay*p)
simlib3::ZDelayTimer::Register	zdelay.h	/^    void Register(ZDelay*);   \/\/ insert into container$/;"	p	class:simlib3::ZDelayTimer	access:private	signature:(ZDelay*)
simlib3::ZDelayTimer::Set	zdelay.h	/^    void Set(double new_dt) { dt = new_dt; }$/;"	f	class:simlib3::ZDelayTimer	access:public	signature:(double new_dt)
simlib3::ZDelayTimer::Start	zdelay.cc	/^void ZDelayTimer::Start() \/\/ clock activation$/;"	f	class:simlib3::ZDelayTimer	signature:()
simlib3::ZDelayTimer::Start	zdelay.h	/^    void Start(); \/\/ clock activation$/;"	p	class:simlib3::ZDelayTimer	access:public	signature:()
simlib3::ZDelayTimer::Stop	zdelay.cc	/^void ZDelayTimer::Stop() \/\/ clock deactivation$/;"	f	class:simlib3::ZDelayTimer	signature:()
simlib3::ZDelayTimer::Stop	zdelay.h	/^    void Stop();  \/\/ stop clock$/;"	p	class:simlib3::ZDelayTimer	access:public	signature:()
simlib3::ZDelayTimer::UnRegister	zdelay.cc	/^void ZDelayTimer::UnRegister(ZDelay*p)$/;"	f	class:simlib3::ZDelayTimer	signature:(ZDelay*p)
simlib3::ZDelayTimer::UnRegister	zdelay.h	/^    void UnRegister(ZDelay*); \/\/ remove from container$/;"	p	class:simlib3::ZDelayTimer	access:private	signature:(ZDelay*)
simlib3::ZDelayTimer::ZDelayContainer	zdelay.cc	/^class ZDelayTimer::ZDelayContainer { \/\/ implementation-defined container$/;"	c	class:simlib3::ZDelayTimer	file:
simlib3::ZDelayTimer::ZDelayContainer::ZDelayContainer	zdelay.cc	/^        ZDelayContainer(): c() {}$/;"	f	class:simlib3::ZDelayTimer::ZDelayContainer	access:public	signature:()
simlib3::ZDelayTimer::ZDelayContainer::begin	zdelay.cc	/^        iterator begin()        { return c.begin(); }$/;"	f	class:simlib3::ZDelayTimer::ZDelayContainer	access:public	signature:()
simlib3::ZDelayTimer::ZDelayContainer::c	zdelay.cc	/^        container_t c;$/;"	m	class:simlib3::ZDelayTimer::ZDelayContainer	file:	access:private
simlib3::ZDelayTimer::ZDelayContainer::clear	zdelay.cc	/^        void clear()            { c.clear(); }$/;"	f	class:simlib3::ZDelayTimer::ZDelayContainer	access:public	signature:()
simlib3::ZDelayTimer::ZDelayContainer::container_t	zdelay.cc	/^        typedef std::set<ZDelay*> container_t;$/;"	t	class:simlib3::ZDelayTimer::ZDelayContainer	file:	access:private
simlib3::ZDelayTimer::ZDelayContainer::end	zdelay.cc	/^        iterator end()          { return c.end(); }$/;"	f	class:simlib3::ZDelayTimer::ZDelayContainer	access:public	signature:()
simlib3::ZDelayTimer::ZDelayContainer::erase	zdelay.cc	/^        void erase(ZDelay * p)  { c.erase(p); }$/;"	f	class:simlib3::ZDelayTimer::ZDelayContainer	access:public	signature:(ZDelay * p)
simlib3::ZDelayTimer::ZDelayContainer::insert	zdelay.cc	/^        void insert(ZDelay * p) { c.insert(p); }$/;"	f	class:simlib3::ZDelayTimer::ZDelayContainer	access:public	signature:(ZDelay * p)
simlib3::ZDelayTimer::ZDelayContainer::iterator	zdelay.cc	/^        typedef container_t::iterator iterator;$/;"	t	class:simlib3::ZDelayTimer::ZDelayContainer	file:	access:public
simlib3::ZDelayTimer::ZDelayTimer	zdelay.cc	/^ZDelayTimer::ZDelayTimer(double step, bool is_default) :$/;"	f	class:simlib3::ZDelayTimer	signature:(double step, bool is_default)
simlib3::ZDelayTimer::ZDelayTimer	zdelay.h	/^    ZDelayTimer(const ZDelayTimer&); \/\/ ##$/;"	p	class:simlib3::ZDelayTimer	access:private	signature:(const ZDelayTimer&)
simlib3::ZDelayTimer::ZDelayTimer	zdelay.h	/^    ZDelayTimer(double dt, bool is_default = false);$/;"	p	class:simlib3::ZDelayTimer	access:public	signature:(double dt, bool is_default = false)
simlib3::ZDelayTimer::c	zdelay.h	/^    ZDelayContainer *c;$/;"	m	class:simlib3::ZDelayTimer	access:private
simlib3::ZDelayTimer::dt	zdelay.h	/^    double dt;          \/\/ clock period$/;"	m	class:simlib3::ZDelayTimer	access:private
simlib3::ZDelayTimer::operator =	zdelay.h	/^    ZDelayTimer&operator=(const ZDelayTimer&); \/\/ ##$/;"	p	class:simlib3::ZDelayTimer	access:private	signature:(const ZDelayTimer&)
simlib3::ZDelayTimer::operator ZDelayTimer *	zdelay.h	/^    operator ZDelayTimer * () { return this; }$/;"	f	class:simlib3::ZDelayTimer	access:public	signature:()
simlib3::ZDelayTimer::~ZDelayTimer	zdelay.cc	/^ZDelayTimer::~ZDelayTimer()$/;"	f	class:simlib3::ZDelayTimer	signature:()
simlib3::ZDelayTimer::~ZDelayTimer	zdelay.h	/^    ~ZDelayTimer();$/;"	p	class:simlib3::ZDelayTimer	access:public	signature:()
simlib3::Zpart	simlib3D.cc	/^Input Zpart(Input3D a) { return new _XYZpart(a, _XYZpart::z); }$/;"	f	namespace:simlib3	signature:(Input3D a)
simlib3::Zpart	simlib3D.h	/^Input Zpart(Input3D a);$/;"	p	namespace:simlib3	signature:(Input3D a)
simlib3::_Abs2D	simlib2D.cc	/^class _Abs2D: public aContiBlock {$/;"	c	namespace:simlib3	file:	inherits:aContiBlock
simlib3::_Abs2D::Value	simlib2D.cc	/^  virtual double Value() {$/;"	f	class:simlib3::_Abs2D	access:public	signature:()
simlib3::_Abs2D::_Abs2D	simlib2D.cc	/^  _Abs2D(Input2D a): in(a) {}$/;"	f	class:simlib3::_Abs2D	access:public	signature:(Input2D a)
simlib3::_Abs2D::_Eval	simlib2D.cc	/^  virtual void _Eval() {}$/;"	f	class:simlib3::_Abs2D	file:	access:private	signature:()
simlib3::_Abs2D::in	simlib2D.cc	/^  Input2D in;$/;"	m	class:simlib3::_Abs2D	file:	access:private
simlib3::_Abs3D	simlib3D.cc	/^class _Abs3D: public aContiBlock {$/;"	c	namespace:simlib3	file:	inherits:aContiBlock
simlib3::_Abs3D::Value	simlib3D.cc	/^  virtual double Value() {$/;"	f	class:simlib3::_Abs3D	access:public	signature:()
simlib3::_Abs3D::_Abs3D	simlib3D.cc	/^  _Abs3D(Input3D a): in(a) {}$/;"	f	class:simlib3::_Abs3D	access:public	signature:(Input3D a)
simlib3::_Abs3D::_Eval	simlib3D.cc	/^  virtual void _Eval() {}$/;"	f	class:simlib3::_Abs3D	file:	access:private	signature:()
simlib3::_Abs3D::in	simlib3D.cc	/^  Input3D in;$/;"	m	class:simlib3::_Abs3D	file:	access:private
simlib3::_Add	continuous.cc	/^class _Add : public aContiBlock2 {$/;"	c	namespace:simlib3	file:	inherits:aContiBlock2
simlib3::_Add2D	simlib2D.cc	/^class _Add2D : public aContiBlock2D2 {$/;"	c	namespace:simlib3	file:	inherits:aContiBlock2D2
simlib3::_Add2D::Value	simlib2D.cc	/^  virtual Value2D Value() {$/;"	f	class:simlib3::_Add2D	access:public	signature:()
simlib3::_Add2D::_Add2D	simlib2D.cc	/^  _Add2D(Input2D a, Input2D b): aContiBlock2D2(a,b) {$/;"	f	class:simlib3::_Add2D	access:public	signature:(Input2D a, Input2D b)
simlib3::_Add2D::_Eval	simlib2D.cc	/^  virtual void _Eval() {}$/;"	f	class:simlib3::_Add2D	file:	access:private	signature:()
simlib3::_Add3D	simlib3D.cc	/^class _Add3D : public aContiBlock3D2 {$/;"	c	namespace:simlib3	file:	inherits:aContiBlock3D2
simlib3::_Add3D::Value	simlib3D.cc	/^  virtual Value3D Value() {$/;"	f	class:simlib3::_Add3D	access:public	signature:()
simlib3::_Add3D::_Add3D	simlib3D.cc	/^  _Add3D(Input3D a, Input3D b): aContiBlock3D2(a,b) {$/;"	f	class:simlib3::_Add3D	access:public	signature:(Input3D a, Input3D b)
simlib3::_Add3D::_Eval	simlib3D.cc	/^  virtual void _Eval() {}$/;"	f	class:simlib3::_Add3D	file:	access:private	signature:()
simlib3::_Add::Eval	continuous.cc	/^  virtual void Eval() {}$/;"	f	class:simlib3::_Add	file:	access:private	signature:()
simlib3::_Add::Name	continuous.cc	/^  virtual const char *Name() const {$/;"	f	class:simlib3::_Add	access:public	signature:() const
simlib3::_Add::Value	continuous.cc	/^  virtual double Value() { return Input1Value() + Input2Value(); }$/;"	f	class:simlib3::_Add	access:public	signature:()
simlib3::_Add::_Add	continuous.cc	/^  _Add(Input a, Input b): aContiBlock2(a,b) {$/;"	f	class:simlib3::_Add	access:public	signature:(Input a, Input b)
simlib3::_Add::_Eval	continuous.cc	/^  virtual void _Eval() {}$/;"	f	class:simlib3::_Add	file:	access:private	signature:()
simlib3::_Add::~_Add	continuous.cc	/^  ~_Add() {$/;"	f	class:simlib3::_Add	access:public	signature:()
simlib3::_Div	continuous.cc	/^class _Div : public aContiBlock2 {$/;"	c	namespace:simlib3	file:	inherits:aContiBlock2
simlib3::_Div2D	simlib2D.cc	/^class _Div2D : public aContiBlock2D1 {$/;"	c	namespace:simlib3	file:	inherits:aContiBlock2D1
simlib3::_Div2D::Value	simlib2D.cc	/^  virtual Value2D Value() {$/;"	f	class:simlib3::_Div2D	access:public	signature:()
simlib3::_Div2D::_Div2D	simlib2D.cc	/^  _Div2D(Input2D a, Input b): aContiBlock2D1(a), _b(b) {$/;"	f	class:simlib3::_Div2D	access:public	signature:(Input2D a, Input b)
simlib3::_Div2D::_Eval	simlib2D.cc	/^  virtual void _Eval() {}$/;"	f	class:simlib3::_Div2D	file:	access:private	signature:()
simlib3::_Div2D::_b	simlib2D.cc	/^  Input _b;$/;"	m	class:simlib3::_Div2D	file:	access:private
simlib3::_Div3D	simlib3D.cc	/^class _Div3D : public aContiBlock3D1 {$/;"	c	namespace:simlib3	file:	inherits:aContiBlock3D1
simlib3::_Div3D::Value	simlib3D.cc	/^  virtual Value3D Value() {$/;"	f	class:simlib3::_Div3D	access:public	signature:()
simlib3::_Div3D::_Div3D	simlib3D.cc	/^  _Div3D(Input3D a, Input b): aContiBlock3D1(a), _b(b) {$/;"	f	class:simlib3::_Div3D	access:public	signature:(Input3D a, Input b)
simlib3::_Div3D::_Eval	simlib3D.cc	/^  virtual void _Eval() {}$/;"	f	class:simlib3::_Div3D	file:	access:private	signature:()
simlib3::_Div3D::_b	simlib3D.cc	/^  Input _b;$/;"	m	class:simlib3::_Div3D	file:	access:private
simlib3::_Div::Eval	continuous.cc	/^  virtual void Eval() {}$/;"	f	class:simlib3::_Div	file:	access:private	signature:()
simlib3::_Div::Name	continuous.cc	/^  virtual const char *Name() const {$/;"	f	class:simlib3::_Div	access:public	signature:() const
simlib3::_Div::Value	continuous.cc	/^  virtual double Value() { return Input1Value() \/ Input2Value(); }$/;"	f	class:simlib3::_Div	access:public	signature:()
simlib3::_Div::_Div	continuous.cc	/^  _Div(Input a, Input b): aContiBlock2(a,b) {$/;"	f	class:simlib3::_Div	access:public	signature:(Input a, Input b)
simlib3::_Div::_Eval	continuous.cc	/^  virtual void _Eval() {}$/;"	f	class:simlib3::_Div	file:	access:private	signature:()
simlib3::_Div::~_Div	continuous.cc	/^  ~_Div() {$/;"	f	class:simlib3::_Div	access:public	signature:()
simlib3::_ErrMsg	errors.cc	/^char *_ErrMsg(enum _ErrEnum N)$/;"	f	namespace:simlib3	signature:(enum _ErrEnum N)
simlib3::_Errors	errors.cc	/^static char _Errors[] = {$/;"	m	namespace:simlib3	file:
simlib3::_FileWrap	print.cc	/^class _FileWrap {$/;"	c	namespace:simlib3	file:
simlib3::_FileWrap::OutFile	print.cc	/^    static FILE *OutFile;$/;"	m	class:simlib3::_FileWrap	file:	access:private
simlib3::_FileWrap::OutFile	print.cc	/^FILE *_FileWrap::OutFile = 0;$/;"	m	class:simlib3::_FileWrap	file:
simlib3::_FileWrap::get	print.cc	/^    static FILE *get() {$/;"	f	class:simlib3::_FileWrap	file:	access:private	signature:()
simlib3::_FileWrap::operator =	print.cc	/^    void operator = (FILE *f)   { OutFile=f; }$/;"	f	class:simlib3::_FileWrap	access:public	signature:(FILE *f)
simlib3::_FileWrap::operator FILE *	print.cc	/^    operator FILE *()           { return get(); }$/;"	f	class:simlib3::_FileWrap	access:public	signature:()
simlib3::_GraphInit	graph.cc	/^void _GraphInit()$/;"	f	namespace:simlib3	signature:()
simlib3::_Mul	continuous.cc	/^class _Mul : public aContiBlock2 {$/;"	c	namespace:simlib3	file:	inherits:aContiBlock2
simlib3::_Mul2D1D	simlib2D.cc	/^class _Mul2D1D : public aContiBlock2D1 {$/;"	c	namespace:simlib3	file:	inherits:aContiBlock2D1
simlib3::_Mul2D1D::Value	simlib2D.cc	/^  virtual Value2D Value() {$/;"	f	class:simlib3::_Mul2D1D	access:public	signature:()
simlib3::_Mul2D1D::_Eval	simlib2D.cc	/^  virtual void _Eval() {}$/;"	f	class:simlib3::_Mul2D1D	file:	access:private	signature:()
simlib3::_Mul2D1D::_Mul2D1D	simlib2D.cc	/^  _Mul2D1D(Input2D a, Input b): aContiBlock2D1(a), _b(b) {$/;"	f	class:simlib3::_Mul2D1D	access:public	signature:(Input2D a, Input b)
simlib3::_Mul2D1D::_b	simlib2D.cc	/^  Input _b;$/;"	m	class:simlib3::_Mul2D1D	file:	access:private
simlib3::_Mul3D	simlib3D.cc	/^class _Mul3D : public aContiBlock3D2 {$/;"	c	namespace:simlib3	file:	inherits:aContiBlock3D2
simlib3::_Mul3D1D	simlib3D.cc	/^class _Mul3D1D : public aContiBlock3D1 {$/;"	c	namespace:simlib3	file:	inherits:aContiBlock3D1
simlib3::_Mul3D1D::Value	simlib3D.cc	/^  virtual Value3D Value() {$/;"	f	class:simlib3::_Mul3D1D	access:public	signature:()
simlib3::_Mul3D1D::_Eval	simlib3D.cc	/^  virtual void _Eval() {}$/;"	f	class:simlib3::_Mul3D1D	file:	access:private	signature:()
simlib3::_Mul3D1D::_Mul3D1D	simlib3D.cc	/^  _Mul3D1D(Input3D a, Input b): aContiBlock3D1(a), _b(b) {$/;"	f	class:simlib3::_Mul3D1D	access:public	signature:(Input3D a, Input b)
simlib3::_Mul3D1D::_b	simlib3D.cc	/^  Input _b;$/;"	m	class:simlib3::_Mul3D1D	file:	access:private
simlib3::_Mul3D::Value	simlib3D.cc	/^  virtual Value3D Value() {$/;"	f	class:simlib3::_Mul3D	access:public	signature:()
simlib3::_Mul3D::_Eval	simlib3D.cc	/^  virtual void _Eval() {}$/;"	f	class:simlib3::_Mul3D	file:	access:private	signature:()
simlib3::_Mul3D::_Mul3D	simlib3D.cc	/^  _Mul3D(Input3D a, Input3D b): aContiBlock3D2(a,b) {$/;"	f	class:simlib3::_Mul3D	access:public	signature:(Input3D a, Input3D b)
simlib3::_Mul::Eval	continuous.cc	/^  virtual void Eval() {}$/;"	f	class:simlib3::_Mul	file:	access:private	signature:()
simlib3::_Mul::Name	continuous.cc	/^  virtual const char *Name() const {$/;"	f	class:simlib3::_Mul	access:public	signature:() const
simlib3::_Mul::Value	continuous.cc	/^  virtual double Value() { return Input1Value() * Input2Value(); }$/;"	f	class:simlib3::_Mul	access:public	signature:()
simlib3::_Mul::_Eval	continuous.cc	/^  virtual void _Eval() {}$/;"	f	class:simlib3::_Mul	file:	access:private	signature:()
simlib3::_Mul::_Mul	continuous.cc	/^  _Mul(Input a, Input b): aContiBlock2(a,b) {$/;"	f	class:simlib3::_Mul	access:public	signature:(Input a, Input b)
simlib3::_Mul::~_Mul	continuous.cc	/^  ~_Mul() {$/;"	f	class:simlib3::_Mul	access:public	signature:()
simlib3::_Norm2D	simlib2D.cc	/^class _Norm2D: public aContiBlock2D1 {$/;"	c	namespace:simlib3	file:	inherits:aContiBlock2D1
simlib3::_Norm2D::Value	simlib2D.cc	/^  virtual Value2D Value() {$/;"	f	class:simlib3::_Norm2D	access:public	signature:()
simlib3::_Norm2D::_Eval	simlib2D.cc	/^  virtual void _Eval() {}$/;"	f	class:simlib3::_Norm2D	file:	access:private	signature:()
simlib3::_Norm2D::_Norm2D	simlib2D.cc	/^  _Norm2D(Input2D a): aContiBlock2D1(a) {}$/;"	f	class:simlib3::_Norm2D	access:public	signature:(Input2D a)
simlib3::_Norm3D	simlib3D.cc	/^class _Norm3D: public aContiBlock3D1 {$/;"	c	namespace:simlib3	file:	inherits:aContiBlock3D1
simlib3::_Norm3D::Value	simlib3D.cc	/^  virtual Value3D Value() {$/;"	f	class:simlib3::_Norm3D	access:public	signature:()
simlib3::_Norm3D::_Eval	simlib3D.cc	/^  virtual void _Eval() {}$/;"	f	class:simlib3::_Norm3D	file:	access:private	signature:()
simlib3::_Norm3D::_Norm3D	simlib3D.cc	/^  _Norm3D(Input3D a): aContiBlock3D1(a) {}$/;"	f	class:simlib3::_Norm3D	access:public	signature:(Input3D a)
simlib3::_Print	print.cc	/^int _Print(const char *fmt, ...)$/;"	f	namespace:simlib3	signature:(const char *fmt, ...)
simlib3::_Print	simlib.h	/^int  _Print(const char *fmt, ...);$/;"	p	namespace:simlib3	signature:(const char *fmt, ...)
simlib3::_ProcessDispatcherStatusBuffer	process.cc	/^static jmp_buf _ProcessDispatcherStatusBuffer;  \/\/ stack state before dispatch$/;"	m	namespace:simlib3	file:
simlib3::_ScalarProduct2D	simlib2D.cc	/^class _ScalarProduct2D: public aContiBlock {$/;"	c	namespace:simlib3	file:	inherits:aContiBlock
simlib3::_ScalarProduct2D::Value	simlib2D.cc	/^  virtual double Value() {$/;"	f	class:simlib3::_ScalarProduct2D	access:public	signature:()
simlib3::_ScalarProduct2D::_Eval	simlib2D.cc	/^  virtual void _Eval() {}$/;"	f	class:simlib3::_ScalarProduct2D	file:	access:private	signature:()
simlib3::_ScalarProduct2D::_ScalarProduct2D	simlib2D.cc	/^  _ScalarProduct2D(Input2D a, Input2D b): input1(a), input2(b) {}$/;"	f	class:simlib3::_ScalarProduct2D	access:public	signature:(Input2D a, Input2D b)
simlib3::_ScalarProduct2D::input1	simlib2D.cc	/^  Input2D input1;$/;"	m	class:simlib3::_ScalarProduct2D	file:	access:private
simlib3::_ScalarProduct2D::input2	simlib2D.cc	/^  Input2D input2;$/;"	m	class:simlib3::_ScalarProduct2D	file:	access:private
simlib3::_ScalarProduct3D	simlib3D.cc	/^class _ScalarProduct3D: public aContiBlock {$/;"	c	namespace:simlib3	file:	inherits:aContiBlock
simlib3::_ScalarProduct3D::Value	simlib3D.cc	/^  virtual double Value() {$/;"	f	class:simlib3::_ScalarProduct3D	access:public	signature:()
simlib3::_ScalarProduct3D::_Eval	simlib3D.cc	/^  virtual void _Eval() {}$/;"	f	class:simlib3::_ScalarProduct3D	file:	access:private	signature:()
simlib3::_ScalarProduct3D::_ScalarProduct3D	simlib3D.cc	/^  _ScalarProduct3D(Input3D a, Input3D b): input1(a), input2(b) {}$/;"	f	class:simlib3::_ScalarProduct3D	access:public	signature:(Input3D a, Input3D b)
simlib3::_ScalarProduct3D::input1	simlib3D.cc	/^  Input3D input1;$/;"	m	class:simlib3::_ScalarProduct3D	file:	access:private
simlib3::_ScalarProduct3D::input2	simlib3D.cc	/^  Input3D input2;$/;"	m	class:simlib3::_ScalarProduct3D	file:	access:private
simlib3::_StackBase	process.cc	/^static char *volatile _StackBase = 0;    \/\/ start of stack data area$/;"	m	namespace:simlib3	file:
simlib3::_StackBase2	process.cc	/^static char *volatile _StackBase2 = 0;   \/\/ CHECKING start of stack data area$/;"	m	namespace:simlib3	file:
simlib3::_StackSize	process.cc	/^static volatile size_t _StackSize = 0;   \/\/ temporary - global stack size$/;"	m	namespace:simlib3	file:
simlib3::_Sub	continuous.cc	/^class _Sub : public aContiBlock2 {$/;"	c	namespace:simlib3	file:	inherits:aContiBlock2
simlib3::_Sub2D	simlib2D.cc	/^class _Sub2D : public aContiBlock2D2 {$/;"	c	namespace:simlib3	file:	inherits:aContiBlock2D2
simlib3::_Sub2D::Value	simlib2D.cc	/^  virtual Value2D Value() {$/;"	f	class:simlib3::_Sub2D	access:public	signature:()
simlib3::_Sub2D::_Eval	simlib2D.cc	/^  virtual void _Eval() {}$/;"	f	class:simlib3::_Sub2D	file:	access:private	signature:()
simlib3::_Sub2D::_Sub2D	simlib2D.cc	/^  _Sub2D(Input2D a, Input2D b): aContiBlock2D2(a,b) {$/;"	f	class:simlib3::_Sub2D	access:public	signature:(Input2D a, Input2D b)
simlib3::_Sub3D	simlib3D.cc	/^class _Sub3D : public aContiBlock3D2 {$/;"	c	namespace:simlib3	file:	inherits:aContiBlock3D2
simlib3::_Sub3D::Value	simlib3D.cc	/^  virtual Value3D Value() {$/;"	f	class:simlib3::_Sub3D	access:public	signature:()
simlib3::_Sub3D::_Eval	simlib3D.cc	/^  virtual void _Eval() {}$/;"	f	class:simlib3::_Sub3D	file:	access:private	signature:()
simlib3::_Sub3D::_Sub3D	simlib3D.cc	/^  _Sub3D(Input3D a, Input3D b): aContiBlock3D2(a,b) {$/;"	f	class:simlib3::_Sub3D	access:public	signature:(Input3D a, Input3D b)
simlib3::_Sub::Eval	continuous.cc	/^  virtual void Eval() {}$/;"	f	class:simlib3::_Sub	file:	access:private	signature:()
simlib3::_Sub::Name	continuous.cc	/^  virtual const char *Name() const {$/;"	f	class:simlib3::_Sub	access:public	signature:() const
simlib3::_Sub::Value	continuous.cc	/^  virtual double Value() { return Input1Value() - Input2Value(); }$/;"	f	class:simlib3::_Sub	access:public	signature:()
simlib3::_Sub::_Eval	continuous.cc	/^  virtual void _Eval() {}$/;"	f	class:simlib3::_Sub	file:	access:private	signature:()
simlib3::_Sub::_Sub	continuous.cc	/^  _Sub(Input a, Input b): aContiBlock2(a,b) {$/;"	f	class:simlib3::_Sub	access:public	signature:(Input a, Input b)
simlib3::_Sub::~_Sub	continuous.cc	/^  ~_Sub() {$/;"	f	class:simlib3::_Sub	access:public	signature:()
simlib3::_T	continuous.cc	/^static class _Time _T;$/;"	m	namespace:simlib3	typeref:class:simlib3::_Time	file:
simlib3::_Time	continuous.cc	/^class _Time: public aContiBlock {$/;"	c	namespace:simlib3	file:	inherits:aContiBlock
simlib3::_Time::Name	continuous.cc	/^  virtual const char *Name() const { return "T(Time)"; }$/;"	f	class:simlib3::_Time	access:public	signature:() const
simlib3::_Time::Value	continuous.cc	/^  virtual double Value () { return Time; }$/;"	f	class:simlib3::_Time	access:public	signature:()
simlib3::_Time::_Time	continuous.cc	/^  _Time() {}$/;"	f	class:simlib3::_Time	access:public	signature:()
simlib3::_UMinus	continuous.cc	/^class _UMinus: public aContiBlock1 {$/;"	c	namespace:simlib3	file:	inherits:aContiBlock1
simlib3::_UMinus2D	simlib2D.cc	/^class _UMinus2D: public aContiBlock2D1 {$/;"	c	namespace:simlib3	file:	inherits:aContiBlock2D1
simlib3::_UMinus2D::Value	simlib2D.cc	/^  virtual Value2D Value() {$/;"	f	class:simlib3::_UMinus2D	access:public	signature:()
simlib3::_UMinus2D::_Eval	simlib2D.cc	/^  virtual void _Eval() {}$/;"	f	class:simlib3::_UMinus2D	file:	access:private	signature:()
simlib3::_UMinus2D::_UMinus2D	simlib2D.cc	/^  _UMinus2D(Input2D a): aContiBlock2D1(a) {$/;"	f	class:simlib3::_UMinus2D	access:public	signature:(Input2D a)
simlib3::_UMinus3D	simlib3D.cc	/^class _UMinus3D: public aContiBlock3D1 {$/;"	c	namespace:simlib3	file:	inherits:aContiBlock3D1
simlib3::_UMinus3D::Value	simlib3D.cc	/^  virtual Value3D Value() {$/;"	f	class:simlib3::_UMinus3D	access:public	signature:()
simlib3::_UMinus3D::_Eval	simlib3D.cc	/^  virtual void _Eval() {}$/;"	f	class:simlib3::_UMinus3D	file:	access:private	signature:()
simlib3::_UMinus3D::_UMinus3D	simlib3D.cc	/^  _UMinus3D(Input3D a): aContiBlock3D1(a) {$/;"	f	class:simlib3::_UMinus3D	access:public	signature:(Input3D a)
simlib3::_UMinus::Eval	continuous.cc	/^  virtual void Eval() {}$/;"	f	class:simlib3::_UMinus	file:	access:private	signature:()
simlib3::_UMinus::Name	continuous.cc	/^  virtual const char *Name() const {$/;"	f	class:simlib3::_UMinus	access:public	signature:() const
simlib3::_UMinus::Value	continuous.cc	/^  virtual double Value()    { return -InputValue(); }$/;"	f	class:simlib3::_UMinus	access:public	signature:()
simlib3::_UMinus::_Eval	continuous.cc	/^  virtual void _Eval() {}$/;"	f	class:simlib3::_UMinus	file:	access:private	signature:()
simlib3::_UMinus::_UMinus	continuous.cc	/^  _UMinus(Input a): aContiBlock1(a) {$/;"	f	class:simlib3::_UMinus	access:public	signature:(Input a)
simlib3::_UMinus::~_UMinus	continuous.cc	/^  ~_UMinus() {$/;"	f	class:simlib3::_UMinus	access:public	signature:()
simlib3::_XYZpart	simlib3D.cc	/^class _XYZpart: public aContiBlock {$/;"	c	namespace:simlib3	file:	inherits:aContiBlock
simlib3::_XYZpart::Value	simlib3D.cc	/^  virtual double Value() {$/;"	f	class:simlib3::_XYZpart	access:public	signature:()
simlib3::_XYZpart::WhichPart	simlib3D.cc	/^  enum WhichPart { x,y,z }; \/\/ part identification$/;"	g	class:simlib3::_XYZpart	file:	access:public
simlib3::_XYZpart::_Eval	simlib3D.cc	/^  virtual void _Eval() {}$/;"	f	class:simlib3::_XYZpart	file:	access:private	signature:()
simlib3::_XYZpart::_XYZpart	simlib3D.cc	/^  _XYZpart(Input3D a, WhichPart w): input(a), which(w) {}$/;"	f	class:simlib3::_XYZpart	access:public	signature:(Input3D a, WhichPart w)
simlib3::_XYZpart::input	simlib3D.cc	/^  Input3D input;$/;"	m	class:simlib3::_XYZpart	file:	access:private
simlib3::_XYZpart::which	simlib3D.cc	/^  WhichPart which;$/;"	m	class:simlib3::_XYZpart	file:	access:private
simlib3::_XYZpart::x	simlib3D.cc	/^  enum WhichPart { x,y,z }; \/\/ part identification$/;"	e	enum:simlib3::_XYZpart::WhichPart	file:
simlib3::_XYZpart::y	simlib3D.cc	/^  enum WhichPart { x,y,z }; \/\/ part identification$/;"	e	enum:simlib3::_XYZpart::WhichPart	file:
simlib3::_XYZpart::z	simlib3D.cc	/^  enum WhichPart { x,y,z }; \/\/ part identification$/;"	e	enum:simlib3::_XYZpart::WhichPart	file:
simlib3::_XYpart	simlib2D.cc	/^class _XYpart: public aContiBlock {$/;"	c	namespace:simlib3	file:	inherits:aContiBlock
simlib3::_XYpart::Value	simlib2D.cc	/^  virtual double Value() {$/;"	f	class:simlib3::_XYpart	access:public	signature:()
simlib3::_XYpart::WhichPart	simlib2D.cc	/^  enum WhichPart { x,y }; \/\/ part identification$/;"	g	class:simlib3::_XYpart	file:	access:public
simlib3::_XYpart::_Eval	simlib2D.cc	/^  virtual void _Eval() {}$/;"	f	class:simlib3::_XYpart	file:	access:private	signature:()
simlib3::_XYpart::_XYpart	simlib2D.cc	/^  _XYpart(Input2D a, WhichPart w): input(a), which(w) {}$/;"	f	class:simlib3::_XYpart	access:public	signature:(Input2D a, WhichPart w)
simlib3::_XYpart::input	simlib2D.cc	/^  Input2D input;$/;"	m	class:simlib3::_XYpart	file:	access:private
simlib3::_XYpart::which	simlib2D.cc	/^  WhichPart which;$/;"	m	class:simlib3::_XYpart	file:	access:private
simlib3::_XYpart::x	simlib2D.cc	/^  enum WhichPart { x,y }; \/\/ part identification$/;"	e	enum:simlib3::_XYpart::WhichPart	file:
simlib3::_XYpart::y	simlib2D.cc	/^  enum WhichPart { x,y }; \/\/ part identification$/;"	e	enum:simlib3::_XYpart::WhichPart	file:
simlib3::_gam	random2.cc	/^static double _gam(double AK)$/;"	f	namespace:simlib3	signature:(double AK)
simlib3::aBlock	simlib.h	/^class aBlock : public SimObject {                \/\/ base class$/;"	c	namespace:simlib3	inherits:SimObject
simlib3::aCondition	simlib.h	/^class aCondition : public aBlock {$/;"	c	namespace:simlib3	inherits:aBlock
simlib3::aCondition::Action	simlib.h	/^  virtual void Action()=0;             \/\/!< state event description$/;"	p	class:simlib3::aCondition	access:private	signature:()
simlib3::aCondition::AllActions	cond.cc	/^void aCondition::AllActions()$/;"	f	class:simlib3::aCondition	signature:()
simlib3::aCondition::AllActions	simlib.h	/^  static void AllActions();$/;"	p	class:simlib3::aCondition	access:public	signature:()
simlib3::aCondition::First	cond.cc	/^aCondition *aCondition::First = 0;       \/\/ condition list$/;"	m	class:simlib3::aCondition	file:
simlib3::aCondition::First	simlib.h	/^  static aCondition *First;            \/\/ list of all conditions$/;"	m	class:simlib3::aCondition	access:private
simlib3::aCondition::Init	simlib.h	/^  virtual void Init()=0;               \/\/!< initialize$/;"	p	class:simlib3::aCondition	access:private	signature:()
simlib3::aCondition::InitAll	cond.cc	/^void aCondition::InitAll() {$/;"	f	class:simlib3::aCondition	signature:()
simlib3::aCondition::InitAll	simlib.h	/^  static void InitAll();$/;"	p	class:simlib3::aCondition	access:public	signature:()
simlib3::aCondition::Next	simlib.h	/^  aCondition *Next;                    \/\/ next condition in list$/;"	m	class:simlib3::aCondition	access:private
simlib3::aCondition::SetAll	cond.cc	/^void aCondition::SetAll() {$/;"	f	class:simlib3::aCondition	signature:()
simlib3::aCondition::SetAll	simlib.h	/^  static void SetAll();$/;"	p	class:simlib3::aCondition	access:public	signature:()
simlib3::aCondition::SetNewStatus	simlib.h	/^  virtual void SetNewStatus()=0;       \/\/!< update$/;"	p	class:simlib3::aCondition	access:private	signature:()
simlib3::aCondition::Test	simlib.h	/^  virtual bool Test()=0;               \/\/!< test of the condition$/;"	p	class:simlib3::aCondition	access:private	signature:()
simlib3::aCondition::TestAll	cond.cc	/^void aCondition::TestAll()$/;"	f	class:simlib3::aCondition	signature:()
simlib3::aCondition::TestAll	simlib.h	/^  static void TestAll();$/;"	p	class:simlib3::aCondition	access:public	signature:()
simlib3::aCondition::Value	simlib.h	/^  virtual bool Value()=0;              \/\/!< state of the condition$/;"	p	class:simlib3::aCondition	access:public	signature:()
simlib3::aCondition::aCondition	cond.cc	/^aCondition::aCondition() :$/;"	f	class:simlib3::aCondition	signature:()
simlib3::aCondition::aCondition	simlib.h	/^  aCondition();$/;"	p	class:simlib3::aCondition	access:public	signature:()
simlib3::aCondition::aCondition	simlib.h	/^  aCondition(aCondition&);             \/\/ disable operation$/;"	p	class:simlib3::aCondition	access:private	signature:(aCondition&)
simlib3::aCondition::isAny	cond.cc	/^bool aCondition::isAny()  { return First!=0; }$/;"	f	class:simlib3::aCondition	signature:()
simlib3::aCondition::isAny	simlib.h	/^  static bool isAny();$/;"	p	class:simlib3::aCondition	access:public	signature:()
simlib3::aCondition::operator =	simlib.h	/^  void operator= (aCondition&);        \/\/ disable operation$/;"	p	class:simlib3::aCondition	access:private	signature:(aCondition&)
simlib3::aCondition::~aCondition	cond.cc	/^aCondition::~aCondition() {$/;"	f	class:simlib3::aCondition	signature:()
simlib3::aCondition::~aCondition	simlib.h	/^  ~aCondition();$/;"	p	class:simlib3::aCondition	access:public	signature:()
simlib3::aContiBlock	simlib.h	/^class aContiBlock : public aBlock {$/;"	c	namespace:simlib3	inherits:aBlock
simlib3::aContiBlock1	simlib.h	/^class aContiBlock1 : public aContiBlock {$/;"	c	namespace:simlib3	inherits:aContiBlock
simlib3::aContiBlock1::InputValue	simlib.h	/^  double InputValue() { return input.Value(); }$/;"	f	class:simlib3::aContiBlock1	access:public	signature:()
simlib3::aContiBlock1::aContiBlock1	continuous.cc	/^aContiBlock1::aContiBlock1(Input i) : input(i)$/;"	f	class:simlib3::aContiBlock1	signature:(Input i)
simlib3::aContiBlock1::aContiBlock1	simlib.h	/^  aContiBlock1(Input i);$/;"	p	class:simlib3::aContiBlock1	access:public	signature:(Input i)
simlib3::aContiBlock1::input	simlib.h	/^  Input input;$/;"	m	class:simlib3::aContiBlock1	access:private
simlib3::aContiBlock2	simlib.h	/^class aContiBlock2 : public aContiBlock {$/;"	c	namespace:simlib3	inherits:aContiBlock
simlib3::aContiBlock2::Input1Value	simlib.h	/^  double Input1Value() { return input1.Value(); }$/;"	f	class:simlib3::aContiBlock2	access:public	signature:()
simlib3::aContiBlock2::Input2Value	simlib.h	/^  double Input2Value() { return input2.Value(); }$/;"	f	class:simlib3::aContiBlock2	access:public	signature:()
simlib3::aContiBlock2::aContiBlock2	continuous.cc	/^aContiBlock2::aContiBlock2(Input i1, Input i2) : input1(i1), input2(i2)$/;"	f	class:simlib3::aContiBlock2	signature:(Input i1, Input i2)
simlib3::aContiBlock2::aContiBlock2	simlib.h	/^  aContiBlock2(Input i1, Input i2);$/;"	p	class:simlib3::aContiBlock2	access:public	signature:(Input i1, Input i2)
simlib3::aContiBlock2::input1	simlib.h	/^  Input input1;$/;"	m	class:simlib3::aContiBlock2	access:private
simlib3::aContiBlock2::input2	simlib.h	/^  Input input2;$/;"	m	class:simlib3::aContiBlock2	access:private
simlib3::aContiBlock2D	simlib2D.h	/^class aContiBlock2D : public aBlock {  \/\/ abstract continuous block$/;"	c	namespace:simlib3	inherits:aBlock
simlib3::aContiBlock2D1	simlib2D.h	/^class aContiBlock2D1 : public aContiBlock2D {$/;"	c	namespace:simlib3	inherits:aContiBlock2D
simlib3::aContiBlock2D1::InputValue	simlib2D.h	/^  Value2D InputValue() { return input.Value(); }$/;"	f	class:simlib3::aContiBlock2D1	access:public	signature:()
simlib3::aContiBlock2D1::SetInput	simlib2D.h	/^  Input2D SetInput(Input2D i) { return input.Set(i); }$/;"	f	class:simlib3::aContiBlock2D1	access:public	signature:(Input2D i)
simlib3::aContiBlock2D1::aContiBlock2D1	simlib2D.cc	/^aContiBlock2D1::aContiBlock2D1(Input2D i) : input(i)$/;"	f	class:simlib3::aContiBlock2D1	signature:(Input2D i)
simlib3::aContiBlock2D1::aContiBlock2D1	simlib2D.h	/^  explicit aContiBlock2D1(Input2D i);$/;"	p	class:simlib3::aContiBlock2D1	access:public	signature:(Input2D i)
simlib3::aContiBlock2D1::input	simlib2D.h	/^  Input2D input;$/;"	m	class:simlib3::aContiBlock2D1	access:private
simlib3::aContiBlock2D2	simlib2D.h	/^class aContiBlock2D2 : public aContiBlock2D {$/;"	c	namespace:simlib3	inherits:aContiBlock2D
simlib3::aContiBlock2D2::Input1Value	simlib2D.h	/^  Value2D Input1Value() { return input1.Value(); }$/;"	f	class:simlib3::aContiBlock2D2	access:public	signature:()
simlib3::aContiBlock2D2::Input2Value	simlib2D.h	/^  Value2D Input2Value() { return input2.Value(); }$/;"	f	class:simlib3::aContiBlock2D2	access:public	signature:()
simlib3::aContiBlock2D2::aContiBlock2D2	simlib2D.cc	/^aContiBlock2D2::aContiBlock2D2(Input2D i1, Input2D i2)$/;"	f	class:simlib3::aContiBlock2D2	signature:(Input2D i1, Input2D i2)
simlib3::aContiBlock2D2::aContiBlock2D2	simlib2D.h	/^  aContiBlock2D2(Input2D i1, Input2D i2);$/;"	p	class:simlib3::aContiBlock2D2	access:public	signature:(Input2D i1, Input2D i2)
simlib3::aContiBlock2D2::input1	simlib2D.h	/^  Input2D input1;$/;"	m	class:simlib3::aContiBlock2D2	access:private
simlib3::aContiBlock2D2::input2	simlib2D.h	/^  Input2D input2;$/;"	m	class:simlib3::aContiBlock2D2	access:private
simlib3::aContiBlock2D3	simlib2D.h	/^class aContiBlock2D3 : public aContiBlock2D2 {$/;"	c	namespace:simlib3	inherits:aContiBlock2D2
simlib3::aContiBlock2D3::Input3Value	simlib2D.h	/^  Value2D Input3Value() { return input3.Value(); }$/;"	f	class:simlib3::aContiBlock2D3	access:public	signature:()
simlib3::aContiBlock2D3::aContiBlock2D3	simlib2D.cc	/^aContiBlock2D3::aContiBlock2D3(Input2D i1, Input2D i2, Input2D i3)$/;"	f	class:simlib3::aContiBlock2D3	signature:(Input2D i1, Input2D i2, Input2D i3)
simlib3::aContiBlock2D3::aContiBlock2D3	simlib2D.h	/^  aContiBlock2D3(Input2D i1, Input2D i2, Input2D i3);$/;"	p	class:simlib3::aContiBlock2D3	access:public	signature:(Input2D i1, Input2D i2, Input2D i3)
simlib3::aContiBlock2D3::input3	simlib2D.h	/^  Input2D input3;$/;"	m	class:simlib3::aContiBlock2D3	access:private
simlib3::aContiBlock2D::Eval	simlib2D.h	/^  virtual void Eval() {};            \/\/ evaluate without loop detection$/;"	f	class:simlib3::aContiBlock2D	access:private	signature:()
simlib3::aContiBlock2D::Print	simlib2D.cc	/^void aContiBlock2D::Print() {$/;"	f	class:simlib3::aContiBlock2D	signature:()
simlib3::aContiBlock2D::Print	simlib2D.h	/^  void Print();                      \/\/ print value$/;"	p	class:simlib3::aContiBlock2D	access:public	signature:()
simlib3::aContiBlock2D::Value	simlib2D.h	/^  virtual Value2D Value() = 0;       \/\/ output value$/;"	p	class:simlib3::aContiBlock2D	access:public	signature:()
simlib3::aContiBlock2D::_Eval	simlib2D.cc	/^void aContiBlock2D::_Eval()$/;"	f	class:simlib3::aContiBlock2D	signature:()
simlib3::aContiBlock2D::_Eval	simlib2D.h	/^  virtual void _Eval();              \/\/ evaluate with loop detection$/;"	p	class:simlib3::aContiBlock2D	access:public	signature:()
simlib3::aContiBlock2D::aContiBlock2D	simlib2D.cc	/^aContiBlock2D::aContiBlock2D():$/;"	f	class:simlib3::aContiBlock2D	signature:()
simlib3::aContiBlock2D::aContiBlock2D	simlib2D.h	/^  aContiBlock2D();$/;"	p	class:simlib3::aContiBlock2D	access:public	signature:()
simlib3::aContiBlock2D::aContiBlock2D	simlib2D.h	/^  aContiBlock2D(const aContiBlock2D&); \/\/ disable copy ctr$/;"	p	class:simlib3::aContiBlock2D	access:private	signature:(const aContiBlock2D&)
simlib3::aContiBlock2D::isEvaluated	simlib2D.h	/^  bool isEvaluated;                  \/\/ flag for loop checking ###---$/;"	m	class:simlib3::aContiBlock2D	access:protected
simlib3::aContiBlock2D::operator =	simlib2D.h	/^  void operator= (aContiBlock2D&);     \/\/ disable assignment$/;"	p	class:simlib3::aContiBlock2D	access:private	signature:(aContiBlock2D&)
simlib3::aContiBlock2D::~aContiBlock2D	simlib2D.cc	/^aContiBlock2D::~aContiBlock2D() {$/;"	f	class:simlib3::aContiBlock2D	signature:()
simlib3::aContiBlock2D::~aContiBlock2D	simlib2D.h	/^  ~aContiBlock2D();$/;"	p	class:simlib3::aContiBlock2D	access:public	signature:()
simlib3::aContiBlock3	simlib.h	/^class aContiBlock3 : public aContiBlock {$/;"	c	namespace:simlib3	inherits:aContiBlock
simlib3::aContiBlock3::Input1Value	simlib.h	/^  double Input1Value() { return input1.Value(); }$/;"	f	class:simlib3::aContiBlock3	access:public	signature:()
simlib3::aContiBlock3::Input2Value	simlib.h	/^  double Input2Value() { return input2.Value(); }$/;"	f	class:simlib3::aContiBlock3	access:public	signature:()
simlib3::aContiBlock3::Input3Value	simlib.h	/^  double Input3Value() { return input3.Value(); }$/;"	f	class:simlib3::aContiBlock3	access:public	signature:()
simlib3::aContiBlock3::aContiBlock3	continuous.cc	/^aContiBlock3::aContiBlock3(Input i1, Input i2, Input i3)$/;"	f	class:simlib3::aContiBlock3	signature:(Input i1, Input i2, Input i3)
simlib3::aContiBlock3::aContiBlock3	simlib.h	/^  aContiBlock3(Input i1, Input i2, Input i3);$/;"	p	class:simlib3::aContiBlock3	access:public	signature:(Input i1, Input i2, Input i3)
simlib3::aContiBlock3::input1	simlib.h	/^  Input input1;$/;"	m	class:simlib3::aContiBlock3	access:private
simlib3::aContiBlock3::input2	simlib.h	/^  Input input2;$/;"	m	class:simlib3::aContiBlock3	access:private
simlib3::aContiBlock3::input3	simlib.h	/^  Input input3;$/;"	m	class:simlib3::aContiBlock3	access:private
simlib3::aContiBlock3D	simlib3D.h	/^class aContiBlock3D : public aBlock {  \/\/ abstract continuous block$/;"	c	namespace:simlib3	inherits:aBlock
simlib3::aContiBlock3D1	simlib3D.h	/^class aContiBlock3D1 : public aContiBlock3D {$/;"	c	namespace:simlib3	inherits:aContiBlock3D
simlib3::aContiBlock3D1::InputValue	simlib3D.h	/^  Value3D InputValue() { return input.Value(); }$/;"	f	class:simlib3::aContiBlock3D1	access:public	signature:()
simlib3::aContiBlock3D1::SetInput	simlib3D.h	/^  Input3D SetInput(Input3D i) { return input.Set(i); }$/;"	f	class:simlib3::aContiBlock3D1	access:public	signature:(Input3D i)
simlib3::aContiBlock3D1::aContiBlock3D1	simlib3D.cc	/^aContiBlock3D1::aContiBlock3D1(Input3D i) : input(i)$/;"	f	class:simlib3::aContiBlock3D1	signature:(Input3D i)
simlib3::aContiBlock3D1::aContiBlock3D1	simlib3D.h	/^  explicit aContiBlock3D1(Input3D i);$/;"	p	class:simlib3::aContiBlock3D1	access:public	signature:(Input3D i)
simlib3::aContiBlock3D1::input	simlib3D.h	/^  Input3D input;$/;"	m	class:simlib3::aContiBlock3D1	access:private
simlib3::aContiBlock3D2	simlib3D.h	/^class aContiBlock3D2 : public aContiBlock3D {$/;"	c	namespace:simlib3	inherits:aContiBlock3D
simlib3::aContiBlock3D2::Input1Value	simlib3D.h	/^  Value3D Input1Value() { return input1.Value(); }$/;"	f	class:simlib3::aContiBlock3D2	access:public	signature:()
simlib3::aContiBlock3D2::Input2Value	simlib3D.h	/^  Value3D Input2Value() { return input2.Value(); }$/;"	f	class:simlib3::aContiBlock3D2	access:public	signature:()
simlib3::aContiBlock3D2::aContiBlock3D2	simlib3D.cc	/^aContiBlock3D2::aContiBlock3D2(Input3D i1, Input3D i2)$/;"	f	class:simlib3::aContiBlock3D2	signature:(Input3D i1, Input3D i2)
simlib3::aContiBlock3D2::aContiBlock3D2	simlib3D.h	/^  aContiBlock3D2(Input3D i1, Input3D i2);$/;"	p	class:simlib3::aContiBlock3D2	access:public	signature:(Input3D i1, Input3D i2)
simlib3::aContiBlock3D2::input1	simlib3D.h	/^  Input3D input1;$/;"	m	class:simlib3::aContiBlock3D2	access:private
simlib3::aContiBlock3D2::input2	simlib3D.h	/^  Input3D input2;$/;"	m	class:simlib3::aContiBlock3D2	access:private
simlib3::aContiBlock3D3	simlib3D.h	/^class aContiBlock3D3 : public aContiBlock3D2 {$/;"	c	namespace:simlib3	inherits:aContiBlock3D2
simlib3::aContiBlock3D3::Input3Value	simlib3D.h	/^  Value3D Input3Value() { return input3.Value(); }$/;"	f	class:simlib3::aContiBlock3D3	access:public	signature:()
simlib3::aContiBlock3D3::aContiBlock3D3	simlib3D.cc	/^aContiBlock3D3::aContiBlock3D3(Input3D i1, Input3D i2, Input3D i3)$/;"	f	class:simlib3::aContiBlock3D3	signature:(Input3D i1, Input3D i2, Input3D i3)
simlib3::aContiBlock3D3::aContiBlock3D3	simlib3D.h	/^  aContiBlock3D3(Input3D i1, Input3D i2, Input3D i3);$/;"	p	class:simlib3::aContiBlock3D3	access:public	signature:(Input3D i1, Input3D i2, Input3D i3)
simlib3::aContiBlock3D3::input3	simlib3D.h	/^  Input3D input3;$/;"	m	class:simlib3::aContiBlock3D3	access:private
simlib3::aContiBlock3D::Eval	simlib3D.h	/^  virtual void Eval() {};            \/\/ evaluate without loop detection$/;"	f	class:simlib3::aContiBlock3D	access:private	signature:()
simlib3::aContiBlock3D::Print	simlib3D.cc	/^void aContiBlock3D::Print() {$/;"	f	class:simlib3::aContiBlock3D	signature:()
simlib3::aContiBlock3D::Print	simlib3D.h	/^  void Print();                      \/\/ print value$/;"	p	class:simlib3::aContiBlock3D	access:public	signature:()
simlib3::aContiBlock3D::Value	simlib3D.h	/^  virtual Value3D Value() = 0;       \/\/ output value$/;"	p	class:simlib3::aContiBlock3D	access:public	signature:()
simlib3::aContiBlock3D::_Eval	simlib3D.cc	/^void aContiBlock3D::_Eval()$/;"	f	class:simlib3::aContiBlock3D	signature:()
simlib3::aContiBlock3D::_Eval	simlib3D.h	/^  virtual void _Eval();              \/\/ evaluate with loop detection$/;"	p	class:simlib3::aContiBlock3D	access:public	signature:()
simlib3::aContiBlock3D::aContiBlock3D	simlib3D.cc	/^aContiBlock3D::aContiBlock3D():$/;"	f	class:simlib3::aContiBlock3D	signature:()
simlib3::aContiBlock3D::aContiBlock3D	simlib3D.h	/^  aContiBlock3D();$/;"	p	class:simlib3::aContiBlock3D	access:public	signature:()
simlib3::aContiBlock3D::aContiBlock3D	simlib3D.h	/^  aContiBlock3D(const aContiBlock3D&); \/\/ disable copy ctr$/;"	p	class:simlib3::aContiBlock3D	access:private	signature:(const aContiBlock3D&)
simlib3::aContiBlock3D::isEvaluated	simlib3D.h	/^  bool isEvaluated;                  \/\/ flag for loop checking ###---$/;"	m	class:simlib3::aContiBlock3D	access:protected
simlib3::aContiBlock3D::operator =	simlib3D.h	/^  void operator= (aContiBlock3D&);     \/\/ disable assignment$/;"	p	class:simlib3::aContiBlock3D	access:private	signature:(aContiBlock3D&)
simlib3::aContiBlock3D::~aContiBlock3D	simlib3D.cc	/^aContiBlock3D::~aContiBlock3D() {$/;"	f	class:simlib3::aContiBlock3D	signature:()
simlib3::aContiBlock3D::~aContiBlock3D	simlib3D.h	/^  ~aContiBlock3D();$/;"	p	class:simlib3::aContiBlock3D	access:public	signature:()
simlib3::aContiBlock::Eval	simlib.h	/^    virtual void Eval() {};$/;"	f	class:simlib3::aContiBlock	access:private	signature:()
simlib3::aContiBlock::Value	simlib.h	/^    virtual double Value() = 0;$/;"	p	class:simlib3::aContiBlock	access:public	signature:()
simlib3::aContiBlock::_Eval	continuous.cc	/^void aContiBlock::_Eval()$/;"	f	class:simlib3::aContiBlock	signature:()
simlib3::aContiBlock::_Eval	simlib.h	/^    virtual void _Eval();       \/\/!< evaluate block (with loop detection)$/;"	p	class:simlib3::aContiBlock	access:public	signature:()
simlib3::aContiBlock::aContiBlock	simlib.h	/^    aContiBlock(): isEvaluated(false) {}$/;"	f	class:simlib3::aContiBlock	access:public	signature:()
simlib3::aContiBlock::aContiBlock	simlib.h	/^    aContiBlock(const aContiBlock&);            \/\/ disable copy ctr$/;"	p	class:simlib3::aContiBlock	access:private	signature:(const aContiBlock&)
simlib3::aContiBlock::isEvaluated	simlib.h	/^    bool isEvaluated;                   \/\/TODO:remove this flag for algebraic loop detection$/;"	m	class:simlib3::aContiBlock	access:protected
simlib3::aContiBlock::operator =	simlib.h	/^    void operator= (const aContiBlock&);        \/\/ disable assignment$/;"	p	class:simlib3::aContiBlock	access:private	signature:(const aContiBlock&)
simlib3::aStat	simlib.h	/^class aStat : public SimObject {$/;"	c	namespace:simlib3	inherits:SimObject
simlib3::aStat::Clear	simlib.h	/^  virtual void Clear() = 0;                 \/\/ initialize$/;"	p	class:simlib3::aStat	access:public	signature:()
simlib3::aStat::Max	simlib.h	/^  double Max() const { \/* test n==0 *\/ return max; }$/;"	f	class:simlib3::aStat	access:public	signature:() const
simlib3::aStat::MeanValue	simlib.h	/^  virtual double MeanValue() = 0;           \/\/!< compute mean value$/;"	p	class:simlib3::aStat	access:public	signature:()
simlib3::aStat::Min	simlib.h	/^  double Min() const { \/* test n==0 +exception *\/ return min; }$/;"	f	class:simlib3::aStat	access:public	signature:() const
simlib3::aStat::NumberOfRecords	simlib.h	/^  unsigned long NumberOfRecords() const { return n; }$/;"	f	class:simlib3::aStat	access:public	signature:() const
simlib3::aStat::Output	simlib.h	/^  virtual void Output() const;        \/\/!< Print all values to output file$/;"	p	class:simlib3::aStat	access:public	signature:() const
simlib3::aStat::Record	simlib.h	/^  virtual void Record(double x) = 0;        \/\/!< record value$/;"	p	class:simlib3::aStat	access:public	signature:(double x)
simlib3::aStat::aStat	simlib.h	/^  aStat();$/;"	p	class:simlib3::aStat	access:public	signature:()
simlib3::aStat::aStat	simlib.h	/^  aStat(const char *name);$/;"	p	class:simlib3::aStat	access:public	signature:(const char *name)
simlib3::aStat::max	simlib.h	/^  double max;                   \/\/ maximal recorded value$/;"	m	class:simlib3::aStat	access:protected
simlib3::aStat::min	simlib.h	/^  double min;                   \/\/ minimal recorded value$/;"	m	class:simlib3::aStat	access:protected
simlib3::aStat::n	simlib.h	/^  unsigned long n;              \/\/ number of values recorded$/;"	m	class:simlib3::aStat	access:protected
simlib3::aStat::operator ()	simlib.h	/^  virtual void operator () (double x) = 0;  \/\/!< record value$/;"	p	class:simlib3::aStat	access:public	signature:(double x)
simlib3::aStat::~aStat	simlib.h	/^  ~aStat();$/;"	p	class:simlib3::aStat	access:public	signature:()
simlib3::abm_ord	ni_abm4.h	/^const int abm_ord=4;$/;"	m	namespace:simlib3
simlib3::abs	simlib2D.cc	/^double abs(const Value2D &a)$/;"	f	namespace:simlib3	signature:(const Value2D &a)
simlib3::abs	simlib3D.cc	/^double abs(const Value3D &a)$/;"	f	namespace:simlib3	signature:(const Value3D &a)
simlib3::accept_bad	opt-simann.cc	/^bool accept_bad(double eps)$/;"	f	namespace:simlib3	signature:(double eps)
simlib3::allocator	calendar.cc	/^} allocator;  \/\/ global allocator TODO: improve -> singleton$/;"	m	namespace:simlib3	typeref:class:simlib3::EventNoticeAllocator	file:
simlib3::atexit_array	atexit.cc	/^static SIMLIB_atexit_function_t atexit_array[MAX_ATEXIT] = { 0, };$/;"	m	namespace:simlib3	file:
simlib3::cal_cost_flag	calendar.cc	/^int      cal_cost_flag;$/;"	m	namespace:simlib3	file:
simlib3::cal_cost_op	calendar.cc	/^const char * cal_cost_op;$/;"	m	namespace:simlib3	file:
simlib3::cal_cost_size	calendar.cc	/^unsigned cal_cost_size;$/;"	m	namespace:simlib3	file:
simlib3::cal_cost_time	calendar.cc	/^double   cal_cost_time;$/;"	m	namespace:simlib3	file:
simlib3::counter	atexit.cc	/^static int counter = 0; \/\/ internal module counter$/;"	m	namespace:simlib3	file:
simlib3::flag	waitunti.cc	/^static bool flag = false; \/\/ valid iterator in WUList$/;"	m	namespace:simlib3	file:
simlib3::hooke_step	opt-hooke.cc	/^static double hooke_step(double *delta, opt_function_t f, ParameterVector & p,$/;"	f	namespace:simlib3	signature:(double *delta, opt_function_t f, ParameterVector & p, double min0)
simlib3::max	internal.h	/^inline double max(double a, double b) { return ((a)>(b)?(a):(b)); }$/;"	f	namespace:simlib3	signature:(double a, double b)
simlib3::min	internal.h	/^inline double min(double a, double b) { return ((a)>(b)?(b):(a)); }$/;"	f	namespace:simlib3	signature:(double a, double b)
simlib3::move_to_next_point	opt-simann.cc	/^void move_to_next_point(ParameterVector & p, double eps)$/;"	f	namespace:simlib3	signature:(ParameterVector & p, double eps)
simlib3::myint32	random1.cc	/^typedef int myint32;      \/\/ long has >32 bits$/;"	t	namespace:simlib3	file:
simlib3::myint32	random1.cc	/^typedef long myint32;     \/\/ long has 32 bits$/;"	t	namespace:simlib3	file:
simlib3::operator *	continuous.cc	/^Input operator * (Input a, Input b) { return new _Mul(a,b); }$/;"	f	namespace:simlib3	signature:(Input a, Input b)
simlib3::operator *	simlib.h	/^Input operator * (Input a, Input b);$/;"	p	namespace:simlib3	signature:(Input a, Input b)
simlib3::operator *	simlib2D.cc	/^Input2D operator * (Input a, Input2D b)   { return new _Mul2D1D(b,a); }$/;"	f	namespace:simlib3	signature:(Input a, Input2D b)
simlib3::operator *	simlib2D.cc	/^Input2D operator * (Input2D a, Input b)   { return new _Mul2D1D(a,b); }$/;"	f	namespace:simlib3	signature:(Input2D a, Input b)
simlib3::operator *	simlib2D.cc	/^Value2D operator *(const Value2D& a, const double b)$/;"	f	namespace:simlib3	signature:(const Value2D& a, const double b)
simlib3::operator *	simlib2D.cc	/^Value2D operator *(const double a, const Value2D& b)$/;"	f	namespace:simlib3	signature:(const double a, const Value2D& b)
simlib3::operator *	simlib2D.h	/^Input2D operator * (Input a, Input2D b);        \/\/ scalar * vector$/;"	p	namespace:simlib3	signature:(Input a, Input2D b)
simlib3::operator *	simlib2D.h	/^Input2D operator * (Input2D a, Input b);        \/\/ vector * scalar$/;"	p	namespace:simlib3	signature:(Input2D a, Input b)
simlib3::operator *	simlib3D.cc	/^Input3D operator * (Input a, Input3D b)   { return new _Mul3D1D(b,a); }$/;"	f	namespace:simlib3	signature:(Input a, Input3D b)
simlib3::operator *	simlib3D.cc	/^Input3D operator * (Input3D a, Input b)   { return new _Mul3D1D(a,b); }$/;"	f	namespace:simlib3	signature:(Input3D a, Input b)
simlib3::operator *	simlib3D.cc	/^Input3D operator * (Input3D a, Input3D b) { return new _Mul3D(a,b); }$/;"	f	namespace:simlib3	signature:(Input3D a, Input3D b)
simlib3::operator *	simlib3D.cc	/^Value3D operator *(const Value3D& a, const Value3D &b)$/;"	f	namespace:simlib3	signature:(const Value3D& a, const Value3D &b)
simlib3::operator *	simlib3D.cc	/^Value3D operator *(const Value3D& a, const double b)$/;"	f	namespace:simlib3	signature:(const Value3D& a, const double b)
simlib3::operator *	simlib3D.cc	/^Value3D operator *(const double a, const Value3D& b)$/;"	f	namespace:simlib3	signature:(const double a, const Value3D& b)
simlib3::operator *	simlib3D.h	/^Input3D operator * (Input a, Input3D b);        \/\/ scalar * vector$/;"	p	namespace:simlib3	signature:(Input a, Input3D b)
simlib3::operator *	simlib3D.h	/^Input3D operator * (Input3D a, Input b);        \/\/ vector * scalar$/;"	p	namespace:simlib3	signature:(Input3D a, Input b)
simlib3::operator *	simlib3D.h	/^Input3D operator * (Input3D a, Input3D b);      \/\/ vector multiplication$/;"	p	namespace:simlib3	signature:(Input3D a, Input3D b)
simlib3::operator +	continuous.cc	/^Input operator + (Input a, Input b) { return new _Add(a,b); }$/;"	f	namespace:simlib3	signature:(Input a, Input b)
simlib3::operator +	simlib.h	/^Input operator + (Input a, Input b);$/;"	p	namespace:simlib3	signature:(Input a, Input b)
simlib3::operator +	simlib2D.cc	/^Input2D operator + (Input2D a, Input2D b) { return new _Add2D(a,b); }$/;"	f	namespace:simlib3	signature:(Input2D a, Input2D b)
simlib3::operator +	simlib2D.cc	/^Value2D operator +(const Value2D& a, const Value2D &b)$/;"	f	namespace:simlib3	signature:(const Value2D& a, const Value2D &b)
simlib3::operator +	simlib2D.h	/^Input2D operator + (Input2D a, Input2D b);      \/\/ add vectors$/;"	p	namespace:simlib3	signature:(Input2D a, Input2D b)
simlib3::operator +	simlib3D.cc	/^Input3D operator + (Input3D a, Input3D b) { return new _Add3D(a,b); }$/;"	f	namespace:simlib3	signature:(Input3D a, Input3D b)
simlib3::operator +	simlib3D.cc	/^Value3D operator +(const Value3D& a, const Value3D &b)$/;"	f	namespace:simlib3	signature:(const Value3D& a, const Value3D &b)
simlib3::operator +	simlib3D.h	/^Input3D operator + (Input3D a, Input3D b);      \/\/ add vectors$/;"	p	namespace:simlib3	signature:(Input3D a, Input3D b)
simlib3::operator -	continuous.cc	/^Input operator - (Input a) { return new _UMinus(a); }$/;"	f	namespace:simlib3	signature:(Input a)
simlib3::operator -	continuous.cc	/^Input operator - (Input a, Input b) { return new _Sub(a,b); }$/;"	f	namespace:simlib3	signature:(Input a, Input b)
simlib3::operator -	simlib.h	/^Input operator - (Input a);$/;"	p	namespace:simlib3	signature:(Input a)
simlib3::operator -	simlib.h	/^Input operator - (Input a, Input b);$/;"	p	namespace:simlib3	signature:(Input a, Input b)
simlib3::operator -	simlib2D.cc	/^Input2D operator - (Input2D a) { return new _UMinus2D(a); }$/;"	f	namespace:simlib3	signature:(Input2D a)
simlib3::operator -	simlib2D.cc	/^Input2D operator - (Input2D a, Input2D b) { return new _Sub2D(a,b); }$/;"	f	namespace:simlib3	signature:(Input2D a, Input2D b)
simlib3::operator -	simlib2D.cc	/^Value2D operator -(const Value2D& a)$/;"	f	namespace:simlib3	signature:(const Value2D& a)
simlib3::operator -	simlib2D.cc	/^Value2D operator -(const Value2D& a, const Value2D &b)$/;"	f	namespace:simlib3	signature:(const Value2D& a, const Value2D &b)
simlib3::operator -	simlib2D.h	/^Input2D operator - (Input2D a);                 \/\/ unary -$/;"	p	namespace:simlib3	signature:(Input2D a)
simlib3::operator -	simlib2D.h	/^Input2D operator - (Input2D a, Input2D b);      \/\/ subtract vectors$/;"	p	namespace:simlib3	signature:(Input2D a, Input2D b)
simlib3::operator -	simlib3D.cc	/^Input3D operator - (Input3D a) { return new _UMinus3D(a); }$/;"	f	namespace:simlib3	signature:(Input3D a)
simlib3::operator -	simlib3D.cc	/^Input3D operator - (Input3D a, Input3D b) { return new _Sub3D(a,b); }$/;"	f	namespace:simlib3	signature:(Input3D a, Input3D b)
simlib3::operator -	simlib3D.cc	/^Value3D operator -(const Value3D& a)$/;"	f	namespace:simlib3	signature:(const Value3D& a)
simlib3::operator -	simlib3D.cc	/^Value3D operator -(const Value3D& a, const Value3D &b)$/;"	f	namespace:simlib3	signature:(const Value3D& a, const Value3D &b)
simlib3::operator -	simlib3D.h	/^Input3D operator - (Input3D a);                 \/\/ unary -$/;"	p	namespace:simlib3	signature:(Input3D a)
simlib3::operator -	simlib3D.h	/^Input3D operator - (Input3D a, Input3D b);      \/\/ subtract vectors$/;"	p	namespace:simlib3	signature:(Input3D a, Input3D b)
simlib3::operator /	continuous.cc	/^Input operator \/ (Input a, Input b) { return new _Div(a,b); }$/;"	f	namespace:simlib3	signature:(Input a, Input b)
simlib3::operator /	simlib.h	/^Input operator \/ (Input a, Input b);$/;"	p	namespace:simlib3	signature:(Input a, Input b)
simlib3::operator /	simlib2D.cc	/^Input2D operator \/ (Input2D a, Input b)   { return new _Div2D(a,b); }$/;"	f	namespace:simlib3	signature:(Input2D a, Input b)
simlib3::operator /	simlib2D.cc	/^Value2D operator \/(const Value2D& a, const double b)$/;"	f	namespace:simlib3	signature:(const Value2D& a, const double b)
simlib3::operator /	simlib2D.h	/^Input2D operator \/ (Input2D a, Input b);        \/\/ vector \/ scalar$/;"	p	namespace:simlib3	signature:(Input2D a, Input b)
simlib3::operator /	simlib3D.cc	/^Input3D operator \/ (Input3D a, Input b)   { return new _Div3D(a,b); }$/;"	f	namespace:simlib3	signature:(Input3D a, Input b)
simlib3::operator /	simlib3D.cc	/^Value3D operator \/(const Value3D& a, const double b)$/;"	f	namespace:simlib3	signature:(const Value3D& a, const double b)
simlib3::operator /	simlib3D.h	/^Input3D operator \/ (Input3D a, Input b);        \/\/ vector \/ scalar$/;"	p	namespace:simlib3	signature:(Input3D a, Input b)
simlib3::operator ==	opt-param.cc	/^bool operator == (const ParameterVector & p1, const ParameterVector & p2) {$/;"	f	namespace:simlib3	signature:(const ParameterVector & p1, const ParameterVector & p2)
simlib3::opt_function_t	optimize.h	/^typedef double (*opt_function_t) (const ParameterVector & p);$/;"	t	namespace:simlib3
simlib3::scalar_product	simlib2D.cc	/^double scalar_product(const Value2D& a, const Value2D &b)$/;"	f	namespace:simlib3	signature:(const Value2D& a, const Value2D &b)
simlib3::scalar_product	simlib3D.cc	/^double scalar_product(const Value3D& a, const Value3D &b)$/;"	f	namespace:simlib3	signature:(const Value3D& a, const Value3D &b)
simlib3::sign	fun.cc	/^static double sign(double x)$/;"	f	namespace:simlib3	signature:(double x)
size	optimize.h	/^    int size() const { return n; }$/;"	f	class:simlib3::ParameterVector	access:public	signature:() const
size	process.cc	/^    size_t size;        \/\/ size of following array (allocated on heap)$/;"	m	struct:simlib3::P_Context_t	file:	access:public
size	simlib.h	/^    unsigned size() const  { return n; }$/;"	f	class:simlib3::List	access:public	signature:() const
sp	generr.c	/^char *sp = line;$/;"	v
special_input	simlib2D.h	/^    special_input(Input2D i) : a(0,0), in(i), count(0) {}$/;"	f	class:simlib3::Integrator2D::special_input	access:public	signature:(Input2D i)
special_input	simlib2D.h	/^  class special_input : public aContiBlock {$/;"	c	class:simlib3::Integrator2D	inherits:aContiBlock	access:private
special_input	simlib3D.h	/^    special_input(Input3D i) : a(0,0,0), in(i), count(0) {}$/;"	f	class:simlib3::Integrator3D::special_input	access:public	signature:(Input3D i)
special_input	simlib3D.h	/^  class special_input : public aContiBlock {$/;"	c	class:simlib3::Integrator3D	inherits:aContiBlock	access:private
ss	simlib.h	/^  double ss;                           \/\/ status: y = S f(t,y) dt$/;"	m	class:simlib3::Integrator	access:private
ssl	simlib.h	/^  double ssl;                          \/\/ the same from previous step$/;"	m	class:simlib3::Integrator	access:private
st	simlib.h	/^  double st;                           \/\/!< status$/;"	m	class:simlib3::Status	access:public
stack	process.cc	/^    char stack[1];      \/\/ stack contents saved$/;"	m	struct:simlib3::P_Context_t	file:	access:public
stat	simlib.h	/^  Stat     stat;             \/\/ statistics$/;"	m	class:simlib3::Histogram	access:public
status	process.cc	/^    jmp_buf status;     \/\/ stored SP, IP, and other registers$/;"	m	struct:simlib3::P_Context_t	file:	access:public
step	simlib.h	/^    double step;        \/\/!< step of sampling$/;"	m	class:simlib3::Sampler	access:protected
step	simlib.h	/^  double   step;             \/\/ interval width$/;"	m	class:simlib3::Histogram	access:protected
step	simlib.h	/^  double step;                    \/\/ quantum$/;"	m	class:simlib3::Qntzr	access:protected
stl	simlib.h	/^  double stl;                          \/\/!< status from previous step$/;"	m	class:simlib3::Status	access:public
string	internal.h	/^  const char *string; \/\/ module identification string$/;"	m	class:simlib3::SIMLIB_module	access:private
succ	calendar.cc	/^    EventNoticeLinkBase * succ;         \/\/!< next object in list$/;"	m	struct:simlib3::EventNoticeLinkBase	file:	access:public
succ	simlib.h	/^  Link *succ;                          \/\/!< next object in List$/;"	m	class:simlib3::Link	access:private
sumdelta	calendar.cc	/^    double sumdelta;        \/\/ sum for bucket_width estimation$/;"	m	class:simlib3::CalendarQueue	file:	access:private
switchtocq	calendar.cc	/^    void switchtocq();$/;"	p	class:simlib3::CalendarQueue	file:	access:private	signature:()
switchtocq	calendar.cc	/^void CalendarQueue::switchtocq()$/;"	f	class:simlib3::CalendarQueue	signature:()
switchtolist	calendar.cc	/^    void switchtolist();$/;"	p	class:simlib3::CalendarQueue	file:	access:private	signature:()
switchtolist	calendar.cc	/^void CalendarQueue::switchtolist()$/;"	f	class:simlib3::CalendarQueue	signature:()
sx	simlib.h	/^  double sx;                    \/\/ sum of values$/;"	m	class:simlib3::Stat	access:protected
sx2	simlib.h	/^  double sx2;                   \/\/ sum of value square$/;"	m	class:simlib3::Stat	access:protected
sx2t	simlib.h	/^  double sx2t;                  \/\/ sum of squares$/;"	m	class:simlib3::TStat	access:protected
sxt	simlib.h	/^  double sxt;                   \/\/ sum of x*time$/;"	m	class:simlib3::TStat	access:protected
t	_test_.cc	/^Test t(F);          \/\/$/;"	p	file:	signature:(F)
t0	simlib.h	/^  double t0;                    \/\/ time of initialization$/;"	m	class:simlib3::TStat	access:protected
tab	generr.c	/^TABLE *tab;$/;"	v
tabitem	generr.c	/^struct tabitem {$/;"	s	file:
tabitem::ErrId	generr.c	/^    char *ErrId;$/;"	m	struct:tabitem	file:	access:public
tabitem::ErrMsg	generr.c	/^    char *ErrMsg;$/;"	m	struct:tabitem	file:	access:public
tableX	simlib.h	/^  double *tableX;                 \/\/ tabulka X$/;"	m	class:simlib3::Rline	access:protected
tableY	simlib.h	/^  double *tableY;                 \/\/ tabulka Y$/;"	m	class:simlib3::Rline	access:protected
tga	simlib.h	/^    double tga;$/;"	m	class:simlib3::Hyst	access:protected
tga	simlib.h	/^  double tga;$/;"	m	class:simlib3::Blash	access:protected
tgalpha	simlib.h	/^  double tgalpha,tgbeta;          \/\/$/;"	m	class:simlib3::Insv	access:protected
tgalpha	simlib.h	/^  double tgalpha;                 \/\/$/;"	m	class:simlib3::Frict	access:protected
tgalpha	simlib.h	/^  double tgalpha;                 \/\/$/;"	m	class:simlib3::Lim	access:protected
tgbeta	simlib.h	/^  double tgalpha,tgbeta;          \/\/$/;"	m	class:simlib3::Insv	access:protected
time	calendar.cc	/^    double time;$/;"	m	struct:simlib3::EventNotice	file:	access:public
time	delay.cc	/^        double time;    \/\/<! sample time$/;"	m	struct:simlib3::SIMLIB_DelayBuffer::Pair	file:	access:public
time2bucket	calendar.cc	/^    inline int time2bucket (double t) {$/;"	f	class:simlib3::CalendarQueue	file:	access:private	signature:(double t)
time2bucket_top	calendar.cc	/^    inline double time2bucket_top(double t) {$/;"	f	class:simlib3::CalendarQueue	file:	access:private	signature:(double t)
tittle	generr.c	/^char tittle[] =$/;"	v
tl	simlib.h	/^  double tl;                    \/\/ last record time$/;"	m	class:simlib3::TStat	access:protected
tstat	simlib.h	/^  TStat tstat;                  \/\/!< usage statistics$/;"	m	class:simlib3::Store	access:public
tstat	simlib.h	/^  TStat tstat;               \/\/ stat$/;"	m	class:simlib3::Facility	access:public
unlock	internal.h	/^    void unlock() {$/;"	f	class:simlib3::AlgLoopDetector	access:private	signature:()
used	simlib.h	/^  unsigned long used;            \/\/ used capacity$/;"	m	class:simlib3::Store	access:private
v	_test_.cc	/^  Integrator v;$/;"	m	struct:Test	file:	access:public
value	delay.cc	/^        double value;   \/\/<! sampled value$/;"	m	struct:simlib3::SIMLIB_DelayBuffer::Pair	file:	access:public
value	optimize.h	/^    double value;$/;"	m	class:simlib3::Param	access:private
value	simlib.h	/^  const double value;$/;"	m	class:simlib3::Constant	access:private
value	simlib.h	/^  double value;$/;"	m	class:simlib3::Parameter	access:private
value	simlib.h	/^  double value;$/;"	m	class:simlib3::Variable	access:private
value	simlib2D.h	/^  Value2D value;$/;"	m	class:simlib3::Variable2D	access:protected
value	simlib2D.h	/^  const Value2D value;$/;"	m	class:simlib3::Constant2D	access:private
value	simlib3D.h	/^  Value3D value;$/;"	m	class:simlib3::Variable3D	access:protected
value	simlib3D.h	/^  const Value3D value;$/;"	m	class:simlib3::Constant3D	access:private
visualize	calendar.cc	/^    void visualize(const char *msg);$/;"	p	class:simlib3::CalendarQueue	file:	access:public	signature:(const char *msg)
visualize	calendar.cc	/^void CalendarQueue::visualize(const char *msg)$/;"	f	class:simlib3::CalendarQueue	signature:(const char *msg)
waiting	simlib.h	/^  Entity **waiting;     \/\/!< array of waiting entities (fixed size)$/;"	m	class:simlib3::Barrier	access:protected
was_cycle	simlib.h	/^  bool was_cycle; \/\/ flag for going through loop$/;"	m	class:simlib3::AlgLoop	access:protected
which	simlib2D.cc	/^  WhichPart which;$/;"	m	class:simlib3::_XYpart	file:	access:private
which	simlib3D.cc	/^  WhichPart which;$/;"	m	class:simlib3::_XYZpart	file:	access:private
x	simlib2D.cc	/^  enum WhichPart { x,y }; \/\/ part identification$/;"	e	enum:simlib3::_XYpart::WhichPart	file:
x	simlib2D.h	/^  Input x, y;$/;"	m	class:simlib3::Adaptor2D	access:private
x	simlib2D.h	/^  double x() const { return _x; }$/;"	f	class:simlib3::Value2D	access:public	signature:() const
x	simlib3D.cc	/^  enum WhichPart { x,y,z }; \/\/ part identification$/;"	e	enum:simlib3::_XYZpart::WhichPart	file:
x	simlib3D.h	/^  Input x, y, z;$/;"	m	class:simlib3::Adaptor3D	access:private
x	simlib3D.h	/^  double x() const { return _x; }$/;"	f	class:simlib3::Value3D	access:public	signature:() const
xi	ni_euler.h	/^  StatusMemory xi;$/;"	m	class:simlib3::EULER	access:private
xi	ni_rke.h	/^  StatusMemory xi;$/;"	m	class:simlib3::RKE	access:private
xl	simlib.h	/^  double xl;                    \/\/ last recorded value x$/;"	m	class:simlib3::TStat	access:protected
y	_test_.cc	/^  Status y;$/;"	m	struct:Test	file:	access:public
y	simlib2D.cc	/^  enum WhichPart { x,y }; \/\/ part identification$/;"	e	enum:simlib3::_XYpart::WhichPart	file:
y	simlib2D.h	/^  Input x, y;$/;"	m	class:simlib3::Adaptor2D	access:private
y	simlib2D.h	/^  double y() const { return _y; }$/;"	f	class:simlib3::Value2D	access:public	signature:() const
y	simlib3D.cc	/^  enum WhichPart { x,y,z }; \/\/ part identification$/;"	e	enum:simlib3::_XYZpart::WhichPart	file:
y	simlib3D.h	/^  Input x, y, z;$/;"	m	class:simlib3::Adaptor3D	access:private
y	simlib3D.h	/^  double y() const { return _y; }$/;"	f	class:simlib3::Value3D	access:public	signature:() const
y1	simlib.h	/^    double y1,y2;$/;"	m	class:simlib3::Hyst	access:protected
y1	simlib.h	/^  double y1,y2;                 \/\/ points on y-axis$/;"	m	class:simlib3::Relay	access:protected
y2	simlib.h	/^    double y1,y2;$/;"	m	class:simlib3::Hyst	access:protected
y2	simlib.h	/^  double y1,y2;                 \/\/ points on y-axis$/;"	m	class:simlib3::Relay	access:protected
z	simlib3D.cc	/^  enum WhichPart { x,y,z }; \/\/ part identification$/;"	e	enum:simlib3::_XYZpart::WhichPart	file:
z	simlib3D.h	/^  Input x, y, z;$/;"	m	class:simlib3::Adaptor3D	access:private
z	simlib3D.h	/^  double z() const { return _z; }$/;"	f	class:simlib3::Value3D	access:public	signature:() const
~ABM4	ni_abm4.h	/^  virtual ~ABM4()  \/\/ destructor$/;"	f	class:simlib3::ABM4	access:public	signature:()
~AlgLoopDetector	internal.h	/^    ~AlgLoopDetector() { unlock(); }$/;"	f	class:simlib3::AlgLoopDetector	access:public	signature:()
~Barrier	barrier.cc	/^Barrier::~Barrier() {$/;"	f	class:simlib3::Barrier	signature:()
~Barrier	simlib.h	/^  virtual ~Barrier();$/;"	p	class:simlib3::Barrier	access:public	signature:()
~Buffer	delay.cc	/^    virtual ~Buffer() {};$/;"	f	struct:simlib3::Delay::Buffer	access:public	signature:()
~Buffer	delay.h	/^        virtual ~Buffer() {};$/;"	f	struct:simlib3::Delay::Buffer	access:public	signature:()
~Calendar	calendar.cc	/^    virtual ~Calendar() {} \/\/!< clear is called in derived class dtr$/;"	f	class:simlib3::Calendar	access:protected	signature:()
~CalendarList	calendar.cc	/^    ~CalendarList() {$/;"	f	class:simlib3::CalendarList	file:	access:private	signature:()
~CalendarListImplementation	calendar.cc	/^    ~ CalendarListImplementation() {$/;"	f	class:simlib3::CalendarListImplementation	access:public	signature:()
~CalendarQueue	calendar.cc	/^    ~CalendarQueue();$/;"	p	class:simlib3::CalendarQueue	file:	access:private	signature:()
~CalendarQueue	calendar.cc	/^CalendarQueue::~CalendarQueue()$/;"	f	class:simlib3::CalendarQueue	signature:()
~Condition	cond.cc	/^Condition::~Condition()$/;"	f	class:simlib3::Condition	signature:()
~Condition	simlib.h	/^  ~Condition();$/;"	p	class:simlib3::Condition	access:public	signature:()
~Delay	delay.cc	/^Delay::~Delay()$/;"	f	class:simlib3::Delay	signature:()
~Delay	delay.h	/^    ~Delay();$/;"	p	class:simlib3::Delay	access:public	signature:()
~EULER	ni_euler.h	/^  virtual ~EULER()  \/\/ destructor$/;"	f	class:simlib3::EULER	access:public	signature:()
~Entity	entity.cc	/^Entity::~Entity() {$/;"	f	class:simlib3::Entity	signature:()
~Entity	simlib.h	/^    virtual ~Entity();$/;"	p	class:simlib3::Entity	access:public	signature:()
~Event	event.cc	/^Event::~Event()$/;"	f	class:simlib3::Event	signature:()
~Event	simlib.h	/^  virtual ~Event();$/;"	p	class:simlib3::Event	access:public	signature:()
~EventNotice	calendar.cc	/^    ~EventNotice() {$/;"	f	struct:simlib3::EventNotice	access:public	signature:()
~EventNoticeAllocator	calendar.cc	/^    ~EventNoticeAllocator() {$/;"	f	class:simlib3::EventNoticeAllocator	access:public	signature:()
~FW	ni_fw.h	/^  virtual ~FW()  \/\/ destructor$/;"	f	class:simlib3::FW	access:public	signature:()
~Facility	facility.cc	/^Facility::~Facility()$/;"	f	class:simlib3::Facility	signature:()
~Facility	simlib.h	/^  virtual ~Facility();$/;"	p	class:simlib3::Facility	access:public	signature:()
~Graph	graph.cc	/^Graph::~Graph()$/;"	f	class:simlib3::Graph	signature:()
~Histogram	histo.cc	/^Histogram::~Histogram()$/;"	f	class:simlib3::Histogram	signature:()
~Histogram	simlib.h	/^  ~Histogram();$/;"	p	class:simlib3::Histogram	access:public	signature:()
~Input	simlib.h	/^  ~Input() { UnRegisterReference(bp); }$/;"	f	class:simlib3::Input	access:public	signature:()
~IntegrationMethod	numint.cc	/^IntegrationMethod::~IntegrationMethod() {$/;"	f	class:simlib3::IntegrationMethod	signature:()
~IntegrationMethod	simlib.h	/^  virtual ~IntegrationMethod();  \/\/ destructor unregistrates method$/;"	p	class:simlib3::IntegrationMethod	access:public	signature:()
~Integrator	intg.cc	/^Integrator::~Integrator()$/;"	f	class:simlib3::Integrator	signature:()
~Integrator	simlib.h	/^  ~Integrator();$/;"	p	class:simlib3::Integrator	access:public	signature:()
~Link	link.cc	/^Link::~Link() {$/;"	f	class:simlib3::Link	signature:()
~Link	simlib.h	/^  virtual ~Link();$/;"	p	class:simlib3::Link	access:public	signature:()
~List	list.cc	/^List::~List() {$/;"	f	class:simlib3::List	signature:()
~List	simlib.h	/^    ~List();$/;"	p	class:simlib3::List	access:public	signature:()
~Memory	numint.cc	/^IntegrationMethod::Memory::~Memory()$/;"	f	class:simlib3::IntegrationMethod::Memory	signature:()
~Memory	simlib.h	/^      virtual ~Memory();$/;"	p	class:simlib3::IntegrationMethod::Memory	access:public	signature:()
~MultiStepMethod	numint.cc	/^MultiStepMethod::~MultiStepMethod()$/;"	f	class:simlib3::MultiStepMethod	signature:()
~MultiStepMethod	simlib.h	/^  ~MultiStepMethod();  \/\/ destructor frees dynamic data$/;"	p	class:simlib3::MultiStepMethod	access:public	signature:()
~ParameterVector	opt-param.cc	/^ParameterVector::~ParameterVector()$/;"	f	class:simlib3::ParameterVector	signature:()
~ParameterVector	optimize.h	/^   ~ParameterVector();$/;"	p	class:simlib3::ParameterVector	access:public	signature:()
~Process	process.cc	/^Process::~Process()$/;"	f	class:simlib3::Process	signature:()
~Process	simlib.h	/^  virtual ~Process();$/;"	p	class:simlib3::Process	access:public	signature:()
~Queue	queue.cc	/^Queue::~Queue() {$/;"	f	class:simlib3::Queue	signature:()
~Queue	simlib.h	/^    ~Queue();$/;"	p	class:simlib3::Queue	access:public	signature:()
~RKE	ni_rke.h	/^  virtual ~RKE()  \/\/ destructor$/;"	f	class:simlib3::RKE	access:public	signature:()
~RKF3	ni_rkf3.h	/^  virtual ~RKF3()  \/\/ destructor$/;"	f	class:simlib3::RKF3	access:public	signature:()
~RKF5	ni_rkf5.h	/^  virtual ~RKF5()  \/\/ destructor$/;"	f	class:simlib3::RKF5	access:public	signature:()
~RKF8	ni_rkf8.h	/^  virtual ~RKF8()  \/\/ destructor$/;"	f	class:simlib3::RKF8	access:public	signature:()
~Rline	simlib.h	/^  ~Rline();$/;"	p	class:simlib3::Rline	access:public	signature:()
~Rline	stdblock.cc	/^Rline::~Rline()$/;"	f	class:simlib3::Rline	signature:()
~SIMLIB_module	atexit.cc	/^SIMLIB_module::~SIMLIB_module() {$/;"	f	class:simlib3::SIMLIB_module	signature:()
~SIMLIB_module	internal.h	/^  ~SIMLIB_module(); \/\/ last can do ATEXIT ?$/;"	p	class:simlib3::SIMLIB_module	access:public	signature:()
~Sampler	sampler.cc	/^Sampler::~Sampler()$/;"	f	class:simlib3::Sampler	signature:()
~Sampler	simlib.h	/^    virtual ~Sampler();$/;"	p	class:simlib3::Sampler	access:public	signature:()
~Semaphore	semaphor.cc	/^Semaphore::~Semaphore()$/;"	f	class:simlib3::Semaphore	signature:()
~Semaphore	simlib.h	/^  virtual ~Semaphore();$/;"	p	class:simlib3::Semaphore	access:public	signature:()
~SimObject	object.cc	/^SimObject::~SimObject()$/;"	f	class:simlib3::SimObject	signature:()
~SimObject	simlib.h	/^  virtual ~SimObject();$/;"	p	class:simlib3::SimObject	access:public	signature:()
~Stat	simlib.h	/^  ~Stat();$/;"	p	class:simlib3::Stat	access:public	signature:()
~Stat	stat.cc	/^Stat::~Stat()$/;"	f	class:simlib3::Stat	signature:()
~Status	intg.cc	/^Status::~Status() {$/;"	f	class:simlib3::Status	signature:()
~Status	simlib.h	/^  ~Status();$/;"	p	class:simlib3::Status	access:public	signature:()
~StatusMemory	simlib.h	/^    virtual ~StatusMemory() { }$/;"	f	class:simlib3::StatusMethod::StatusMemory	access:public	signature:()
~StatusMethod	simlib.h	/^  virtual ~StatusMethod() { } \/\/ free dynamic datas$/;"	f	class:simlib3::StatusMethod	access:public	signature:()
~Store	simlib.h	/^  virtual ~Store();$/;"	p	class:simlib3::Store	access:public	signature:()
~Store	store.cc	/^Store::~Store()$/;"	f	class:simlib3::Store	signature:()
~TStat	simlib.h	/^  ~TStat();$/;"	p	class:simlib3::TStat	access:public	signature:()
~TStat	tstat.cc	/^TStat::~TStat()$/;"	f	class:simlib3::TStat	signature:()
~WaitUntilList	waitunti.cc	/^    ~WaitUntilList() { Dprintf(("WaitUntilList::~WaitUntilList()")); }$/;"	f	class:simlib3::WaitUntilList	file:	access:private	signature:()
~ZDelay	zdelay.cc	/^ZDelay::~ZDelay()$/;"	f	class:simlib3::ZDelay	signature:()
~ZDelay	zdelay.h	/^    ~ZDelay();$/;"	p	class:simlib3::ZDelay	access:public	signature:()
~ZDelayTimer	zdelay.cc	/^ZDelayTimer::~ZDelayTimer()$/;"	f	class:simlib3::ZDelayTimer	signature:()
~ZDelayTimer	zdelay.h	/^    ~ZDelayTimer();$/;"	p	class:simlib3::ZDelayTimer	access:public	signature:()
~_Add	continuous.cc	/^  ~_Add() {$/;"	f	class:simlib3::_Add	access:public	signature:()
~_Div	continuous.cc	/^  ~_Div() {$/;"	f	class:simlib3::_Div	access:public	signature:()
~_Mul	continuous.cc	/^  ~_Mul() {$/;"	f	class:simlib3::_Mul	access:public	signature:()
~_Sub	continuous.cc	/^  ~_Sub() {$/;"	f	class:simlib3::_Sub	access:public	signature:()
~_UMinus	continuous.cc	/^  ~_UMinus() {$/;"	f	class:simlib3::_UMinus	access:public	signature:()
~aCondition	cond.cc	/^aCondition::~aCondition() {$/;"	f	class:simlib3::aCondition	signature:()
~aCondition	simlib.h	/^  ~aCondition();$/;"	p	class:simlib3::aCondition	access:public	signature:()
~aContiBlock2D	simlib2D.cc	/^aContiBlock2D::~aContiBlock2D() {$/;"	f	class:simlib3::aContiBlock2D	signature:()
~aContiBlock2D	simlib2D.h	/^  ~aContiBlock2D();$/;"	p	class:simlib3::aContiBlock2D	access:public	signature:()
~aContiBlock3D	simlib3D.cc	/^aContiBlock3D::~aContiBlock3D() {$/;"	f	class:simlib3::aContiBlock3D	signature:()
~aContiBlock3D	simlib3D.h	/^  ~aContiBlock3D();$/;"	p	class:simlib3::aContiBlock3D	access:public	signature:()
~aStat	simlib.h	/^  ~aStat();$/;"	p	class:simlib3::aStat	access:public	signature:()
